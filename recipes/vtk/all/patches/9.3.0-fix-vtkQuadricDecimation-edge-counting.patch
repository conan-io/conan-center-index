Improve performance for edge-counting

--- a/Filters/Core/vtkQuadricDecimation.cxx	2024-05-27 12:59:27.603883200 +0800
+++ b/Filters/Core/vtkQuadricDecimation.cxx	2024-05-27 13:07:02.214895600 +0800
@@ -713,6 +713,59 @@
   delete[] QEM;
 }
 
+// an edge consists of two id's and their order
+// is *not* important. To that end special hash and
+// equals functions have been made
+// typedef std::pair<vtkIdType, vtkIdType> Edge;
+
+struct Edge : public std::pair<vtkIdType, vtkIdType>
+{
+public:
+  Edge() = default;
+  Edge(vtkIdType a, vtkIdType b)
+    : std::pair<vtkIdType, vtkIdType>(a, b)
+  {
+  }
+  Edge(vtkCell* edge)
+    : std::pair<vtkIdType, vtkIdType>(edge->GetPointId(0), edge->GetPointId(1))
+  {
+  }
+  friend ostream& operator<<(ostream& stream, const Edge& e)
+  {
+    stream << e.first << " - " << e.second;
+    return stream;
+  }
+};
+
+struct hash_fn
+{
+  size_t operator()(Edge const& p) const
+  {
+    size_t i = (size_t)p.first;
+    size_t j = (size_t)p.second;
+
+    // first make order-independent, i.e. hash(i,j) == hash(j,i)
+    if (i < j)
+    {
+      size_t tmp = i;
+      i = j;
+      j = tmp;
+    }
+
+    // then XOR both together , multiplied by two primes to try to prevent collisions
+    return (17 * i) ^ (31 * j);
+  }
+};
+
+struct equal_fn
+{
+  bool operator()(Edge const& e1, Edge const& e2) const
+  {
+    return (e1.first == e2.first && e1.second == e2.second) ||
+      (e1.second == e2.first && e1.first == e2.second);
+  }
+};
+
 void vtkQuadricDecimation::AddBoundaryConstraints()
 {
   vtkPolyData* input = this->Mesh;
@@ -723,7 +776,18 @@
   const vtkIdType* pts;
   double t0[3], t1[3], t2[3];
   double e0[3], e1[3], n[3], c, w;
-  vtkIdList* cellIds = vtkIdList::New();
+  std::unordered_map<Edge, int, hash_fn, equal_fn> edgeCount;
+
+  for (cellId = 0; cellId < input->GetNumberOfCells(); cellId++)
+  {
+   input->GetCellPoints(cellId, npts, pts);
+
+    for (i = 0; i < 3; i++)
+    {
+      Edge e (pts[i], pts[(i + 1) % 3]);
+      edgeCount[e]++;
+    }
+  }
 
   // allocate local QEM space matrix
   QEM = new double[11 + 4 * this->NumberOfComponents];
@@ -734,8 +798,9 @@
 
     for (i = 0; i < 3; i++)
     {
-      input->GetCellEdgeNeighbors(cellId, pts[i], pts[(i + 1) % 3], cellIds);
-      if (cellIds->GetNumberOfIds() == 0)
+      Edge e (pts[i], pts[(i + 1) % 3]);
+
+      if (edgeCount[e] == 1)
       {
         // this is a boundary
         input->GetPoint(pts[(i + 2) % 3], t0);
@@ -817,7 +882,6 @@
       }
     }
   }
-  cellIds->Delete();
   delete[] QEM;
 }
 
