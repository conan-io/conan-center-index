diff --git a/include/jwt-cpp/base.h b/include/jwt-cpp/base.h
--- a/include/jwt-cpp/base.h
+++ b/include/jwt-cpp/base.h
@@ -120,7 +120,7 @@ namespace jwt {
 			auto get_sextet = [&](size_t offset) {
 				for (size_t i = 0; i < alphabet.size(); i++) {
 					if (alphabet[i] == base[offset])
-						return i;
+						return static_cast<uint32_t>(i);
 				}
 				throw std::runtime_error("Invalid input");
 			};
diff --git a/include/jwt-cpp/jwt.h b/include/jwt-cpp/jwt.h
--- a/include/jwt-cpp/jwt.h
+++ b/include/jwt-cpp/jwt.h
@@ -99,10 +99,10 @@ namespace jwt {
 			std::unique_ptr<BIO, decltype(&BIO_free_all)> pubkey_bio(BIO_new(BIO_s_mem()), BIO_free_all);
 			if(key.substr(0, 27) == "-----BEGIN CERTIFICATE-----") {
 				auto epkey = helper::extract_pubkey_from_cert(key, password);
-				if ((size_t)BIO_write(pubkey_bio.get(), epkey.data(), epkey.size()) != epkey.size())
+				if ((size_t)BIO_write(pubkey_bio.get(), epkey.data(), (int)epkey.size()) != epkey.size())
 					throw rsa_exception("failed to load public key: bio_write failed");
 			} else {
-				if ((size_t)BIO_write(pubkey_bio.get(), key.data(), key.size()) != key.size())
+				if ((size_t)BIO_write(pubkey_bio.get(), key.data(), (int)key.size()) != key.size())
 					throw rsa_exception("failed to load public key: bio_write failed");
 			}
 			
@@ -115,7 +115,7 @@ namespace jwt {
 		inline
 		std::shared_ptr<EVP_PKEY> load_private_key_from_string(const std::string& key, const std::string& password = "") {
 			std::unique_ptr<BIO, decltype(&BIO_free_all)> privkey_bio(BIO_new(BIO_s_mem()), BIO_free_all);
-			if ((size_t)BIO_write(privkey_bio.get(), key.data(), key.size()) != key.size())
+			if ((size_t)BIO_write(privkey_bio.get(), key.data(), (int)key.size()) != key.size())
 				throw rsa_exception("failed to load private key: bio_write failed");
 			std::shared_ptr<EVP_PKEY> pkey(PEM_read_bio_PrivateKey(privkey_bio.get(), nullptr, nullptr, const_cast<char*>(password.c_str())), EVP_PKEY_free);
 			if (!pkey)
@@ -168,7 +168,7 @@ namespace jwt {
 				std::string res;
 				res.resize(EVP_MAX_MD_SIZE);
 				unsigned int len = res.size();
-				if (HMAC(md(), secret.data(), secret.size(), (const unsigned char*)data.data(), data.size(), (unsigned char*)res.data(), &len) == nullptr)
+				if (HMAC(md(), secret.data(), (int)secret.size(), (const unsigned char*)data.data(), (int)data.size(), (unsigned char*)res.data(), &len) == nullptr)
 					throw signature_generation_exception();
 				res.resize(len);
 				return res;
@@ -278,9 +278,9 @@ namespace jwt {
 					throw signature_verification_exception("failed to verify signature: could not create context");
 				if (!EVP_VerifyInit(ctx.get(), md()))
 					throw signature_verification_exception("failed to verify signature: VerifyInit failed");
-				if (!EVP_VerifyUpdate(ctx.get(), data.data(), data.size()))
+				if (!EVP_VerifyUpdate(ctx.get(), data.data(), (int)data.size()))
 					throw signature_verification_exception("failed to verify signature: VerifyUpdate failed");
-				auto res = EVP_VerifyFinal(ctx.get(), (const unsigned char*)signature.data(), signature.size(), pkey.get());
+				auto res = EVP_VerifyFinal(ctx.get(), (const unsigned char*)signature.data(), (int)signature.size(), pkey.get());
 				if (res != 1)
 					throw signature_verification_exception("evp verify final failed: " + std::to_string(res) + " " + ERR_error_string(ERR_get_error(), NULL));
 			}
@@ -319,10 +319,10 @@ namespace jwt {
 					std::unique_ptr<BIO, decltype(&BIO_free_all)> pubkey_bio(BIO_new(BIO_s_mem()), BIO_free_all);
 					if(public_key.substr(0, 27) == "-----BEGIN CERTIFICATE-----") {
 						auto epkey = helper::extract_pubkey_from_cert(public_key, public_key_password);
-						if ((size_t)BIO_write(pubkey_bio.get(), epkey.data(), epkey.size()) != epkey.size())
+						if ((size_t)BIO_write(pubkey_bio.get(), epkey.data(), (int)epkey.size()) != epkey.size())
 							throw ecdsa_exception("failed to load public key: bio_write failed");
 					} else  {
-						if ((size_t)BIO_write(pubkey_bio.get(), public_key.data(), public_key.size()) != public_key.size())
+						if ((size_t)BIO_write(pubkey_bio.get(), public_key.data(), (int)public_key.size()) != public_key.size())
 							throw ecdsa_exception("failed to load public key: bio_write failed");
 					}
 
@@ -333,7 +333,7 @@ namespace jwt {
 
 				if (!private_key.empty()) {
 					std::unique_ptr<BIO, decltype(&BIO_free_all)> privkey_bio(BIO_new(BIO_s_mem()), BIO_free_all);
-					if ((size_t)BIO_write(privkey_bio.get(), private_key.data(), private_key.size()) != private_key.size())
+					if ((size_t)BIO_write(privkey_bio.get(), private_key.data(), (int)private_key.size()) != private_key.size())
 						throw rsa_exception("failed to load private key: bio_write failed");
 					pkey.reset(PEM_read_bio_ECPrivateKey(privkey_bio.get(), nullptr, nullptr, const_cast<char*>(private_key_password.c_str())), EC_KEY_free);
 					if (!pkey)
@@ -355,7 +355,7 @@ namespace jwt {
 				const std::string hash = generate_hash(data);
 
 				std::unique_ptr<ECDSA_SIG, decltype(&ECDSA_SIG_free)>
-					sig(ECDSA_do_sign((const unsigned char*)hash.data(), hash.size(), pkey.get()), ECDSA_SIG_free);
+					sig(ECDSA_do_sign((const unsigned char*)hash.data(), (int)hash.size(), pkey.get()), ECDSA_SIG_free);
 				if(!sig)
 					throw signature_generation_exception();
 #ifdef OPENSSL10
@@ -384,14 +384,14 @@ namespace jwt {
 				sig.r = r.get();
 				sig.s = s.get();
 
-				if(ECDSA_do_verify((const unsigned char*)hash.data(), hash.size(), &sig, pkey.get()) != 1)
+				if(ECDSA_do_verify((const unsigned char*)hash.data(), (int)hash.size(), &sig, pkey.get()) != 1)
 					throw signature_verification_exception("Invalid signature");
 #else
 				ECDSA_SIG *sig = ECDSA_SIG_new();
 
 				ECDSA_SIG_set0(sig, r.get(), s.get());
 
-				if(ECDSA_do_verify((const unsigned char*)hash.data(), hash.size(), sig, pkey.get()) != 1)
+				if(ECDSA_do_verify((const unsigned char*)hash.data(), (int)hash.size(), sig, pkey.get()) != 1)
 					throw signature_verification_exception("Invalid signature");
 #endif
 			}
@@ -448,7 +448,7 @@ namespace jwt {
 #endif
 				if(EVP_DigestInit(ctx.get(), md()) == 0)
 					throw signature_generation_exception("EVP_DigestInit failed");
-				if(EVP_DigestUpdate(ctx.get(), data.data(), data.size()) == 0)
+				if(EVP_DigestUpdate(ctx.get(), data.data(), (int)data.size()) == 0)
 					throw signature_generation_exception("EVP_DigestUpdate failed");
 				unsigned int len = 0;
 				std::string res;
@@ -524,7 +524,7 @@ namespace jwt {
 				const int size = RSA_size(key.get());
 				
 				std::string sig(size, 0x00);
-				if(!RSA_public_decrypt(signature.size(), (const unsigned char*)signature.data(), (unsigned char*)sig.data(), key.get(), RSA_NO_PADDING))
+				if(!RSA_public_decrypt((int)signature.size(), (const unsigned char*)signature.data(), (unsigned char*)sig.data(), key.get(), RSA_NO_PADDING))
 					throw signature_verification_exception("Invalid signature");
 				
 				if(!RSA_verify_PKCS1_PSS_mgf1(key.get(), (const unsigned char*)hash.data(), md(), md(), (const unsigned char*)sig.data(), -1))
@@ -551,7 +551,7 @@ namespace jwt {
 #endif
 				if(EVP_DigestInit(ctx.get(), md()) == 0)
 					throw signature_generation_exception("EVP_DigestInit failed");
-				if(EVP_DigestUpdate(ctx.get(), data.data(), data.size()) == 0)
+				if(EVP_DigestUpdate(ctx.get(), data.data(), (int)data.size()) == 0)
 					throw signature_generation_exception("EVP_DigestUpdate failed");
 				unsigned int len = 0;
 				std::string res;
