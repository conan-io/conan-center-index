diff --git CMakeLists.txt CMakeLists.txt
index ea088e9..f94ecb1 100644
--- CMakeLists.txt
+++ CMakeLists.txt
@@ -202,8 +202,6 @@ endif()

 set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)

-set(CMAKE_POSITION_INDEPENDENT_CODE ON)
-
 set(
   sources
   src/cpptrace.cpp
@@ -228,6 +226,7 @@ if(CPPTRACE_STATIC)
   add_library(cpptrace STATIC ${sources} include/cpptrace/cpptrace.hpp)
 else()
   add_library(cpptrace SHARED ${sources} include/cpptrace/cpptrace.hpp)
+  set_property(TARGET cpptrace PROPERTY POSITION_INDEPENDENT_CODE ON)
 endif()

 target_include_directories(
@@ -250,9 +249,8 @@ set_target_properties(
 target_compile_options(
   cpptrace
   PRIVATE
-  #  -Wshadow
   $<$<NOT:$<CXX_COMPILER_ID:MSVC>>:-Wall -Wextra -Werror=return-type -Wundef>
-  $<$<CXX_COMPILER_ID:GNU>:-Wuseless-cast -Wnonnull-compare>
+  $<$<CXX_COMPILER_ID:GNU>:-Wuseless-cast>
   $<$<CXX_COMPILER_ID:MSVC>:/W4 /WX /permissive->
 )

diff --git bundled/libdwarf/CMakeLists.txt bundled/libdwarf/CMakeLists.txt
index bc30c88..b272e94 100644
--- bundled/libdwarf/CMakeLists.txt
+++ bundled/libdwarf/CMakeLists.txt
@@ -421,12 +421,10 @@ set(

 set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)

-### libassert uses relocs, -fpic has to be used to allow shared libs to link libassert as a static library.
-##set(CMAKE_POSITION_INDEPENDENT_CODE ON)
-
 include(GNUInstallDirs)

-add_library(dwarf STATIC ${libdwarf_sources} ${libdwarf_headers})
+add_library(dwarf OBJECT ${libdwarf_sources} ${libdwarf_headers})
+set_property(TARGET dwarf PROPERTY POSITION_INDEPENDENT_CODE ON)

 target_compile_definitions(dwarf PUBLIC LIBDWARF_BUILD)

diff --git src/symbols/symbols_with_libdwarf.cpp src/symbols/symbols_with_libdwarf.cpp
index ea52632..314a402 100644
--- src/symbols/symbols_with_libdwarf.cpp
+++ src/symbols/symbols_with_libdwarf.cpp
@@ -458,7 +458,8 @@ namespace libdwarf {
                     &table_count,
                     &line_context
                 );
-                VERIFY(table_count >= 0 && table_count <= 2, "Unknown dwarf line table count");
+                static_assert(std::is_unsigned<decltype(table_count)>::value, "Expected unsigned Dwarf_Small");
+                VERIFY(/*table_count >= 0 &&*/ table_count <= 2, "Unknown dwarf line table count");
                 if(ret == DW_DLV_NO_ENTRY) {
                     // TODO: Failing silently for now
                     return;
@@ -674,7 +675,8 @@ namespace libdwarf {
                     }
                 }
                 if(resolver_object.has_value() && get_cache_mode() == cache_mode::prioritize_speed) {
-                    resolver_map.insert({obj_name, std::move(resolver_object).unwrap()});
+                    // .emplace needed, for some reason .insert tries to copy <= gcc 7.2
+                    resolver_map.emplace(obj_name, std::move(resolver_object).unwrap());
                 }
             } catch(...) {
                 if(!should_absorb_trace_exceptions()) {
diff --git src/unwind/unwind_with_dbghelp.cpp src/unwind/unwind_with_dbghelp.cpp
index c6f035a..995cdd3 100644
--- src/unwind/unwind_with_dbghelp.cpp
+++ src/unwind/unwind_with_dbghelp.cpp
@@ -21,6 +21,10 @@

 namespace cpptrace {
 namespace detail {
+    #if IS_MSVC
+    #pragma warning(push)
+    #pragma warning(disable: 4740) // warning C4740: flow in or out of inline asm code suppresses global optimization
+    #endif
     CPPTRACE_FORCE_NO_INLINE
     std::vector<uintptr_t> capture_frames(size_t skip, size_t max_depth) {
         skip++;
@@ -121,7 +138,7 @@ namespace detail {
                     // On x86/x64/arm, as far as I can tell, the frame return address is always one after the call
                     // So we just decrement to get the pc back inside the `call` / `bl`
                     // This is done with _Unwind too but conditionally based on info from _Unwind_GetIPInfo.
-                    trace.push_back(frame.AddrPC.Offset - 1);
+                    trace.push_back(static_cast<uintptr_t>(frame.AddrPC.Offset) - 1);
                 }
             } else {
                 // base
@@ -135,6 +152,9 @@ namespace detail {
         }
         return trace;
     }
+    #if IS_MSVC
+    #pragma warning(pop)
+    #endif
 }
 }

