import json
import re
import textwrap
from pathlib import Path, PurePosixPath

from conan import ConanFile
from conan.errors import ConanInvalidConfiguration
from conan.tools.build import check_min_cppstd
from conan.tools.cmake import CMake, CMakeDeps, CMakeToolchain, cmake_layout
from conan.tools.files import copy, export_conandata_patches, get, replace_in_file, rm, rmdir, save, load
from conan.tools.microsoft import is_msvc
from conan.tools.scm import Version
import os


required_conan_version = ">=2.0.9"


def components_from_dotfile(dotfile):
    """
    Parse the dotfile generated by the
    [cmake --graphviz](https://cmake.org/cmake/help/latest/module/CMakeGraphVizOptions.html)
    option to generate the list of available Clang CMake targets and their inter-component dependencies.

    In future a [CPS](https://cps-org.github.io/cps/index.html) format could be used, or generated directly
    by the LLVM/Clang build system
    """
    def node_labels(dot):
        """
        match each node in the dotfile with a label property, and map the label to a conan component
        """
        for row in dot:
            match_label = re.match(r'''^\s*"(node[0-9]+)"\s*\[\s*label\s*=\s*"(.+)".*''', row)
            if match_label:
                node = match_label.group(1)
                label = match_label.group(2)
                if label.startswith("LLVM"):
                    yield node, f"llvm-core::{label}"
                else:
                    yield node, label

    def component_and_dependency(dot):
        """
        Using the nodes with labels, extract the component dependencies of each node,
        ie -  each node->dependency pair in the dotfile
        """
        def is_package_label(label):
            # Other components of interest end in `-resource-headers`. These are not libraries
            # but sets of header files that may be of use to clang consumers. Making these available
            # via conan is left for a future enhancement
            return label.startswith("clang") and not label.endswith("-resource-headers")

        labels = {k: v for k, v in node_labels(dot)}
        for row in dot:
            match_dep = re.match(r'''^\s*"(node[0-9]+)"\s*->\s*"(node[0-9]+)".*''', row)
            if match_dep:
                node_label = labels[match_dep.group(1)]
                if is_package_label(node_label):
                    yield node_label, labels[match_dep.group(2)]
        # some components don't have dependencies
        for label in labels.values():
            if is_package_label(label):
                yield label, None

    def component_key(dependency):
        return "requires"

    components = {}
    dotfile_rows = dotfile.split("\n")
    for component, dependency in component_and_dependency(dotfile_rows):
        key = component_key(dependency)
        if key is None:
            continue

        if not component in components:
            components[component] = { "system_libs": [], "requires": [] }
            if dependency is not None:
                components[component][key] = [dependency]
        elif dependency is not None:
            components[component][key].append(dependency)

    return components


class ClangConan(ConanFile):
    name = "clang"
    description = "The Clang project provides a language front-end and tooling infrastructure for languages in the C language family"
    license = "Apache-2 with LLVM-exception"
    url = "https://github.com/conan-io/conan-center-index"
    homepage = "https://clang.llvm.org/"
    topics = ("clang", "llvm", "compiler")
    package_type = "library"
    settings = "os", "arch", "compiler", "build_type"
    options = {
        "shared": [True, False],
        "fPIC": [True, False],
    }
    default_options = {
        "shared": False,
        "fPIC": True,
    }

    @property
    def _min_cppstd(self):
        return 17

    @property
    def _compilers_minimum_version(self):
        return {
            "apple-clang": "10",
            "clang": "7",
            "gcc": "7",
            "msvc": "191",
            "Visual Studio": "15",
        }

    @property
    def _clang_source_folder(self):
        return Path(self.source_folder) / "clang"

    def export_sources(self):
        export_conandata_patches(self)

    def config_options(self):
        if self.settings.os == "Windows":
            del self.options.fPIC

    def configure(self):
        if self.options.shared:
            self.options.rm_safe("fPIC")

    def layout(self):
        cmake_layout(self, src_folder="src")

    def requirements(self):
        self.requires(f"llvm-core/{self.version}", transitive_headers=True)

    def build_requirements(self):
        # needed to build c-index-test but not actually required by any components
        self.test_requires(f"libxml2/[>2.12.4 <3]")
        self.tool_requires("cmake/[>=3.20]")

    def validate(self):
        if self.settings.compiler.cppstd:
            check_min_cppstd(self, self._min_cppstd)
        minimum_version = self._compilers_minimum_version.get(str(self.settings.compiler), False)
        if minimum_version and Version(self.settings.compiler.version) < minimum_version:
            raise ConanInvalidConfiguration(
                f"{self.ref} requires C++{self._min_cppstd}, which your compiler does not support."
            )
        if self.dependencies["llvm-core"].options.shared:
            # CMake only supports this for in-tree builds (ie when building LLVM and Clang together) as
            # we need to build clang-tblgen which requires the LLVMSupport library. See
            # clang/lib/Support/CMakeLists.txt
            raise ConanInvalidConfiguration("Building with the shared LLVM library is not supported")
        elif self.options.shared:
            # See Clang CMakeLists.txt
            raise ConanInvalidConfiguration("Clang tools built against the shared library cannot be linked against static LLVM (llvm-core)")

    def source(self):
        sources = self.conan_data["sources"][self.version]
        get(self, **sources["clang"], destination="clang", strip_root=True)
        get(self, **sources["cmake"], destination="cmake", strip_root=True)

    def generate(self):
        llvm = self.dependencies["llvm-core"]
        tc = CMakeToolchain(self)
        tc.cache_variables.update({
            "CLANG_LINK_CLANG_DYLIB": self.options.shared,
            "LLVM_INCLUDE_TESTS": False,
            # Following not necessary when https://github.com/conan-io/conan-center-index/pull/27156 is merged
            "LLVM_ENABLE_RTTI": llvm.options.rtti,
            "LLVM_ENABLE_PIC": llvm.options.get_safe("fPIC", True),
            "LLVM_LINK_LLVM_DYLIB": llvm.options.shared,
        })

        tc.generate()

        CMakeDeps(self).generate()

    def _patch_sources(self):
        cmake_lists = self._clang_source_folder / "CMakeLists.txt"
        # Some of this customization can be removed when
        # https://github.com/conan-io/conan-center-index/pull/27156 is merged
        replace_in_file(self, cmake_lists,
                        """list(APPEND CMAKE_MODULE_PATH "${LLVM_DIR}")""",
                        textwrap.dedent("""list(APPEND CMAKE_MODULE_PATH "${LLVM_DIR};${LLVM_CMAKE_DIR}")
            if (NOT TARGET ARMTargetParserTableGen)
                add_custom_target(ARMTargetParserTableGen)
            endif()
            if (NOT TARGET AArch64TargetParserTableGen)
                add_custom_target(AArch64TargetParserTableGen)
            endif()
            if (NOT TARGET RISCVTargetParserTableGen)
                add_custom_target(RISCVTargetParserTableGen)
            endif()"""),
                        strict=False)

    @property
    def _graphviz_file(self):
        return PurePosixPath(self.build_folder) / "clang.dot"

    def build(self):
        self._patch_sources()
        cmake = CMake(self)
        graphviz_args = [f"--graphviz={self._graphviz_file}"]

        # components not exported or not of interest
        exclude_patterns = [
            "CONAN_LIB*",
            "llvm-core*"
        ]
        graphviz_options = textwrap.dedent(f"""
                    set(GRAPHVIZ_EXECUTABLES OFF)
                    set(GRAPHVIZ_MODULE_LIBS OFF)
                    set(GRAPHVIZ_OBJECT_LIBS OFF)
                    set(GRAPHVIZ_IGNORE_TARGETS "{';'.join(exclude_patterns)}")
                """)
        save(self, PurePosixPath(self.build_folder) / "CMakeGraphVizOptions.cmake", graphviz_options)
        cmake.configure(build_script_folder="clang", cli_args=graphviz_args)
        cmake.build()

    @property
    def _package_folder_path(self):
        return PurePosixPath(self.package_folder)

    @property
    def _cmake_build_folder_rel_path(self):
        return Path("lib") / "cmake" / "clang"

    @property
    def _build_module_file_rel_path(self):
        return self._cmake_build_folder_rel_path / f"conan-official-{self.name}-variables.cmake"

    @property
    def _components_path(self):
        return Path(self.package_folder) / self._cmake_build_folder_rel_path / "components.json"

    def _create_cmake_build_module(self, module_file):
        package_folder = Path(self.package_folder)
        content = textwrap.dedent(f"""\
            set(CLANG_INSTALL_PREFIX "{str(package_folder)}")
            set(CLANG_CMAKE_DIR "{str(package_folder / self._cmake_build_folder_rel_path)}")
            if (NOT TARGET clang-tablegen-targets)
              add_custom_target(clang-tablegen-targets)
            endif()
            list(APPEND CMAKE_MODULE_PATH "${{LLVM_CMAKE_DIR}}")
            # should have been be included by AddClang but isn't
            include(AddLLVM)
           """)
        save(self, module_file, content)

    @property
    def _cmake_module_path(self):
        return PurePosixPath("lib") / "cmake" / "clang"

    @property
    def _build_info_file(self):
        return self._package_folder_path / self._cmake_module_path / "conan_clang_build_info.json"

    def _write_build_info(self):
        build_info = {"components": components_from_dotfile(load(self, self._graphviz_file.as_posix()))}
        with open(self._build_info_file, "w", encoding="utf-8") as fp:
            json.dump(build_info, fp, indent=2)

        return build_info

    def _read_build_info(self) -> dict:
        with open(self._build_info_file, encoding="utf-8") as fp:
            return json.load(fp)

    def package(self):
        copy(self, "LICENSE.TXT", self._clang_source_folder, os.path.join(self.package_folder, "licenses"))
        cmake = CMake(self)
        cmake.install()
        self._write_build_info()

        package_folder = Path(self.package_folder)
        self._create_cmake_build_module(package_folder / self._build_module_file_rel_path)

        cmake_folder = package_folder / self._cmake_build_folder_rel_path
        rm(self, "ClangConfig*", cmake_folder)
        rm(self, "ClangTargets*", cmake_folder)
        rmdir(self, package_folder / "share")

    def package_info(self):
        def _add_no_rtti_flag(component):
            if is_msvc(self):
                component.cxxflags.append("/GS-")
            else:
                component.cxxflags.append("-fno-rtti")

        def _lib_name_from_component(name):
            replacements = {
                "libclang": "clang"
            }
            return replacements.get(name, name)

        self.cpp_info.set_property("cmake_file_name", "Clang")
        self.cpp_info.set_property("cmake_build_modules",
                                   [self._build_module_file_rel_path,
                                    self._cmake_build_folder_rel_path / "AddClang.cmake"]
                                   )

        self.cpp_info.builddirs.append(self._build_module_file_rel_path)
        llvm = self.dependencies["llvm-core"]
        if not llvm.options.rtti:
            _add_no_rtti_flag(self.cpp_info)

        build_info = self._read_build_info()
        components = build_info["components"]
        for component, data in components.items():
            self.cpp_info.components[component].set_property("cmake_target_name", component)
            self.cpp_info.components[component].libs = [_lib_name_from_component(component)]
            self.cpp_info.components[component].requires = data["requires"]
            if not llvm.options.rtti:
                _add_no_rtti_flag(self.cpp_info.components[component])
