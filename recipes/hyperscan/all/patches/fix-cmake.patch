diff --git a/CMakeLists.txt b/CMakeLists.txt
index 8bc6077..ec77261 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -6,7 +6,7 @@ set (HS_MINOR_VERSION 4)
 set (HS_PATCH_VERSION 0)
 set (HS_VERSION ${HS_MAJOR_VERSION}.${HS_MINOR_VERSION}.${HS_PATCH_VERSION})
 
-set(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)
+list(APPEND CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/cmake")
 include(CheckCCompilerFlag)
 include(CheckCXXCompilerFlag)
 include(CheckCXXSymbolExists)
@@ -17,8 +17,8 @@ INCLUDE (CheckLibraryExists)
 INCLUDE (CheckSymbolExists)
 include (CMakeDependentOption)
 include (GNUInstallDirs)
-include (${CMAKE_MODULE_PATH}/platform.cmake)
-include (${CMAKE_MODULE_PATH}/ragel.cmake)
+include (platform)
+include (ragel)
 
 find_package(PkgConfig QUIET)
 
@@ -69,7 +69,7 @@ include_directories(${PROJECT_SOURCE_DIR}/src)
 include_directories(${PROJECT_BINARY_DIR})
 include_directories(SYSTEM include)
 
-include (${CMAKE_MODULE_PATH}/boost.cmake)
+include (boost)
 
 # -- make this work? set(python_ADDITIONAL_VERSIONS 2.7 2.6)
 find_package(PythonInterp)
@@ -84,7 +84,7 @@ endif()
 # allow for reproducible builds - python for portability
 if (DEFINED ENV{SOURCE_DATE_EPOCH})
       execute_process(
-          COMMAND "${PYTHON}" "${CMAKE_MODULE_PATH}/formatdate.py" "$ENV{SOURCE_DATE_EPOCH}"
+          COMMAND "${PYTHON}" "${PROJECT_SOURCE_DIR}/cmake/formatdate.py" "$ENV{SOURCE_DATE_EPOCH}"
           OUTPUT_VARIABLE BUILD_DATE
           OUTPUT_STRIP_TRAILING_WHITESPACE)
 else ()
@@ -326,7 +326,7 @@ if (CMAKE_SYSTEM_NAME MATCHES "Linux")
         message (STATUS "Building the fat runtime requires the Unix Makefiles generator, or Ninja with CMake v3.0 or higher")
         set (FAT_RUNTIME_REQUISITES FALSE)
     else()
-        include (${CMAKE_MODULE_PATH}/attrib.cmake)
+        include (attrib)
         if (NOT HAS_C_ATTR_IFUNC)
             message(STATUS "Compiler does not support ifunc attribute, cannot build fat runtime")
             set (FAT_RUNTIME_REQUISITES FALSE)
@@ -337,7 +337,7 @@ if (CMAKE_SYSTEM_NAME MATCHES "Linux")
     CMAKE_DEPENDENT_OPTION(FAT_RUNTIME "Build a library that supports multiple microarchitectures" ${RELEASE_BUILD} "FAT_RUNTIME_REQUISITES" OFF)
 endif ()
 
-include (${CMAKE_MODULE_PATH}/arch.cmake)
+include (arch)
 
 # testing a builtin takes a little more work
 CHECK_C_SOURCE_COMPILES("void *aa_test(void *x) { return __builtin_assume_aligned(x, 16);}\nint main(void) { return 0; }" HAVE_CC_BUILTIN_ASSUME_ALIGNED)
@@ -472,7 +472,7 @@ if (NOT WIN32)
 set(PCRE_REQUIRED_MAJOR_VERSION 8)
 set(PCRE_REQUIRED_MINOR_VERSION 41)
 set(PCRE_REQUIRED_VERSION ${PCRE_REQUIRED_MAJOR_VERSION}.${PCRE_REQUIRED_MINOR_VERSION})
-include (${CMAKE_MODULE_PATH}/pcre.cmake)
+include (pcre)
 if (NOT CORRECT_PCRE_VERSION)
     message(STATUS "PCRE ${PCRE_REQUIRED_VERSION} or above not found")
 endif()
@@ -482,33 +482,18 @@ if (CORRECT_PCRE_VERSION AND PCRE_BUILD_SOURCE AND BUILD_STATIC_LIBS)
     set(BUILD_CHIMERA TRUE)
 endif()
 
-add_subdirectory(unit)
-if (EXISTS ${CMAKE_SOURCE_DIR}/tools/CMakeLists.txt)
+if (EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/tools/CMakeLists.txt)
     add_subdirectory(tools)
 endif()
-if (EXISTS ${CMAKE_SOURCE_DIR}/chimera/CMakeLists.txt AND BUILD_CHIMERA)
+if (EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/chimera/CMakeLists.txt AND BUILD_CHIMERA)
     add_subdirectory(chimera)
 endif()
 endif()
 
 # do substitutions
-configure_file(${CMAKE_MODULE_PATH}/config.h.in ${PROJECT_BINARY_DIR}/config.h)
+configure_file(${PROJECT_SOURCE_DIR}/cmake/config.h.in ${PROJECT_BINARY_DIR}/config.h)
 configure_file(src/hs_version.h.in ${PROJECT_BINARY_DIR}/hs_version.h)
 
-if (NOT WIN32)
-    # expand out library names for pkgconfig static link info
-    foreach (LIB ${CMAKE_CXX_IMPLICIT_LINK_LIBRARIES})
-        # this is fragile, but protects us from toolchain specific files
-        if (NOT EXISTS ${LIB})
-            set(PRIVATE_LIBS "${PRIVATE_LIBS} -l${LIB}")
-        endif()
-    endforeach()
-
-    configure_file(libhs.pc.in libhs.pc @ONLY) # only replace @ quoted vars
-    install(FILES ${CMAKE_BINARY_DIR}/libhs.pc
-        DESTINATION "${CMAKE_INSTALL_LIBDIR}/pkgconfig")
-endif()
-
 # only set these after all tests are done
 if (NOT FAT_RUNTIME)
 set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${EXTRA_C_FLAGS} ${HS_C_FLAGS}")
@@ -524,7 +509,7 @@ if (WIN32)
 set(PCRE_REQUIRED_MAJOR_VERSION 8)
 set(PCRE_REQUIRED_MINOR_VERSION 41)
 set(PCRE_REQUIRED_VERSION ${PCRE_REQUIRED_MAJOR_VERSION}.${PCRE_REQUIRED_MINOR_VERSION})
-include (${CMAKE_MODULE_PATH}/pcre.cmake)
+include (pcre)
 if (NOT CORRECT_PCRE_VERSION)
     message(STATUS "PCRE ${PCRE_REQUIRED_VERSION} or above not found")
 endif()
@@ -534,11 +519,10 @@ if (CORRECT_PCRE_VERSION AND PCRE_BUILD_SOURCE AND BUILD_STATIC_LIBS)
     set(BUILD_CHIMERA TRUE)
 endif()
 
-add_subdirectory(unit)
-if (EXISTS ${CMAKE_SOURCE_DIR}/tools/CMakeLists.txt)
+if (EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/tools/CMakeLists.txt)
     add_subdirectory(tools)
 endif()
-if (EXISTS ${CMAKE_SOURCE_DIR}/chimera/CMakeLists.txt AND BUILD_CHIMERA)
+if (EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/chimera/CMakeLists.txt AND BUILD_CHIMERA)
     add_subdirectory(chimera)
 endif()
 endif()
@@ -548,14 +532,14 @@ set(RAGEL_C_FLAGS "-Wno-unused")
 endif()
 
 set_source_files_properties(
-    ${CMAKE_BINARY_DIR}/src/parser/Parser.cpp
+    ${CMAKE_CURRENT_BINARY_DIR}/src/parser/Parser.cpp
     PROPERTIES
         COMPILE_FLAGS "${RAGEL_C_FLAGS}")
 
 ragelmaker(src/parser/Parser.rl)
 
 set_source_files_properties(
-    ${CMAKE_BINARY_DIR}/src/parser/control_verbs.cpp
+    ${CMAKE_CURRENT_BINARY_DIR}/src/parser/control_verbs.cpp
     PROPERTIES
         COMPILE_FLAGS "${RAGEL_C_FLAGS}")
 
@@ -1216,28 +1200,28 @@ else (FAT_RUNTIME)
        list(APPEND RUNTIME_LIBS $<TARGET_OBJECTS:hs_exec_core2>)
        set_target_properties(hs_exec_core2 PROPERTIES
            COMPILE_FLAGS "-march=core2"
-           RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} core2 ${CMAKE_MODULE_PATH}/keep.syms.in"
+           RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} core2 ${PROJECT_SOURCE_DIR}/cmake/keep.syms.in"
            )
 
        add_library(hs_exec_corei7 OBJECT ${hs_exec_SRCS})
        list(APPEND RUNTIME_LIBS $<TARGET_OBJECTS:hs_exec_corei7>)
        set_target_properties(hs_exec_corei7 PROPERTIES
            COMPILE_FLAGS "-march=corei7"
-           RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} corei7 ${CMAKE_MODULE_PATH}/keep.syms.in"
+           RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} corei7 ${PROJECT_SOURCE_DIR}/cmake/keep.syms.in"
            )
 
        add_library(hs_exec_avx2 OBJECT ${hs_exec_SRCS} ${hs_exec_avx2_SRCS})
        list(APPEND RUNTIME_LIBS $<TARGET_OBJECTS:hs_exec_avx2>)
        set_target_properties(hs_exec_avx2 PROPERTIES
            COMPILE_FLAGS "-march=core-avx2"
-           RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} avx2 ${CMAKE_MODULE_PATH}/keep.syms.in"
+           RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} avx2 ${PROJECT_SOURCE_DIR}/cmake/keep.syms.in"
            )
        if (BUILD_AVX512)
            add_library(hs_exec_avx512 OBJECT ${hs_exec_SRCS} ${hs_exec_avx2_SRCS})
            list(APPEND RUNTIME_LIBS $<TARGET_OBJECTS:hs_exec_avx512>)
            set_target_properties(hs_exec_avx512 PROPERTIES
                COMPILE_FLAGS "${SKYLAKE_FLAG}"
-               RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} avx512 ${CMAKE_MODULE_PATH}/keep.syms.in"
+               RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} avx512 ${PROJECT_SOURCE_DIR}/cmake/keep.syms.in"
                )
        endif (BUILD_AVX512)
        if (BUILD_AVX512VBMI)
@@ -1245,7 +1229,7 @@ else (FAT_RUNTIME)
            list(APPEND RUNTIME_LIBS $<TARGET_OBJECTS:hs_exec_avx512vbmi>)
            set_target_properties(hs_exec_avx512vbmi PROPERTIES
                COMPILE_FLAGS "${ICELAKE_FLAG}"
-               RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} avx512vbmi ${CMAKE_MODULE_PATH}/keep.syms.in"
+               RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} avx512vbmi ${PROJECT_SOURCE_DIR}/cmake/keep.syms.in"
                )
        endif (BUILD_AVX512VBMI)
 
@@ -1280,21 +1264,21 @@ else (FAT_RUNTIME)
         set_target_properties(hs_exec_shared_core2 PROPERTIES
             COMPILE_FLAGS "-march=core2"
             POSITION_INDEPENDENT_CODE TRUE
-            RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} core2 ${CMAKE_MODULE_PATH}/keep.syms.in"
+            RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} core2 ${PROJECT_SOURCE_DIR}/cmake/keep.syms.in"
             )
         add_library(hs_exec_shared_corei7 OBJECT ${hs_exec_SRCS})
         list(APPEND RUNTIME_SHLIBS $<TARGET_OBJECTS:hs_exec_shared_corei7>)
         set_target_properties(hs_exec_shared_corei7 PROPERTIES
             COMPILE_FLAGS "-march=corei7"
             POSITION_INDEPENDENT_CODE TRUE
-            RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} corei7 ${CMAKE_MODULE_PATH}/keep.syms.in"
+            RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} corei7 ${PROJECT_SOURCE_DIR}/cmake/keep.syms.in"
             )
         add_library(hs_exec_shared_avx2 OBJECT ${hs_exec_SRCS} ${hs_exec_avx2_SRCS})
         list(APPEND RUNTIME_SHLIBS $<TARGET_OBJECTS:hs_exec_shared_avx2>)
         set_target_properties(hs_exec_shared_avx2 PROPERTIES
             COMPILE_FLAGS "-march=core-avx2"
             POSITION_INDEPENDENT_CODE TRUE
-            RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} avx2 ${CMAKE_MODULE_PATH}/keep.syms.in"
+            RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} avx2 ${PROJECT_SOURCE_DIR}/cmake/keep.syms.in"
             )
 
         if (BUILD_AVX512)
@@ -1303,7 +1287,7 @@ else (FAT_RUNTIME)
             set_target_properties(hs_exec_shared_avx512 PROPERTIES
                 COMPILE_FLAGS "${SKYLAKE_FLAG}"
                 POSITION_INDEPENDENT_CODE TRUE
-                RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} avx512 ${CMAKE_MODULE_PATH}/keep.syms.in"
+                RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} avx512 ${PROJECT_SOURCE_DIR}/cmake/keep.syms.in"
                 )
         endif (BUILD_AVX512)
         if (BUILD_AVX512VBMI)
@@ -1312,7 +1296,7 @@ else (FAT_RUNTIME)
             set_target_properties(hs_exec_shared_avx512vbmi PROPERTIES
                 COMPILE_FLAGS "${ICELAKE_FLAG}"
                 POSITION_INDEPENDENT_CODE TRUE
-                RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} avx512vbmi ${CMAKE_MODULE_PATH}/keep.syms.in"
+                RULE_LAUNCH_COMPILE "${BUILD_WRAPPER} avx512vbmi ${PROJECT_SOURCE_DIR}/cmake/keep.syms.in"
                 )
         endif (BUILD_AVX512VBMI)
         add_library(hs_exec_common_shared OBJECT
diff --git a/chimera/CMakeLists.txt b/chimera/CMakeLists.txt
index 1cd66a3..d4f4180 100644
--- a/chimera/CMakeLists.txt
+++ b/chimera/CMakeLists.txt
@@ -18,6 +18,7 @@ SET(chimera_SRCS
     ${chimera_HEADERS}
     ch_alloc.c
     ch_alloc.h
+    ch_pcre_bridge.c
     ch_compile.cpp
     ch_database.c
     ch_database.h
@@ -27,23 +28,10 @@ SET(chimera_SRCS
     ch_scratch.c
 )
 
+set_source_files_properties(ch_pcre_bridge.c PROPERTIES COMPILE_FLAGS "/Gd")
+
 add_library(chimera STATIC ${chimera_SRCS})
-add_dependencies(chimera hs pcre)
-target_link_libraries(chimera hs pcre)
+add_dependencies(chimera hs PCRE::libpcre)
+target_link_libraries(chimera hs PCRE::libpcre)
 
 install(TARGETS chimera DESTINATION ${CMAKE_INSTALL_LIBDIR})
-
-if (NOT WIN32)
-    # expand out library names for pkgconfig static link info
-    foreach (LIB ${CMAKE_CXX_IMPLICIT_LINK_LIBRARIES})
-        # this is fragile, but protects us from toolchain specific files
-        if (NOT EXISTS ${LIB})
-            set(PRIVATE_LIBS "${PRIVATE_LIBS} -l${LIB}")
-        endif()
-    endforeach()
-    set(PRIVATE_LIBS "${PRIVATE_LIBS} -L${LIBDIR} -lpcre")
-
-    configure_file(libch.pc.in libch.pc @ONLY) # only replace @ quoted vars
-    install(FILES ${CMAKE_BINARY_DIR}/chimera/libch.pc
-        DESTINATION "${CMAKE_INSTALL_LIBDIR}/pkgconfig")
-endif()
diff --git a/chimera/ch_compile.cpp b/chimera/ch_compile.cpp
index 46536f3..43da11b 100644
--- a/chimera/ch_compile.cpp
+++ b/chimera/ch_compile.cpp
@@ -337,7 +337,7 @@ void PatternData::buildPcre(const char *pattern, u32 flags) {
     const char *errptr = nullptr;
     int erroffset = 0;
 
-    compiled = pcre_compile(pattern, options, &errptr, &erroffset, nullptr);
+    compiled = bridge_pcre_compile(pattern, options, &errptr, &erroffset, nullptr);
     if (!compiled) {
         DEBUG_PRINTF("PCRE failed to compile: %s\n", pattern);
         string err("PCRE compilation failed: ");
@@ -346,7 +346,7 @@ void PatternData::buildPcre(const char *pattern, u32 flags) {
         throw CompileError(expr_index, err);
     }
 
-    extra = pcre_study(compiled, PCRE_STUDY_JIT_COMPILE, &errptr);
+    extra = bridge_pcre_study(compiled, PCRE_STUDY_JIT_COMPILE, &errptr);
     // Note that it's OK for pcre_study to return NULL if there's nothing
     // to be found, but a non-NULL error is always bad.
     if (errptr) {
@@ -357,19 +357,19 @@ void PatternData::buildPcre(const char *pattern, u32 flags) {
         throw CompileError(expr_index, err);
     }
 
-    if (pcre_fullinfo(compiled, extra, PCRE_INFO_SIZE, &compiled_size)) {
+    if (bridge_pcre_fullinfo(compiled, extra, PCRE_INFO_SIZE, &compiled_size)) {
         throw CompileError(PCRE_ERROR_MSG);
     }
 
     if (!extra) {
         study_size = 0;
     } else {
-        if (pcre_fullinfo(compiled, extra, PCRE_INFO_STUDYSIZE, &study_size)) {
+        if (bridge_pcre_fullinfo(compiled, extra, PCRE_INFO_STUDYSIZE, &study_size)) {
             throw CompileError(PCRE_ERROR_MSG);
         }
     }
 
-    if (pcre_fullinfo(compiled, extra, PCRE_INFO_CAPTURECOUNT, &capture_cnt)) {
+    if (bridge_pcre_fullinfo(compiled, extra, PCRE_INFO_CAPTURECOUNT, &capture_cnt)) {
         throw CompileError(PCRE_ERROR_MSG);
     }
 
@@ -377,7 +377,7 @@ void PatternData::buildPcre(const char *pattern, u32 flags) {
      * even in the pure unguarded pcre mode where there is no hs available. We
      * can not use the compile flags due to (*UTF8) verb */
     unsigned long int opts = 0; // PCRE_INFO_OPTIONS demands an unsigned long
-    if (pcre_fullinfo(compiled, extra, PCRE_INFO_OPTIONS, &opts)) {
+    if (bridge_pcre_fullinfo(compiled, extra, PCRE_INFO_OPTIONS, &opts)) {
         throw CompileError(PCRE_ERROR_MSG);
     }
     utf8 = opts & PCRE_UTF8;
diff --git a/chimera/ch_database.h b/chimera/ch_database.h
index 28bde86..28459e8 100644
--- a/chimera/ch_database.h
+++ b/chimera/ch_database.h
@@ -38,9 +38,7 @@ extern "C"
 {
 #endif
 
-#define PCRE_STATIC
-#include <pcre.h>
-
+#include "ch_pcre_bridge.h"
 #include "ch_compile.h" // for CH_MODE_ flags
 #include "ue2common.h"
 #include "hs_version.h"
diff --git a/chimera/ch_pcre_bridge.c b/chimera/ch_pcre_bridge.c
new file mode 100644
index 0000000..737676b
--- /dev/null
+++ b/chimera/ch_pcre_bridge.c
@@ -0,0 +1,31 @@
+// HOTFIX TO PREVENT CALLING CONVENTION MISMATCH ON MSVC
+
+#include "ch_pcre_bridge.h"
+
+pcre * bridge_pcre_compile(const char * pattern, int options, const char ** errptr, int * erroffset, const unsigned char * tableptr)
+{
+    return pcre_compile(pattern, options, errptr, erroffset, tableptr);
+}
+
+int bridge_pcre_fullinfo(const pcre *code, const pcre_extra *extra, int what, void *where)
+{
+    return pcre_fullinfo(code, extra, what, where);
+}
+
+pcre_extra * bridge_pcre_study(const pcre *code, int options, const char **errptr)
+{
+    return pcre_study(code, options, errptr);
+}
+
+int bridge_pcre_exec(const pcre *code, const pcre_extra *extra, const char *subject, int length, int startoffset, int options, int *ovector, int ovecsize)
+{
+    return pcre_exec(code, extra, subject, length, startoffset, options, ovector, ovecsize);
+}
+
+// Internal PCRE func.
+extern int _pcre_valid_utf(const unsigned char *, int, int *);
+
+int bridge_pcre_valid_utf(const unsigned char *string, int length, int *erroroffset)
+{
+    return _pcre_valid_utf(string, length, erroroffset);
+}
diff --git a/chimera/ch_pcre_bridge.h b/chimera/ch_pcre_bridge.h
new file mode 100644
index 0000000..bc78c7c
--- /dev/null
+++ b/chimera/ch_pcre_bridge.h
@@ -0,0 +1,32 @@
+#pragma once
+
+#ifndef CH_PCRE_BRIDGE_H_
+#define CH_PCRE_BRIDGE_H_
+
+/* #define PCRE_STATIC */
+#include <pcre.h>
+
+#ifdef __cplusplus__
+extern "C"
+{
+#endif
+
+#ifdef _MSC_VER
+#   define CH_CALL_CDECL __cdecl
+#else
+#   define CH_CALL_CDECL
+#endif
+
+pcre * CH_CALL_CDECL bridge_pcre_compile(const char * pattern, int options, const char ** errptr, int * erroffset, const unsigned char * tableptr);
+int CH_CALL_CDECL bridge_pcre_fullinfo(const pcre *code, const pcre_extra *extra, int what, void *where);
+pcre_extra * CH_CALL_CDECL bridge_pcre_study(const pcre *code, int options, const char **errptr);
+int CH_CALL_CDECL bridge_pcre_exec(const pcre *code, const pcre_extra *extra, const char *subject, int length, int startoffset, int options, int *ovector, int ovecsize);
+int CH_CALL_CDECL bridge_pcre_valid_utf(const unsigned char *string, int length, int *erroroffset);
+
+#undef CH_CALL_CDECL
+
+#ifdef __cplusplus__
+}
+#endif
+
+#endif
diff --git a/chimera/ch_runtime.c b/chimera/ch_runtime.c
index fdb5b99..e95961a 100644
--- a/chimera/ch_runtime.c
+++ b/chimera/ch_runtime.c
@@ -119,9 +119,6 @@ struct HybridContext {
     void *context;
 };
 
-// Internal PCRE func.
-extern int _pcre_valid_utf(const unsigned char *, int, int *);
-
 /** UTF-8 validity check. Returns >0 if the given region of the data is valid
  * UTF-8, 0 otherwise. */
 static
@@ -139,7 +136,7 @@ char isValidUTF8(struct HybridContext *hyctx, u32 end) {
     DEBUG_PRINTF("validating %d bytes\n", validate_len);
 
     int erroroffset = 0;
-    if (_pcre_valid_utf(data, validate_len, &erroroffset)) {
+    if (bridge_pcre_valid_utf(data, validate_len, &erroroffset)) {
         DEBUG_PRINTF("UTF8 invalid at offset %d\n", erroroffset);
         return 0;
     }
@@ -240,7 +237,7 @@ ch_error_t scanPcre(struct HybridContext *hyctx, UNUSED unsigned int length,
         }
     }
 
-    int rv = pcre_exec(p, extra, data, full_length, startoffset, options,
+    int rv = bridge_pcre_exec(p, extra, data, full_length, startoffset, options,
                        ovector, ovectorSize);
 
     DEBUG_PRINTF("pcre return code is %d\n", rv);
diff --git a/cmake/pcre.cmake b/cmake/pcre.cmake
index e0acda5..c68601f 100644
--- a/cmake/pcre.cmake
+++ b/cmake/pcre.cmake
@@ -1,4 +1,5 @@
 # first look in pcre-$version or pcre subdirs
+
 if (PCRE_SOURCE)
     # either provided on cmdline or we've seen it already
     set (PCRE_BUILD_SOURCE TRUE)
@@ -50,14 +51,10 @@ if (PCRE_BUILD_SOURCE)
     set(PCRE_INCLUDE_DIRS ${PCRE_SOURCE} ${PROJECT_BINARY_DIR}/pcre)
     set(PCRE_LDFLAGS -L"${LIBDIR}" -lpcre)
 else ()
-    # pkgconf should save us
-    find_package(PkgConfig)
-    pkg_check_modules(PCRE libpcre>=${PCRE_REQUIRED_VERSION})
-    if (PCRE_FOUND)
+    # conan should save us
+    find_package(PCRE)
+    if(PCRE_FOUND AND (PCRE_VERSION VERSION_GREATER_EQUAL PCRE_REQUIRED_VERSION))
         set(CORRECT_PCRE_VERSION TRUE)
-        message(STATUS "PCRE version ${PCRE_REQUIRED_VERSION} or above")
-    else ()
-        message(STATUS "PCRE version ${PCRE_REQUIRED_VERSION} or above not found")
-        return ()
-    endif ()
+        set(PCRE_LDFLAGS "PCRE::libpcre")
+    endif()
 endif (PCRE_BUILD_SOURCE)
diff --git a/tools/CMakeLists.txt b/tools/CMakeLists.txt
index 6ca3fd8..378afd0 100644
--- a/tools/CMakeLists.txt
+++ b/tools/CMakeLists.txt
@@ -1,3 +1,7 @@
+
+# Tools are not installed
+return ()
+
 find_package(Threads)
 
 # remove some warnings
diff --git a/tools/hsbench/CMakeLists.txt b/tools/hsbench/CMakeLists.txt
index bbceda4..18545d0 100644
--- a/tools/hsbench/CMakeLists.txt
+++ b/tools/hsbench/CMakeLists.txt
@@ -1,4 +1,4 @@
-include (${CMAKE_MODULE_PATH}/sqlite3.cmake)
+include (sqlite3)
 if (NOT SQLITE3_FOUND)
     message(STATUS "sqlite3 not found, not building hsbench")
     return()
diff --git a/tools/hscollider/CMakeLists.txt b/tools/hscollider/CMakeLists.txt
index a4d71b2..f733479 100644
--- a/tools/hscollider/CMakeLists.txt
+++ b/tools/hscollider/CMakeLists.txt
@@ -5,7 +5,7 @@ endif()
 
 include_directories(${PCRE_INCLUDE_DIRS})
 
-include(${CMAKE_MODULE_PATH}/backtrace.cmake)
+include(backtrace)
 
 # we need static libs - too much deep magic for shared libs
 if (NOT BUILD_STATIC_LIBS)
diff --git a/unit/CMakeLists.txt b/unit/CMakeLists.txt
index b0706fa..0f07651 100644
--- a/unit/CMakeLists.txt
+++ b/unit/CMakeLists.txt
@@ -150,7 +150,7 @@ if (BUILD_CHIMERA)
         chimera/scan.cpp
         )
     add_executable(unit-chimera ${unit_chimera_SOURCES})
-    target_link_libraries(unit-chimera chimera hs pcre)
+    target_link_libraries(unit-chimera chimera hs PCRE::libpcre)
     #
     # build target to run unit tests
     #
