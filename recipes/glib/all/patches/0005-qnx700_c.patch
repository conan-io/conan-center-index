--- /dev/null	    2023-07-28 07:48:39.050000000 +0200
+++ gio/qnx700.c	2023-07-28 07:55:24.432860700 +0200
@@ -0,0 +1,572 @@
+#include "qnx700.h"
+
+int openat_permissive (int fd, char const *file, int flags, mode_t mode, int *cwd_errno)
+{
+  struct saved_cwd saved_cwd;
+  int saved_errno;
+  int err;
+  gboolean save_ok;
+
+  if (fd == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file))
+    return open (file, flags, mode);
+
+  {
+    char buf[OPENAT_BUFFER_SIZE];
+    char *proc_file = openat_proc_name (buf, fd, file);
+    if (proc_file)
+      {
+        int open_result = open (proc_file, flags, mode);
+        int open_errno = errno;
+        if (proc_file != buf)
+          free (proc_file);
+        /* If the syscall succeeds, or if it fails with an unexpected
+           errno value, then return right away.  Otherwise, fall through
+           and resort to using save_cwd/restore_cwd.  */
+        if (0 <= open_result || ! EXPECTED_ERRNO (open_errno))
+          {
+            errno = open_errno;
+            return open_result;
+          }
+      }
+  }
+
+  save_ok = (save_cwd (&saved_cwd) == 0);
+  if (! save_ok)
+    {
+      if (! cwd_errno)
+        openat_save_fail (errno);
+      *cwd_errno = errno;
+    }
+  if (0 <= fd && fd == saved_cwd.desc)
+    {
+      /* If saving the working directory collides with the user's
+         requested fd, then the user's fd must have been closed to
+         begin with.  */
+      free_cwd (&saved_cwd);
+      errno = EBADF;
+      return -1;
+    }
+
+  err = fchdir (fd);
+  saved_errno = errno;
+
+  if (! err)
+    {
+      err = open (file, flags, mode);
+      saved_errno = errno;
+      if (save_ok && restore_cwd (&saved_cwd) != 0)
+        {
+          if (! cwd_errno)
+            {
+              /* Don't write a message to just-created fd 2.  */
+              saved_errno = errno;
+              if (err == STDERR_FILENO)
+                close (err);
+              openat_restore_fail (saved_errno);
+            }
+          *cwd_errno = errno;
+        }
+    }
+
+  free_cwd (&saved_cwd);
+  errno = saved_errno;
+  return err;
+}
+
+int openat (int fd, char const *file, int flags, ...)
+{
+  mode_t mode = 0;
+
+  if (flags & O_CREAT)
+    {
+      va_list arg;
+      va_start (arg, flags);
+
+      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4
+         creates crashing code when 'mode_t' is smaller than 'int'.  */
+      mode = va_arg (arg, mode_t);
+
+      va_end (arg);
+    }
+
+  return openat_permissive (fd, file, flags, mode, NULL);
+}
+
+void *memrchr (void const *s, int c_in, size_t n)
+{
+  typedef unsigned long int longword;
+
+  const unsigned char *char_ptr;
+  const longword *longword_ptr;
+  longword repeated_one;
+  longword repeated_c;
+  unsigned char c;
+
+  c = (unsigned char) c_in;
+
+  for (char_ptr = (const unsigned char *) s + n;
+       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;
+       --n)
+    if (*--char_ptr == c)
+      return (void *) char_ptr;
+
+  longword_ptr = (const longword *) char_ptr;
+
+  repeated_one = 0x01010101;
+  repeated_c = c | (c << 8);
+  repeated_c |= repeated_c << 16;
+  if (0xffffffffU < (longword) -1)
+    {
+      repeated_one |= repeated_one << 31 << 1;
+      repeated_c |= repeated_c << 31 << 1;
+      if (8 < sizeof (longword))
+        {
+          size_t i;
+
+          for (i = 64; i < sizeof (longword) * 8; i *= 2)
+            {
+              repeated_one |= repeated_one << i;
+              repeated_c |= repeated_c << i;
+            }
+        }
+    }
+
+  while (n >= sizeof (longword))
+    {
+      longword longword1 = *--longword_ptr ^ repeated_c;
+
+      if ((((longword1 - repeated_one) & ~longword1)
+           & (repeated_one << 7)) != 0)
+        {
+          longword_ptr++;
+          break;
+        }
+      n -= sizeof (longword);
+    }
+
+  char_ptr = (const unsigned char *) longword_ptr;
+  while (n-- > 0)
+    {
+      if (*--char_ptr == c)
+        return (void *) char_ptr;
+    }
+
+  return NULL;
+}
+
+static int cdb_fchdir (struct cd_buf const *cdb)
+{
+  return fchdir (cdb->fd);
+}
+
+static char *find_non_slash (char const *s)
+{
+  size_t n_slash = strspn (s, "/");
+  return (char *) s + n_slash;
+}
+
+static void cdb_free (struct cd_buf const *cdb)
+{
+  if (0 <= cdb->fd)
+    {
+      gboolean close_fail = close (cdb->fd);
+      assure (! close_fail);
+    }
+}
+
+static int cdb_advance_fd (struct cd_buf *cdb, char const *dir)
+{
+  int new_fd = openat (cdb->fd, dir,
+                       O_NOCTTY | O_NONBLOCK);
+  if (new_fd < 0)
+    return -1;
+
+  cdb_free (cdb);
+  cdb->fd = new_fd;
+
+  return 0;
+}
+
+static void cdb_init (struct cd_buf *cdb)
+{
+  cdb->fd = AT_FDCWD;
+}
+
+int chdir_long (char *dir)
+{
+  int e = chdir (dir);
+  if (e == 0 || errno != ENAMETOOLONG)
+    return e;
+
+  {
+    size_t len = strlen (dir);
+    char *dir_end = dir + len;
+    struct cd_buf cdb;
+    size_t n_leading_slash;
+
+    cdb_init (&cdb);
+
+    /* If DIR is the empty string, then the chdir above
+       must have failed and set errno to ENOENT.  */
+    assure (0 < len);
+    assure (PATH_MAX <= len);
+
+    /* Count leading slashes.  */
+    n_leading_slash = strspn (dir, "/");
+
+    /* Handle any leading slashes as well as any name that matches
+       the regular expression, m!^//hostname[/]*! .  Handling this
+       prefix separately usually results in a single additional
+       cdb_advance_fd call, but it's worthwhile, since it makes the
+       code in the following loop cleaner.  */
+    if (n_leading_slash == 2)
+      {
+        int err;
+        /* Find next slash.
+           We already know that dir[2] is neither a slash nor '\0'.  */
+        char *slash = memchr (dir + 3, '/', dir_end - (dir + 3));
+        if (slash == NULL)
+          {
+            errno = ENAMETOOLONG;
+            return -1;
+          }
+        *slash = '\0';
+        err = cdb_advance_fd (&cdb, dir);
+        *slash = '/';
+        if (err != 0)
+          goto Fail;
+        dir = find_non_slash (slash + 1);
+      }
+    else if (n_leading_slash)
+      {
+        if (cdb_advance_fd (&cdb, "/") != 0)
+          goto Fail;
+        dir += n_leading_slash;
+      }
+
+    assure (*dir != '/');
+    assure (dir <= dir_end);
+
+    while (PATH_MAX <= dir_end - dir)
+      {
+        int err;
+        /* Find a slash that is PATH_MAX or fewer bytes away from dir.
+           I.e. see if there is a slash that will give us a name of
+           length PATH_MAX-1 or less.  */
+        char *slash = memrchr (dir, '/', PATH_MAX);
+        if (slash == NULL)
+          {
+            errno = ENAMETOOLONG;
+            return -1;
+          }
+
+        *slash = '\0';
+        assure (slash - dir < PATH_MAX);
+        err = cdb_advance_fd (&cdb, dir);
+        *slash = '/';
+        if (err != 0)
+          goto Fail;
+
+        dir = find_non_slash (slash + 1);
+      }
+
+    if (dir < dir_end)
+      {
+        if (cdb_advance_fd (&cdb, dir) != 0)
+          goto Fail;
+      }
+
+    if (cdb_fchdir (&cdb) != 0)
+      goto Fail;
+
+    cdb_free (&cdb);
+    return 0;
+
+   Fail:
+    {
+      int saved_errno = errno;
+      cdb_free (&cdb);
+      errno = saved_errno;
+      return -1;
+    }
+  }
+}
+
+int dup_safer_flag (int fd, int flag)
+{
+  return fcntl (fd, (flag & O_CLOEXEC) ? F_DUPFD_CLOEXEC : F_DUPFD,
+                STDERR_FILENO + 1);
+}
+
+int fd_safer_flag (int fd, int flag)
+{
+  if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)
+    {
+      int f = dup_safer_flag (fd, flag);
+      int e = errno;
+      close (fd);
+      errno = e;
+      fd = f;
+    }
+
+  return fd;
+}
+
+_Noreturn void openat_restore_fail (int errnum)
+{
+  abort ();
+}
+
+char *openat_proc_name (char buf[OPENAT_BUFFER_SIZE], int fd, char const *file)
+{
+  char *result = buf;
+  int dirlen;
+
+  /* Make sure the caller gets ENOENT when appropriate.  */
+  if (!*file)
+    {
+      buf[0] = '\0';
+      return buf;
+    }
+
+#ifndef __KLIBC__
+# define PROC_SELF_FD_FORMAT "/proc/self/fd/%d/"
+  {
+    enum {
+      PROC_SELF_FD_DIR_SIZE_BOUND
+        = (sizeof PROC_SELF_FD_FORMAT - (sizeof "%d" - 1)
+           + INT_STRLEN_BOUND (int))
+    };
+
+    static int proc_status = 0;
+    if (! proc_status)
+      {
+        /* Set PROC_STATUS to a positive value if /proc/self/fd is
+           reliable, and a negative value otherwise.  Solaris 10
+           /proc/self/fd mishandles "..", and any file name might expand
+           to ".." after symbolic link expansion, so avoid /proc/self/fd
+           if it mishandles "..".  Solaris 10 has openat, but this
+           problem is exhibited on code that built on Solaris 8 and
+           running on Solaris 10.  */
+
+        int proc_self_fd = open ("/proc/self/fd",
+                                 O_NOCTTY | O_NONBLOCK);
+        if (proc_self_fd < 0)
+          proc_status = -1;
+        else
+          {
+            /* Detect whether /proc/self/fd/%i/../fd exists, where %i is the
+               number of a file descriptor open on /proc/self/fd.  On Linux,
+               that name resolves to /proc/self/fd, which was opened above.
+               However, on Solaris, it may resolve to /proc/self/fd/fd, which
+               cannot exist, since all names in /proc/self/fd are numeric.  */
+            char dotdot_buf[PROC_SELF_FD_DIR_SIZE_BOUND + sizeof "../fd" - 1];
+            sprintf (dotdot_buf, PROC_SELF_FD_FORMAT "../fd", proc_self_fd);
+            proc_status = access (dotdot_buf, F_OK) ? -1 : 1;
+            close (proc_self_fd);
+          }
+      }
+
+    if (proc_status < 0)
+      return NULL;
+    else
+      {
+        size_t bufsize = PROC_SELF_FD_DIR_SIZE_BOUND + strlen (file);
+        if (OPENAT_BUFFER_SIZE < bufsize)
+          {
+            result = malloc (bufsize);
+            if (! result)
+              return NULL;
+          }
+
+        dirlen = sprintf (result, PROC_SELF_FD_FORMAT, fd);
+      }
+  }
+#else
+  /* OS/2 kLIBC provides a function to retrieve a path from a fd.  */
+  {
+    char dir[_MAX_PATH];
+    size_t bufsize;
+
+    if (__libc_Back_ioFHToPath (fd, dir, sizeof dir))
+      return NULL;
+
+    dirlen = strlen (dir);
+    bufsize = dirlen + 1 + strlen (file) + 1; /* 1 for '/', 1 for null */
+    if (OPENAT_BUFFER_SIZE < bufsize)
+      {
+        result = malloc (bufsize);
+        if (! result)
+          return NULL;
+      }
+
+    strcpy (result, dir);
+    result[dirlen++] = '/';
+  }
+#endif
+
+  strcpy (result + dirlen, file);
+  return result;
+}
+
+DIR *fdopendir (int fd)
+{
+  DIR *dir = fdopendir_with_dup (fd, -1, NULL);
+
+  if (! REPLACE_FCHDIR && ! dir)
+    {
+      int saved_errno = errno;
+      if (EXPECTED_ERRNO (saved_errno))
+        {
+          struct saved_cwd cwd;
+          if (save_cwd (&cwd) != 0)
+            openat_save_fail (errno);
+          dir = fdopendir_with_dup (fd, -1, &cwd);
+          saved_errno = errno;
+          free_cwd (&cwd);
+          errno = saved_errno;
+        }
+    }
+
+  return dir;
+}
+
+/* Like fdopendir, except that if OLDER_DUPFD is not -1, it is known
+   to be a dup of FD which is less than FD - 1 and which will be
+   closed by the caller and not otherwise used by the caller.  This
+   function makes sure that FD is closed and all file descriptors less
+   than FD are open, and then calls fd_clone_opendir on a dup of FD.
+   That way, barring race conditions, fd_clone_opendir returns a
+   stream whose file descriptor is FD.
+
+   If REPLACE_FCHDIR or CWD is null, use opendir ("/proc/self/fd/...",
+   falling back on fchdir metadata.  Otherwise, CWD is a saved version
+   of the working directory; use fchdir/opendir(".")/restore_cwd(CWD).  */
+DIR *fdopendir_with_dup (int fd, int older_dupfd, struct saved_cwd const *cwd)
+{
+  int dupfd = dup (fd);
+  if (dupfd < 0 && errno == EMFILE)
+    dupfd = older_dupfd;
+  if (dupfd < 0)
+    return NULL;
+  else
+    {
+      DIR *dir;
+      int saved_errno;
+      if (dupfd < fd - 1 && dupfd != older_dupfd)
+        {
+          dir = fdopendir_with_dup (fd, dupfd, cwd);
+          saved_errno = errno;
+        }
+      else
+        {
+          close (fd);
+          dir = fd_clone_opendir (dupfd, cwd);
+          saved_errno = errno;
+          if (! dir)
+            {
+              int fd1 = dup (dupfd);
+              if (fd1 != fd)
+                openat_save_fail (fd1 < 0 ? errno : EBADF);
+            }
+        }
+
+      if (dupfd != older_dupfd)
+        close (dupfd);
+      errno = saved_errno;
+      return dir;
+    }
+}
+
+/* Like fdopendir, except the result controls a clone of FD.  It is
+   the caller's responsibility both to close FD and (if the result is
+   not null) to closedir the result.  */
+static DIR *fd_clone_opendir (int fd, struct saved_cwd const *cwd)
+{
+  if (REPLACE_FCHDIR || ! cwd)
+    {
+      DIR *dir = NULL;
+      int saved_errno = EOPNOTSUPP;
+      char buf[OPENAT_BUFFER_SIZE];
+      char *proc_file = openat_proc_name (buf, fd, ".");
+      if (proc_file)
+        {
+          dir = opendir (proc_file);
+          saved_errno = errno;
+          if (proc_file != buf)
+            free (proc_file);
+        }
+# if REPLACE_FCHDIR
+      if (! dir && EXPECTED_ERRNO (saved_errno))
+        {
+          char const *name = _gl_directory_name (fd);
+          DIR *dp = name ? opendir (name) : NULL;
+
+          /* The caller has done an elaborate dance to arrange for opendir to
+             consume just the right file descriptor.  If dirfd returns -1,
+             though, we're on a system like mingw where opendir does not
+             consume a file descriptor.  Consume it via 'dup' instead.  */
+          if (dp && dirfd (dp) < 0)
+            dup (fd);
+
+          return dp;
+        }
+# endif
+      errno = saved_errno;
+      return dir;
+    }
+  else
+    {
+      if (fchdir (fd) != 0)
+        return NULL;
+      else
+        {
+          DIR *dir = opendir (".");
+          int saved_errno = errno;
+          if (restore_cwd (cwd) != 0)
+            openat_restore_fail (errno);
+          errno = saved_errno;
+          return dir;
+        }
+    }
+}
+
+int save_cwd (struct saved_cwd *cwd)
+{
+  cwd->name = NULL;
+
+  cwd->desc = open (".", O_CLOEXEC);
+  if (!GNULIB_FCNTL_SAFER)
+    cwd->desc = fd_safer_flag (cwd->desc, O_CLOEXEC);
+  if (cwd->desc < 0)
+    {
+      cwd->name = getcwd (NULL, 0);
+      return cwd->name ? 0 : -1;
+    }
+
+  return 0;
+}
+
+/* Change to recorded location, CWD, in directory hierarchy.
+   Upon failure, return -1 (errno is set by chdir or fchdir).
+   Upon success, return zero.  */
+
+int restore_cwd (const struct saved_cwd *cwd)
+{
+  if (0 <= cwd->desc)
+    return fchdir (cwd->desc);
+  else
+    return chdir_long (cwd->name);
+}
+
+void free_cwd (struct saved_cwd *cwd)
+{
+  if (cwd->desc >= 0)
+    close (cwd->desc);
+  free (cwd->name);
+}
+
+_Noreturn void openat_save_fail (int errnum)
+{
+  abort ();
+}
