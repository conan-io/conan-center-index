From 67c4a01278903fcc8012069d78b9396079e5b0f6 Mon Sep 17 00:00:00 2001
From: Tomas Krupa <tomas.krupa@innovatrics.com>
Date: Wed, 26 Feb 2025 08:45:13 +0100
Subject: [PATCH] add NFIR::resample  overload

---
 src/include/nfir_lib.h |   7 ++
 src/lib/nfir_lib.cpp   | 198 +++++++++++++++++++++++++++++++++++++++++
 2 files changed, 205 insertions(+)

diff --git a/src/include/nfir_lib.h b/src/include/nfir_lib.h
index 9c2d6f5..931a2f4 100644
--- a/src/include/nfir_lib.h
+++ b/src/include/nfir_lib.h
@@ -88,6 +88,13 @@ resample( uint8_t *, uint8_t **,
                std::vector<std::string> &,
                std::vector<std::string> & );
 
+std::vector<uint8_t>
+resample(const std::vector<uint8_t>& src,
+               int, int, const std::string &,
+               const std::string &, const std::string &,
+               const std::string &, const std::string &,
+               std::vector<std::string> &,
+               std::vector<std::string> & );
 /**
  * @brief Additional API to get the filtered image prior to downsample.
  *
diff --git a/src/lib/nfir_lib.cpp b/src/lib/nfir_lib.cpp
index 056d752..9c3dd74 100644
--- a/src/lib/nfir_lib.cpp
+++ b/src/lib/nfir_lib.cpp
@@ -476,6 +476,204 @@ void get_filteredImage( uint8_t** filteredImage,
   *filteredImage = filteredImageTmp;
 }
 
+/**
+ * @param srcImage IN pointer to source image
+ * @param srcSampleRate value must reflect srUnits
+ * @param tgtSampleRate value must reflect srUnits
+ * @param srUnits sample rate [ inch | meter | other ]
+ * @param interpolationMethod [ bilinear | bicubic ]
+ * @param filterType [ ideal | Gaussian ]
+ * @param srcComp compression format of source image
+ * @param tgtComp compression format of target image
+ * @param log resample-process metadata for reporting to caller
+ * @return generated, target image
+
+* @throw NFIR::Miscue for invalid sample rate(s), interpolation method,
+*              downsample filter type, or cannot resize image
+*/
+std::vector<uint8_t>
+resample(const std::vector<uint8_t> &srcImage,
+        int srcSampleRate, int tgtSampleRate, const std::string &srUnits,
+        const std::string &interpolationMethod, const std::string &filterType,
+        const std::string &srcComp, const std::string &tgtComp,
+        std::vector<std::string> &vecPngTextChunk,
+        std::vector<std::string> &log)
+{
+  cv::Mat srcImageMtx;
+  cv::Mat tmpImageMtx = cv::imdecode(cv::Mat(srcImage), cv::IMREAD_ANYCOLOR);
+  log.push_back("SRC img std::vector size: " + std::to_string(srcImage.size()));
+  log.push_back("SRC img cv::matrix size: " + std::to_string(tmpImageMtx.total()));
+  log.push_back("SRC img WxH: " + std::to_string(tmpImageMtx.cols) + "x" + std::to_string(tmpImageMtx.rows));
+  log.push_back("SRC img bit depth: " + getImageDepthStr(tmpImageMtx.depth()));
+  log.push_back("SRC img num channels: " + std::to_string(tmpImageMtx.channels()));
+
+  cv::Mat tgtImageMatrix{};
+  tgtImageMatrix.release();
+
+  if (tmpImageMtx.channels() > 1)
+  {
+    cv::cvtColor(tmpImageMtx, srcImageMtx, cv::COLOR_BGR2GRAY);
+    log.push_back("SRC IMG converted to single-channel: TRUE");
+  }
+  else if (tmpImageMtx.channels() == 1)
+  {
+    srcImageMtx = tmpImageMtx.clone();
+    log.push_back("SRC IMG converted to single-channel: FALSE");
+  }
+  else
+  {
+    throw NFIR::Miscue("NFIR lib: SRC IMG num channels not supported");
+  }
+  tmpImageMtx.release();
+
+  // int errCode{0};
+  try
+  {
+    validateUserSpecifiedSampleRates(srcSampleRate, tgtSampleRate);
+  }
+  catch (const NFIR::Miscue &e)
+  {
+    throw e;
+  }
+
+  cv::Mat paddedImg;
+  Padding actualPadSize;
+  uint8_t *tgtImageResampled;
+  std::vector<uint8_t> vecTgtImage, vecTgtImageNFIMM;
+  std::string encComp{"."};
+  std::vector<std::string> resample_metadata;
+
+// Declare the pointers to metadata params and metadata modifier objects.
+// NFIMM is the base class for PNG and BMP derived classes.
+#ifdef USE_NFIMM
+  std::shared_ptr<NFIMM::MetadataParameters> mp;
+  std::unique_ptr<NFIMM::NFIMM> nfimm_mp;
+#endif
+
+  // Based on UP or DOWN sample, instantiate the proper object.
+  if (tgtSampleRate > srcSampleRate) // Upsample
+  {
+    std::unique_ptr<Upsample> resampler(new Upsample(srcSampleRate, tgtSampleRate));
+    resampler->set_interpolationMethod(interpolationMethod);
+
+    resample_metadata.clear();
+    resample_metadata = resampler->to_s();
+    for (auto s : resample_metadata)
+    {
+      log.push_back(s);
+    }
+
+    try
+    {
+      tgtImageMatrix = resampler->resize(srcImageMtx);
+    }
+    catch (const cv::Exception &ex)
+    {
+      std::string err{"NFIR lib: Upsample failed resize(): "};
+      err.append(ex.what());
+      throw NFIR::Miscue(err);
+    }
+
+    if (tgtImageMatrix.empty())
+    {
+      throw NFIR::Miscue("NFIR lib: Upsample failed resized target == 0");
+    }
+
+    log.push_back("UPSAMPLE target img WxH: " + std::to_string(tgtImageMatrix.cols) + "x" + std::to_string(tgtImageMatrix.rows));
+    log.push_back("UPSAMPLE target img matrix size: " + std::to_string(tgtImageMatrix.total()));
+
+    // Encode image to stream of bytes.
+    std::string ncSrcComp = srcComp; // nc = non-const; for tolower() below
+    std::transform(ncSrcComp.begin(), ncSrcComp.end(),
+                  ncSrcComp.begin(), ::tolower);
+    encComp.append(srcComp);
+    cv::imencode(encComp, tgtImageMatrix, vecTgtImage);
+    // Copy the vector to an array of bytes(uint8_t) for call to NFIMM.
+
+    log.push_back("UPSAMPLE target img vector size: " + std::to_string(vecTgtImage.size()));
+    log.push_back("UPSAMPLE target img matrix size: " + std::to_string(tgtImageMatrix.total()));
+    log.push_back("UPSAMPLE target img WxH: " + std::to_string(tgtImageMatrix.cols) + "x" + std::to_string(tgtImageMatrix.rows));
+    log.push_back("UPSAMPLE target img num channels: " + std::to_string(tgtImageMatrix.channels()));
+
+    return vecTgtImage;
+  }
+
+  // Not an UPSAMPLE, so start the DOWNSAMPLE process.
+  FilterMask *currentFilter;
+  // std::unique_ptr<FilterMask> currentFilter;
+  paddedImg = padImage(srcImageMtx, actualPadSize);
+  log.push_back(actualPadSize.to_s());
+
+  // Build the filter/mask for freq domain mulSpectums.
+  // The filter/mask is same dimension (WxH) as the padded, source image.
+  try
+  {
+    // auto resampler = new Downsample( srcSampleRate, tgtSampleRate );
+    std::unique_ptr<Downsample> resampler(new Downsample(srcSampleRate, tgtSampleRate));
+    resampler->set_interpolationMethodAndFilterType(interpolationMethod,
+                                                    filterType);
+    if (resampler->get_filterType() == "Gaussian")
+    {
+      currentFilter = new Gaussian(srcSampleRate, tgtSampleRate);
+      // currentFilter.reset( new Gaussian( srcSampleRate, tgtSampleRate ));
+      currentFilter->build(paddedImg.size());
+    }
+    else if (resampler->get_filterType() == "ideal")
+    {
+      currentFilter = new Ideal(srcSampleRate, tgtSampleRate);
+      // currentFilter.reset( new Ideal( srcSampleRate, tgtSampleRate ));
+      currentFilter->build(paddedImg.size());
+    }
+    else
+    {
+      throw NFIR::Miscue("NFIR lib: invalid parameter filter type: '" + resampler->get_filterType() + "'");
+    }
+
+    // Now that the padded, source image and current filter/mask are available,
+    // ready to downsample.
+    resample_metadata.clear();
+    log.push_back(">> START DOWNSAMPLE (resampler) metadata:");
+    resample_metadata = resampler->to_s();
+    for (auto s : resample_metadata)
+    {
+      log.push_back(s);
+    }
+    log.push_back(">> END DOWNSAMPLE (resampler) metadata");
+
+    tgtImageMatrix = resampler->resize(paddedImg, currentFilter, actualPadSize);
+    if (tgtImageMatrix.empty())
+    {
+      throw NFIR::Miscue("NFIR lib: Downsample failed resize(), target image empty");
+    }
+
+    NFIR::filteredImgPriorToDownsampleDimens = resampler->get_filteredImageDimens();
+    NFIR::filteredImgPriorToDownsample = resampler->get_filteredImage();
+    log.push_back("LOW-PASS-FILTERED target image PRIOR to decimation - WxH: " + std::to_string(NFIR::filteredImgPriorToDownsampleDimens[0]) + "x" + std::to_string(NFIR::filteredImgPriorToDownsampleDimens[1]));
+
+    std::string ncSrcComp = srcComp; // nc = non-const; for tolower() below
+    std::transform(ncSrcComp.begin(), ncSrcComp.end(),
+                  ncSrcComp.begin(), ::tolower);
+    encComp.append(srcComp);
+    cv::imencode(encComp, tgtImageMatrix, vecTgtImage);
+
+    log.push_back("DOWNSAMPLE target img vector size: " + std::to_string(vecTgtImage.size()));
+    log.push_back("DOWNSAMPLE target img matrix size: " + std::to_string(tgtImageMatrix.total()));
+    log.push_back("DOWNSAMPLE target img WxH: " + std::to_string(tgtImageMatrix.cols) + "x" + std::to_string(tgtImageMatrix.rows));
+    log.push_back("DOWNSAMPLE target img num channels: " + std::to_string(tgtImageMatrix.channels()));
+
+    // Clean up
+    delete currentFilter;
+    currentFilter = nullptr;
+  }
+  catch (const cv::Exception &ex)
+  {
+    std::string err{"NFIR lib: Downsample failed resize(): "};
+    err.append(ex.what());
+    throw NFIR::Miscue(err);
+  }
+  return vecTgtImage;
+}
+
 }   // End namespace
 
 
-- 
2.34.1

