From 2651a5dd5bfe7d33963e7f4833be1b9b92101581 Mon Sep 17 00:00:00 2001
From: Rui Oliveira <ruimail24@gmail.com>
Date: Wed, 16 Jun 2021 13:33:39 +0100
Subject: [PATCH] Replace C99 complex types with Microsoft ones

---
 TROUBLESHOOTING                               |   7 +-
 bench/fftbench.c                              |  21 ++-
 examples/agc_crcf_example.c                   |   9 +-
 examples/agc_crcf_qpsk_example.c              |   9 +-
 examples/agc_crcf_squelch_example.c           |   7 +-
 examples/ampmodem_example.c                   |   4 +-
 examples/asgramcf_example.c                   |   3 +-
 examples/autocorr_cccf_example.c              |  14 +-
 examples/bpresync_example.c                   |  26 ++--
 examples/channel_cccf_example.c               |  12 +-
 examples/compand_cf_example.c                 |   3 +-
 examples/conversion_example.c                 |   9 +-
 examples/cpfskmodem_example.c                 |  10 +-
 examples/cpfskmodem_psd_example.c             |  16 +-
 examples/detector_cccf_example.c              |  18 +--
 examples/dotprod_cccf_example.c               |   8 +-
 examples/dsssframesync_example.c              |   4 +-
 examples/eqlms_cccf_blind_example.c           |  28 ++--
 examples/eqlms_cccf_block_example.c           |  14 +-
 .../eqlms_cccf_decisiondirected_example.c     |  24 +--
 examples/eqlms_cccf_example.c                 |  16 +-
 examples/eqrls_cccf_example.c                 |  16 +-
 examples/fading_generator_example.c           |   3 +-
 examples/fft_example.c                        |   9 +-
 examples/fftfilt_crcf_example.c               |  13 +-
 examples/firdecim_crcf_example.c              |   6 +-
 examples/firfilt_cccf_example.c               |  14 +-
 examples/firfilt_cccf_notch_example.c         |   7 +-
 examples/firfilt_crcf_dcblocker_example.c     |   9 +-
 examples/firfilt_crcf_example.c               |  17 +-
 examples/firhilb_decim_example.c              |   4 +-
 examples/firhilb_example.c                    |   8 +-
 examples/firhilb_filter_example.c             |   6 +-
 examples/firhilb_interp_example.c             |   4 +-
 examples/firinterp_crcf_example.c             |   6 +-
 examples/firinterp_firdecim_crcf_example.c    |   8 +-
 examples/firpfbch2_crcf_example.c             |  12 +-
 examples/firpfbch_crcf_analysis_example.c     |  11 +-
 examples/firpfbch_crcf_example.c              |  32 ++--
 examples/firpfbch_crcf_synthesis_example.c    |  13 +-
 examples/firpfbchr_crcf_example.c             |   6 +-
 examples/flexframesync_example.c              |   5 +-
 examples/flexframesync_reconfig_example.c     |   3 +-
 examples/framesync64_example.c                |  11 +-
 examples/freqmodem_example.c                  |   4 +-
 examples/fskframesync_example.c               |  11 +-
 examples/fskmodem_example.c                   |  14 +-
 examples/fskmodem_waterfall_example.c         |   8 +-
 examples/gmskframesync_example.c              |   9 +-
 examples/gmskmodem_example.c                  |   6 +-
 examples/iirdecim_crcf_example.c              |   8 +-
 examples/iirdes_analog_example.c              |   9 +-
 examples/iirdes_pll_example.c                 |   4 +-
 examples/iirfilt_cccf_example.c               |   9 +-
 examples/iirfilt_crcf_dcblocker_example.c     |   9 +-
 examples/iirfilt_crcf_example.c               |   9 +-
 examples/iirhilb_example.c                    |   8 +-
 examples/iirhilb_filter_example.c             |   6 +-
 examples/iirinterp_crcf_example.c             |   6 +-
 examples/modem_arb_example.c                  |   8 +-
 examples/modem_example.c                      |   4 +-
 examples/modem_soft_example.c                 |   4 +-
 examples/msourcecf_example.c                  |   9 +-
 examples/msresamp2_crcf_example.c             |  14 +-
 examples/msresamp_crcf_example.c              |  16 +-
 examples/msresamp_crcf_noise_example.c        |   4 +-
 examples/nco_crcf_mix_example.c               |   4 +-
 examples/nco_example.c                        |   6 +-
 examples/nco_pll_example.c                    |   4 +-
 examples/nco_pll_modem_example.c              |   4 +-
 examples/ofdmflexframesync_example.c          |   3 +-
 examples/ofdmframegen_example.c               |   9 +-
 examples/ofdmframesync_example.c              |  15 +-
 examples/pll_example.c                        |   6 +-
 examples/poly_findroots_example.c             |   4 +-
 examples/qdetector_cccf_example.c             |  18 +--
 examples/qpacketmodem_example.c               |   5 +-
 examples/qpacketmodem_performance_example.c   |  13 +-
 examples/qpilotsync_example.c                 |   9 +-
 examples/resamp2_cccf_example.c               |  14 +-
 examples/resamp2_crcf_decim_example.c         |   8 +-
 examples/resamp2_crcf_example.c               |   8 +-
 examples/resamp2_crcf_filter_example.c        |   8 +-
 examples/resamp2_crcf_interp_example.c        |   8 +-
 examples/resamp_crcf_example.c                |  10 +-
 examples/resamp_crcf_noise_example.c          |   4 +-
 examples/ricek_channel_example.c              |   7 +-
 examples/rresamp_crcf_example.c               |   4 +-
 examples/rresamp_crcf_rnyquist_example.c      |   6 +-
 examples/spgramcf_example.c                   |   7 +-
 examples/spwaterfallcf_example.c              |   6 +-
 examples/symstreamcf_example.c                |   9 +-
 examples/symsync_crcf_example.c               |  10 +-
 examples/symsync_crcf_full_example.c          |  28 ++--
 examples/symsync_crcf_kaiser_example.c        |  18 +--
 examples/symtrack_cccf_example.c              |   8 +-
 include/liquid.internal.h                     | 105 +++++++------
 sandbox/am_demod_dsb_peak_detect_test.c       |   2 +-
 sandbox/am_demod_dsb_pll_carrier_test.c       |   4 +-
 sandbox/am_demod_dsb_pll_costas_test.c        |   4 +-
 sandbox/am_demod_ssb_pll_carrier_test.c       |   6 +-
 sandbox/bpresync_test.c                       |  19 ++-
 sandbox/cpmodem_test.c                        |  12 +-
 sandbox/ellip_func_test.c                     |  11 +-
 sandbox/ellip_test.c                          |  11 +-
 sandbox/eqlms_cccf_test.c                     |  36 ++---
 sandbox/fct_test.c                            |  11 +-
 sandbox/fec_g2412product_test.c               |  14 +-
 sandbox/fec_secded_punctured_test.c           |   9 +-
 sandbox/fec_spc2216_test.c                    |  39 +++--
 sandbox/fecsoft_ber_test.c                    |  13 +-
 sandbox/fecsoft_conv_test.c                   |  19 ++-
 sandbox/fecsoft_ldpc_test.c                   |   5 +-
 sandbox/fft_dual_radix_test.c                 |  33 ++--
 sandbox/fft_mixed_radix_test.c                |  41 +++--
 sandbox/fft_rader_prime_radix2_test.c         |  27 ++--
 sandbox/fft_rader_prime_test.c                |  27 ++--
 sandbox/fft_recursive_test.c                  |  37 +++--
 sandbox/firdes_fexp_test.c                    |  11 +-
 sandbox/firdes_gmskrx_test.c                  |  29 ++--
 sandbox/firpfbch2_analysis_equivalence_test.c |  25 ++-
 sandbox/firpfbch2_test.c                      |  35 ++---
 sandbox/firpfbch_analysis_alignment_test.c    |  17 +-
 sandbox/firpfbch_analysis_equivalence_test.c  |  25 ++-
 sandbox/firpfbch_analysis_test.c              |  23 ++-
 sandbox/firpfbch_synthesis_equivalence_test.c |  27 ++--
 sandbox/fskcorr_test.c                        |  18 +--
 sandbox/fskmodem_test.c                       |  20 +--
 sandbox/gmskmodem_coherent_test.c             |  10 +-
 sandbox/gmskmodem_equalizer_test.c            |  22 +--
 sandbox/gmskmodem_test.c                      |  12 +-
 sandbox/iirdes_example.c                      |  23 ++-
 sandbox/iirfilt_intdiff_test.c                |  25 ++-
 sandbox/matched_filter_cfo_test.c             |  11 +-
 sandbox/math_cacosf_test.c                    |  19 ++-
 sandbox/math_casinf_test.c                    |  21 ++-
 sandbox/math_catanf_test.c                    |  19 ++-
 sandbox/math_cexpf_test.c                     |  23 ++-
 sandbox/math_clogf_test.c                     |  19 ++-
 sandbox/math_csqrtf_test.c                    |  19 ++-
 sandbox/matrix_test.c                         |  11 +-
 sandbox/modem_demodulate_arb_gentab.c         |  27 ++--
 sandbox/modem_demodulate_soft_gentab.c        |  29 ++--
 sandbox/modem_demodulate_soft_test.c          |  10 +-
 sandbox/mskmodem_test.c                       |  20 +--
 sandbox/msresamp_crcf_test.c                  |   4 +-
 sandbox/newbench_example.c                    |   9 +-
 sandbox/ofdm_ber_test.c                       |  11 +-
 sandbox/ofdmframe_papr_test.c                 |  13 +-
 sandbox/ofdmframesync_cfo_test.c              |  15 +-
 sandbox/ofdmoqam_firpfbch_cfo_test.c          |  29 ++--
 sandbox/ofdmoqam_firpfbch_test.c              |  39 +++--
 sandbox/packetizer_persistent_ber_test.c      |  19 ++-
 sandbox/pll_3rd_order_test.c                  |   4 +-
 sandbox/pll_design_test.c                     |   6 +-
 sandbox/predemod_sync_test.c                  |  26 ++--
 sandbox/recursive_qpsk_test.c                 |  13 +-
 sandbox/resamp2_crcf_filterbank_test.c        |   8 +-
 sandbox/resamp2_crcf_interp_recreate_test.c   |   2 +-
 sandbox/symsync_crcf_test.c                   |  22 +--
 sandbox/symsync_eqlms_test.c                  |  36 ++---
 sandbox/throttle_test.c                       |   5 +-
 sandbox/vectorcf_test.c                       |   9 +-
 src/agc/bench/agc_crcf_benchmark.c            |   5 +-
 src/agc/src/agc_crcf.c                        |   2 +-
 src/agc/tests/agc_crcf_autotest.c             |  31 ++--
 src/buffer/bench/cbuffercf_benchmark.c        |   9 +-
 src/buffer/bench/window_read_benchmark.c      |   5 +-
 src/buffer/src/buffercf.c                     |   3 +-
 src/buffer/tests/cbuffer_autotest.c           |  28 ++--
 src/buffer/tests/sbuffer_autotest.c           |   3 +-
 src/channel/src/channel.c                     |   7 +-
 src/channel/src/channel_cccf.c                |   9 +-
 src/channel/src/tvmpch.c                      |   4 +-
 src/dotprod/bench/dotprod_cccf_benchmark.c    |   7 +-
 src/dotprod/bench/dotprod_crcf_benchmark.c    |   5 +-
 src/dotprod/bench/sumsqcf_benchmark.c         |   5 +-
 src/dotprod/src/dotprod_cccf.c                |   8 +-
 src/dotprod/src/dotprod_cccf.mmx.c            |  55 ++++---
 src/dotprod/src/dotprod_cccf.neon.c           |  51 +++---
 src/dotprod/src/dotprod_crcf.av.c             |  21 ++-
 src/dotprod/src/dotprod_crcf.c                |   6 +-
 src/dotprod/src/dotprod_crcf.mmx.c            |  41 +++--
 src/dotprod/src/dotprod_crcf.neon.c           |  43 +++---
 src/dotprod/src/sumsq.c                       |   5 +-
 src/dotprod/src/sumsq.mmx.c                   |   6 +-
 src/dotprod/tests/dotprod_cccf_autotest.c     |  41 +++--
 src/dotprod/tests/dotprod_crcf_autotest.c     |  67 ++++----
 src/dotprod/tests/sumsqcf_autotest.c          |  28 ++--
 src/equalization/bench/eqlms_cccf_benchmark.c |  11 +-
 src/equalization/bench/eqrls_cccf_benchmark.c |  11 +-
 src/equalization/src/eqlms.c                  |   7 +-
 src/equalization/src/equalizer_cccf.c         |   4 +-
 src/equalization/tests/eqlms_cccf_autotest.c  |  21 ++-
 src/fft/bench/fft_runbench.c                  |   7 +-
 src/fft/src/fftf.c                            |   3 +-
 src/fft/src/spgramcf.c                        |   5 +-
 src/fft/src/spgramf.c                         |   3 +-
 src/fft/tests/data/fft_data_10.c              |   5 +-
 src/fft/tests/data/fft_data_120.c             |   5 +-
 src/fft/tests/data/fft_data_130.c             |   5 +-
 src/fft/tests/data/fft_data_157.c             |   5 +-
 src/fft/tests/data/fft_data_16.c              |   5 +-
 src/fft/tests/data/fft_data_17.c              |   5 +-
 src/fft/tests/data/fft_data_192.c             |   5 +-
 src/fft/tests/data/fft_data_2.c               |   5 +-
 src/fft/tests/data/fft_data_20.c              |   5 +-
 src/fft/tests/data/fft_data_21.c              |   5 +-
 src/fft/tests/data/fft_data_22.c              |   5 +-
 src/fft/tests/data/fft_data_24.c              |   5 +-
 src/fft/tests/data/fft_data_26.c              |   5 +-
 src/fft/tests/data/fft_data_3.c               |   5 +-
 src/fft/tests/data/fft_data_30.c              |   5 +-
 src/fft/tests/data/fft_data_317.c             |   5 +-
 src/fft/tests/data/fft_data_32.c              |   5 +-
 src/fft/tests/data/fft_data_35.c              |   5 +-
 src/fft/tests/data/fft_data_36.c              |   5 +-
 src/fft/tests/data/fft_data_4.c               |   5 +-
 src/fft/tests/data/fft_data_43.c              |   5 +-
 src/fft/tests/data/fft_data_48.c              |   5 +-
 src/fft/tests/data/fft_data_5.c               |   5 +-
 src/fft/tests/data/fft_data_509.c             |   5 +-
 src/fft/tests/data/fft_data_6.c               |   5 +-
 src/fft/tests/data/fft_data_63.c              |   5 +-
 src/fft/tests/data/fft_data_64.c              |   5 +-
 src/fft/tests/data/fft_data_7.c               |   5 +-
 src/fft/tests/data/fft_data_79.c              |   5 +-
 src/fft/tests/data/fft_data_8.c               |   5 +-
 src/fft/tests/data/fft_data_9.c               |   5 +-
 src/fft/tests/data/fft_data_92.c              |   5 +-
 src/fft/tests/data/fft_data_96.c              |   5 +-
 src/fft/tests/fft_runtest.c                   |   7 +-
 src/fft/tests/fft_runtest.h                   | 138 ++++++++---------
 src/fft/tests/fft_shift_autotest.c            |  13 +-
 src/filter/bench/fftfilt_crcf_benchmark.c     |   5 +-
 src/filter/bench/firdecim_crcf_benchmark.c    |   5 +-
 src/filter/bench/firfilt_crcf_benchmark.c     |   5 +-
 src/filter/bench/firhilb_benchmark.c          |   3 +-
 src/filter/bench/firinterp_crcf_benchmark.c   |   3 +-
 src/filter/bench/iirdecim_crcf_benchmark.c    |   5 +-
 src/filter/bench/iirfilt_crcf_benchmark.c     |   7 +-
 src/filter/bench/iirinterp_crcf_benchmark.c   |   3 +-
 src/filter/bench/resamp2_crcf_benchmark.c     |   7 +-
 src/filter/bench/resamp_crcf_benchmark.c      |   7 +-
 src/filter/bench/rresamp_crcf_benchmark.c     |   3 +-
 src/filter/bench/symsync_crcf_benchmark.c     |   7 +-
 src/filter/dds.readme.txt                     |  10 +-
 src/filter/src/bessel.c                       |  25 ++-
 src/filter/src/bilinear.c                     |  27 ++--
 src/filter/src/ellip.c                        |  36 ++---
 src/filter/src/fftfilt.c                      |  21 ++-
 src/filter/src/filter_cccf.c                  |  10 +-
 src/filter/src/filter_crcf.c                  |   8 +-
 src/filter/src/firdecim.c                     |   7 +-
 src/filter/src/firdes.c                       |  25 ++-
 src/filter/src/firfarrow.c                    |   7 +-
 src/filter/src/firfilt.c                      |   9 +-
 src/filter/src/firinterp.c                    |   7 +-
 src/filter/src/firpfb.c                       |   9 +-
 src/filter/src/fnyquist.c                     |   7 +-
 src/filter/src/gmsk.c                         |  19 ++-
 src/filter/src/group_delay.c                  |  13 +-
 src/filter/src/iirdes.c                       |  82 +++++-----
 src/filter/src/iirfilt.c                      |  37 +++--
 .../tests/data/fftfilt_cccf_data_h13x256.c    |   7 +-
 .../tests/data/fftfilt_cccf_data_h23x256.c    |   7 +-
 .../tests/data/fftfilt_cccf_data_h4x256.c     |   7 +-
 .../tests/data/fftfilt_cccf_data_h7x256.c     |   7 +-
 .../tests/data/fftfilt_crcf_data_h13x256.c    |   5 +-
 .../tests/data/fftfilt_crcf_data_h23x256.c    |   5 +-
 .../tests/data/fftfilt_crcf_data_h4x256.c     |   5 +-
 .../tests/data/fftfilt_crcf_data_h7x256.c     |   5 +-
 .../tests/data/firdecim_cccf_data_M2h4x20.c   |   7 +-
 .../tests/data/firdecim_cccf_data_M3h7x30.c   |   7 +-
 .../tests/data/firdecim_cccf_data_M4h13x40.c  |   7 +-
 .../tests/data/firdecim_cccf_data_M5h23x50.c  |   7 +-
 .../tests/data/firdecim_crcf_data_M2h4x20.c   |   5 +-
 .../tests/data/firdecim_crcf_data_M3h7x30.c   |   5 +-
 .../tests/data/firdecim_crcf_data_M4h13x40.c  |   5 +-
 .../tests/data/firdecim_crcf_data_M5h23x50.c  |   5 +-
 .../tests/data/firfilt_cccf_data_h13x32.c     |   7 +-
 .../tests/data/firfilt_cccf_data_h23x64.c     |   7 +-
 .../tests/data/firfilt_cccf_data_h4x8.c       |   7 +-
 .../tests/data/firfilt_cccf_data_h7x16.c      |   7 +-
 .../tests/data/firfilt_crcf_data_h13x32.c     |   5 +-
 .../tests/data/firfilt_crcf_data_h23x64.c     |   5 +-
 .../tests/data/firfilt_crcf_data_h4x8.c       |   5 +-
 .../tests/data/firfilt_crcf_data_h7x16.c      |   5 +-
 .../tests/data/iirfilt_cccf_data_h3x64.c      |   9 +-
 .../tests/data/iirfilt_cccf_data_h5x64.c      |   9 +-
 .../tests/data/iirfilt_cccf_data_h7x64.c      |   9 +-
 .../tests/data/iirfilt_crcf_data_h3x64.c      |   5 +-
 .../tests/data/iirfilt_crcf_data_h5x64.c      |   5 +-
 .../tests/data/iirfilt_crcf_data_h7x64.c      |   5 +-
 src/filter/tests/fftfilt_autotest.h           |  53 ++++---
 src/filter/tests/fftfilt_runtest.c            |  21 ++-
 src/filter/tests/firdecim_autotest.h          |  53 ++++---
 src/filter/tests/firdecim_runtest.c           |  27 ++--
 src/filter/tests/firdes_autotest.c            |  34 ++--
 src/filter/tests/firfilt_autotest.h           |  53 ++++---
 .../tests/firfilt_cccf_notch_autotest.c       |   7 +-
 src/filter/tests/firfilt_runtest.c            |  25 ++-
 src/filter/tests/firhilb_autotest.c           |   7 +-
 src/filter/tests/firinterp_autotest.c         |  17 +-
 src/filter/tests/iirdes_autotest.c            |  39 +++--
 src/filter/tests/iirfilt_autotest.h           |  51 +++---
 src/filter/tests/iirfilt_runtest.c            |  27 ++--
 src/filter/tests/msresamp_crcf_autotest.c     |  12 +-
 src/filter/tests/resamp2_crcf_autotest.c      |  20 +--
 src/filter/tests/resamp_crcf_autotest.c       |  12 +-
 src/filter/tests/rresamp_crcf_autotest.c      |  13 +-
 src/filter/tests/symsync_crcf_autotest.c      |  19 ++-
 src/framing/bench/bpresync_benchmark.c        |   7 +-
 src/framing/bench/bsync_benchmark.c           |   7 +-
 src/framing/bench/detector_benchmark.c        |   5 +-
 src/framing/bench/flexframesync_benchmark.c   |   5 +-
 src/framing/bench/framesync64_benchmark.c     |   5 +-
 src/framing/bench/gmskframesync_benchmark.c   |   9 +-
 src/framing/bench/presync_benchmark.c         |   7 +-
 src/framing/bench/qdetector_benchmark.c       |   5 +-
 src/framing/src/bpresync.c                    |  19 ++-
 src/framing/src/bpresync_cccf.c               |   9 +-
 src/framing/src/bsync_cccf.c                  |   9 +-
 src/framing/src/bsync_crcf.c                  |   7 +-
 src/framing/src/detector_cccf.c               |  48 +++---
 src/framing/src/dsssframegen.c                |   4 +-
 src/framing/src/dsssframesync.c               |  12 +-
 src/framing/src/flexframegen.c                |  59 ++++---
 src/framing/src/flexframesync.c               |  85 +++++-----
 src/framing/src/framegen64.c                  |  10 +-
 src/framing/src/framesync64.c                 |  63 ++++----
 src/framing/src/fskframegen.c                 |  17 +-
 src/framing/src/fskframesync.c                |  45 +++---
 src/framing/src/gmskframegen.c                |  33 ++--
 src/framing/src/gmskframesync.c               |  76 ++++-----
 src/framing/src/msource.c                     |  16 +-
 src/framing/src/msourcecf.c                   |   3 +-
 src/framing/src/ofdmflexframegen.c            |  17 +-
 src/framing/src/ofdmflexframesync.c           |  35 ++---
 src/framing/src/presync.c                     |  19 ++-
 src/framing/src/presync_cccf.c                |   9 +-
 src/framing/src/qdetector_cccf.c              |  81 +++++-----
 src/framing/src/qpacketmodem.c                |  12 +-
 src/framing/src/qpilotgen.c                   |  11 +-
 src/framing/src/qpilotsync.c                  |  24 ++-
 src/framing/src/qsource.c                     |  23 ++-
 src/framing/src/symstreamcf.c                 |   3 +-
 src/framing/src/symtrack_cccf.c               |   7 +-
 src/framing/tests/bsync_autotest.c            |  35 ++---
 src/framing/tests/detector_autotest.c         |  24 ++-
 src/framing/tests/flexframesync_autotest.c    |   9 +-
 src/framing/tests/framesync64_autotest.c      |  11 +-
 src/framing/tests/qdetector_cccf_autotest.c   |  18 +--
 src/framing/tests/qpacketmodem_autotest.c     |   7 +-
 src/framing/tests/qpilotsync_autotest.c       |  15 +-
 src/math/src/math.complex.c                   |  19 ++-
 src/math/src/poly.c                           |   5 +-
 src/math/src/polyc.c                          |   7 +-
 src/math/src/polycf.c                         |   7 +-
 src/math/src/polyf.c                          |   5 +-
 src/math/tests/math_complex_autotest.c        |  48 +++---
 src/math/tests/polynomial_autotest.c          |  42 +++--
 .../tests/polynomial_findroots_autotest.c     |  25 ++-
 src/matrix/src/matrixc.c                      |   5 +-
 src/matrix/src/matrixcf.c                     |   5 +-
 src/matrix/tests/data/matrixcf_data_add.c     |   7 +-
 src/matrix/tests/data/matrixcf_data_aug.c     |   7 +-
 src/matrix/tests/data/matrixcf_data_chol.c    |   5 +-
 src/matrix/tests/data/matrixcf_data_inv.c     |   5 +-
 .../tests/data/matrixcf_data_linsolve.c       |   7 +-
 .../tests/data/matrixcf_data_ludecomp.c       |   3 +-
 src/matrix/tests/data/matrixcf_data_mul.c     |   7 +-
 .../tests/data/matrixcf_data_qrdecomp.c       |   7 +-
 .../tests/data/matrixcf_data_transmul.c       |  11 +-
 src/matrix/tests/matrix_data.h                |  55 ++++---
 src/matrix/tests/matrixcf_autotest.c          |  55 ++++---
 src/modem/bench/freqdem_benchmark.c           |   4 +-
 src/modem/bench/freqmod_benchmark.c           |   4 +-
 src/modem/bench/fskdem_benchmark.c            |   5 +-
 src/modem/bench/fskmod_benchmark.c            |   5 +-
 src/modem/bench/gmskmodem_benchmark.c         |  13 +-
 src/modem/bench/modem_demodsoft_benchmark.c   |   3 +-
 src/modem/bench/modem_demodulate_benchmark.c  |   3 +-
 src/modem/bench/modem_modulate_benchmark.c    |   5 +-
 src/modem/src/ampmodem.c                      |  43 +++---
 src/modem/src/cpfskdem.c                      |  43 +++---
 src/modem/src/cpfskmod.c                      |   7 +-
 src/modem/src/fskdem.c                        |  23 ++-
 src/modem/src/fskmod.c                        |   7 +-
 src/modem/src/gmskdem.c                       |   4 +-
 src/modem/src/gmskmod.c                       |   4 +-
 src/modem/src/modem_arb_const.c               | 112 +++++++-------
 src/modem/src/modem_ook.c                     |   5 +-
 src/modem/src/modemf.c                        |   2 +-
 src/modem/tests/ampmodem_autotest.c           |   6 +-
 src/modem/tests/cpfskmodem_autotest.c         |   5 +-
 src/modem/tests/freqmodem_autotest.c          |   3 +-
 src/modem/tests/fskmodem_autotest.c           |   5 +-
 src/modem/tests/modem_autotest.c              |   5 +-
 src/modem/tests/modem_demodsoft_autotest.c    |   7 +-
 src/modem/tests/modem_demodstats_autotest.c   |   5 +-
 .../bench/firpfbch2_crcf_benchmark.c          |   6 +-
 .../bench/firpfbch_crcf_benchmark.c           |   6 +-
 .../bench/firpfbchr_crcf_benchmark.c          |   5 +-
 .../bench/ofdmframesync_acquire_benchmark.c   |   3 +-
 .../bench/ofdmframesync_rxsymbol_benchmark.c  |   5 +-
 src/multichannel/src/firpfbch_cccf.c          |  11 +-
 src/multichannel/src/firpfbch_crcf.c          |   9 +-
 src/multichannel/src/firpfbch_old.c           |  42 ++---
 src/multichannel/src/ofdmframe.common.c       |   9 +-
 src/multichannel/src/ofdmframegen.c           |  57 ++++---
 src/multichannel/src/ofdmframesync.c          | 145 +++++++++---------
 .../tests/firpfbch2_crcf_autotest.c           |   9 +-
 .../tests/firpfbch_crcf_analyzer_autotest.c   |  12 +-
 .../firpfbch_crcf_synthesizer_autotest.c      |  17 +-
 .../tests/ofdmframesync_autotest.c            |  13 +-
 src/nco/bench/nco_benchmark.c                 |   9 +-
 src/nco/bench/vco_benchmark.c                 |   9 +-
 src/nco/src/nco_crcf.c                        |   2 +-
 src/nco/tests/data/nco_sincos_fsqrt1_2.c      |   3 +-
 src/nco/tests/data/nco_sincos_fsqrt1_3.c      |   3 +-
 src/nco/tests/data/nco_sincos_fsqrt1_5.c      |   3 +-
 src/nco/tests/data/nco_sincos_fsqrt1_7.c      |   3 +-
 src/nco/tests/nco_crcf_frequency_autotest.c   |  15 +-
 src/nco/tests/nco_crcf_mix_autotest.c         |   7 +-
 src/nco/tests/nco_crcf_phase_autotest.c       |   5 +-
 src/nco/tests/nco_crcf_pll_autotest.c         |   5 +-
 src/quantization/src/compand.c                |   5 +-
 src/quantization/src/quantizercf.c            |   4 +-
 src/quantization/tests/compand_autotest.c     |   9 +-
 src/random/bench/random_benchmark.c           |  13 +-
 src/random/src/randn.c                        |   9 +-
 src/random/src/randricek.c                    |   4 +-
 src/random/tests/random_autotest.c            |   3 +-
 src/vector/src/vectorcf_add.port.c            |   5 +-
 src/vector/src/vectorcf_mul.port.c            |   5 +-
 src/vector/src/vectorcf_norm.port.c           |   5 +-
 src/vector/src/vectorcf_trig.port.c           |   5 +-
 438 files changed, 2963 insertions(+), 3324 deletions(-)

diff --git a/TROUBLESHOOTING b/TROUBLESHOOTING
index 05cccd97..31f3a9dc 100644
--- a/TROUBLESHOOTING
+++ b/TROUBLESHOOTING
@@ -9,11 +9,11 @@ Here is a list of common problems and potential solutions.
         "internal compiler error: in gimplify_expr, at gimplify.c:7153"
 
  A1(a)  This is a bug with gcc v4.5.1 and v4.5.2 dealing with complex
-        data type, e.g. "float complex"
+        data type, e.g. "_Fcomplex"
         (see: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=47150).
         The best option is to update your compiler to a more recent
         version, revert to an older version, or apply a patch.
-      
+
  A1(b)  Alternatively, if you are observing this error with ellip.c you
         can probably comment out the offending lines; however this will
         render the elliptic filter generator in liquid-dsp useless. This
@@ -56,7 +56,7 @@ Q3      When I try compiling on OS 10.9 I get the following error when trying
 
         configure: error: Need standard c library!
 
-        or 
+        or
 
         configure: error: Could not use standard c library!
 
@@ -70,4 +70,3 @@ A3      This is likely a result of using Apple's default build of gcc (LLVM
         $ export CC="/usr/local/bin/gcc-4.8"
 
         I know this is a work-around; I'm working on a permanent fix.
-
diff --git a/bench/fftbench.c b/bench/fftbench.c
index bc9c5298..ed90f930 100644
--- a/bench/fftbench.c
+++ b/bench/fftbench.c
@@ -72,7 +72,7 @@ typedef enum {
     LIB_FLOAT=0,
     LIB_FFTW,
 } library_t;
-    
+
 // simulation structure
 struct fftbench_s {
     enum {RUN_ALL=0,
@@ -85,7 +85,7 @@ struct fftbench_s {
 
     // library version
     library_t library;
-    
+
     int verbose;
     float runtime;   // minimum run time (s)
 
@@ -197,7 +197,7 @@ int main(int argc, char *argv[])
     for (i=0; i<1e6; i++) {
         // do nothing
     }
-    
+
     // open output file (if applicable)
     if (fftbench.output_to_file) {
         fftbench.fid = fopen(fftbench.filename,"w");
@@ -337,7 +337,7 @@ void fftbench_execute(struct fftbench_s * _fftbench)
         };
         return;
     }
-        
+
     printf("running ");
     switch (_fftbench->mode) {
     case RUN_ALL:       printf("all");              break;
@@ -435,13 +435,13 @@ void benchmark_fft(struct rusage *      _start,
                    struct benchmark_s * _benchmark)
 {
     // initialize arrays, plan
-    float complex * x = (float complex *) malloc((_benchmark->nfft)*sizeof(float complex));
-    float complex * y = (float complex *) malloc((_benchmark->nfft)*sizeof(float complex));
+    _Fcomplex * x = (_Fcomplex *) malloc((_benchmark->nfft)*sizeof(_Fcomplex));
+    _Fcomplex * y = (_Fcomplex *) malloc((_benchmark->nfft)*sizeof(_Fcomplex));
     fftplan q = fft_create_plan(_benchmark->nfft,
                                 x, y,
                                 _benchmark->direction,
                                 _benchmark->flags);
-    
+
     unsigned long int i;
 
     // initialize input with random values
@@ -476,14 +476,14 @@ void benchmark_fftw(struct rusage *      _start,
                     struct benchmark_s * _benchmark)
 {
     // initialize arrays, plan
-    float complex * x = (float complex *) malloc((_benchmark->nfft)*sizeof(float complex));
-    float complex * y = (float complex *) malloc((_benchmark->nfft)*sizeof(float complex));
+    _Fcomplex * x = (_Fcomplex *) malloc((_benchmark->nfft)*sizeof(_Fcomplex));
+    _Fcomplex * y = (_Fcomplex *) malloc((_benchmark->nfft)*sizeof(_Fcomplex));
     fftwf_plan q = fftwf_plan_dft_1d(_benchmark->nfft,
                                      x, y,
                                      //_benchmark->direction,
                                      FFTW_FORWARD,
                                      FFTW_ESTIMATE);
-    
+
     unsigned long int i;
 
     // initialize input with random values
@@ -536,4 +536,3 @@ void benchmark_print(struct benchmark_s * _benchmark)
             time_format, time_units,
             _benchmark->flops * 1e-6f);
 }
-
diff --git a/examples/agc_crcf_example.c b/examples/agc_crcf_example.c
index 38ed5114..79f50125 100644
--- a/examples/agc_crcf_example.c
+++ b/examples/agc_crcf_example.c
@@ -50,7 +50,7 @@ int main(int argc, char*argv[])
         fprintf(stderr,"error: %s, number of samples must be greater than zero\n", argv[0]);
         exit(1);
     }
-    
+
     unsigned int i;
 
     // create objects
@@ -58,8 +58,8 @@ int main(int argc, char*argv[])
     agc_crcf_set_bandwidth(q, bt);
     //agc_crcf_set_scale(q, 0.5f);
 
-    float complex x[num_samples];   // input
-    float complex y[num_samples];   // output
+    _Fcomplex x[num_samples];   // input
+    _Fcomplex y[num_samples];   // output
     float rssi[num_samples];        // received signal strength
 
     // print info
@@ -81,7 +81,7 @@ int main(int argc, char*argv[])
     // destroy AGC object
     agc_crcf_destroy(q);
 
-    // 
+    //
     // export results
     //
     FILE* fid = fopen(OUTPUT_FILENAME,"w");
@@ -127,4 +127,3 @@ int main(int argc, char*argv[])
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/agc_crcf_qpsk_example.c b/examples/agc_crcf_qpsk_example.c
index 5dc9b29d..15319133 100644
--- a/examples/agc_crcf_qpsk_example.c
+++ b/examples/agc_crcf_qpsk_example.c
@@ -35,8 +35,8 @@ int main(int argc, char*argv[])
     float nstd = powf(10.0f, noise_floor / 20.0f);
 
     // arrays
-    float complex x[num_samples];
-    float complex y[num_samples];
+    _Fcomplex x[num_samples];
+    _Fcomplex y[num_samples];
     float rssi[num_samples];
 
     // create objects
@@ -51,7 +51,7 @@ int main(int argc, char*argv[])
     printf("automatic gain control // loop bandwidth: %4.2e\n",bt);
 
     unsigned int sym;
-    float complex s;
+    _Fcomplex s;
     for (i=0; i<num_symbols; i++) {
         // generate random symbol
         sym = modem_gen_rand_sym(mod);
@@ -84,7 +84,7 @@ int main(int argc, char*argv[])
     }
 
 
-    // 
+    //
     // export results
     //
     FILE* fid = fopen(OUTPUT_FILENAME,"w");
@@ -121,4 +121,3 @@ int main(int argc, char*argv[])
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/agc_crcf_squelch_example.c b/examples/agc_crcf_squelch_example.c
index 5585b4ca..82d80c5c 100644
--- a/examples/agc_crcf_squelch_example.c
+++ b/examples/agc_crcf_squelch_example.c
@@ -57,8 +57,8 @@ int main(int argc, char*argv[])
 
     // initialize arrays
     unsigned int  num_samples = 2000;       // total number of samples to run
-    float complex x   [num_samples];        // input
-    float complex y   [num_samples];        // output
+    _Fcomplex x   [num_samples];        // input
+    _Fcomplex y   [num_samples];        // output
     float         rssi[num_samples];        // received signal strength
     int           mode[num_samples];        // squelch mode
 
@@ -109,7 +109,7 @@ int main(int argc, char*argv[])
     // destroy AGC object
     agc_crcf_destroy(q);
 
-    // 
+    //
     // export results
     //
     FILE* fid = fopen(OUTPUT_FILENAME,"w");
@@ -163,4 +163,3 @@ int main(int argc, char*argv[])
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/ampmodem_example.c b/examples/ampmodem_example.c
index 1179a664..7576499d 100644
--- a/examples/ampmodem_example.c
+++ b/examples/ampmodem_example.c
@@ -1,4 +1,4 @@
-// 
+//
 // ampmodem_test.c
 //
 // Tests simple modulation/demodulation of the ampmodem (analog
@@ -76,7 +76,7 @@ int main(int argc, char*argv[])
 
     unsigned int i;
     float         x[num_samples];
-    float complex y[num_samples];
+    _Fcomplex y[num_samples];
     float         z[num_samples];
 
     // generate 'audio' signal (simple windowed sum of tones)
diff --git a/examples/asgramcf_example.c b/examples/asgramcf_example.c
index 052e096e..e8b382c5 100644
--- a/examples/asgramcf_example.c
+++ b/examples/asgramcf_example.c
@@ -32,7 +32,7 @@ int main() {
     float phi    = 0.0f;    // phase of sinusoidal frequency drift
     float dphi   = 0.003f;  // frequency of sinusoidal frequency drift
 
-    float complex x[nfft];
+    _Fcomplex x[nfft];
     float nstd = powf(10.0f,noise_floor/20.0f);  // noise standard deviation
     for (n=0; n<num_frames; n++) {
         // generate a frame of data samples
@@ -63,4 +63,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/autocorr_cccf_example.c b/examples/autocorr_cccf_example.c
index ba868b56..2e0daa51 100644
--- a/examples/autocorr_cccf_example.c
+++ b/examples/autocorr_cccf_example.c
@@ -64,9 +64,9 @@ int main(int argc, char*argv[]) {
     unsigned int num_samples = sequence_len*(n+2); // pad end w/ zeros
 
     // data arrays
-    float complex sequence[sequence_len];   // short sequence
-    float complex x[num_samples];           // autocorr input sequence
-    float complex rxx[num_samples];         // autocorr output
+    _Fcomplex sequence[sequence_len];   // short sequence
+    _Fcomplex x[num_samples];           // autocorr input sequence
+    _Fcomplex rxx[num_samples];         // autocorr output
 
     // generate objects
     autocorr_cccf q = autocorr_cccf_create(window_size,delay);
@@ -83,7 +83,7 @@ int main(int argc, char*argv[]) {
     unsigned int t=0;
     for (i=0; i<n; i++) {
         // copy sequence
-        memmove(&x[t], sequence, sequence_len*sizeof(float complex));
+        memmove(&x[t], sequence, sequence_len*sizeof(_Fcomplex));
 
         t += sequence_len;
     }
@@ -96,7 +96,7 @@ int main(int argc, char*argv[]) {
     float nstd = powf(10.0f, -SNRdB/20.0f);
     for (i=0; i<num_samples; i++)
         cawgn(&x[i],nstd);
-        
+
     // compute auto-correlation
     for (i=0; i<num_samples; i++) {
         autocorr_cccf_push(q,x[i]);
@@ -108,7 +108,7 @@ int main(int argc, char*argv[]) {
     }
 
     // find peak
-    float complex rxx_peak = 0;
+    _Fcomplex rxx_peak = 0;
     for (i=0; i<num_samples; i++) {
         if (i==0 || cabsf(rxx[i]) > cabsf(rxx_peak))
             rxx_peak = rxx[i];
@@ -120,7 +120,7 @@ int main(int argc, char*argv[]) {
     // destroy allocated objects
     autocorr_cccf_destroy(q);
 
-    // 
+    //
     // write results to file
     //
     FILE* fid = fopen(OUTPUT_FILENAME, "w");
diff --git a/examples/bpresync_example.c b/examples/bpresync_example.c
index 187f3e77..64f504f6 100644
--- a/examples/bpresync_example.c
+++ b/examples/bpresync_example.c
@@ -1,4 +1,4 @@
-// 
+//
 // bpresync_example.c
 //
 // This example demonstrates the binary pre-demodulator synchronizer. A random
@@ -79,11 +79,11 @@ int main(int argc, char*argv[])
     float nstd = powf(10.0f, -SNRdB/20.0f);
 
     // arrays
-    float complex seq[num_sync_symbols];    // synchronization pattern (symbols)
-    float complex s0[k*num_sync_symbols];   // synchronization pattern (samples)
-    float complex x[num_samples];           // transmitted signal
-    float complex y[num_samples];           // received signal
-    float complex rxy[num_samples];         // pre-demod correlation output
+    _Fcomplex seq[num_sync_symbols];    // synchronization pattern (symbols)
+    _Fcomplex s0[k*num_sync_symbols];   // synchronization pattern (samples)
+    _Fcomplex x[num_samples];           // transmitted signal
+    _Fcomplex y[num_samples];           // received signal
+    _Fcomplex rxy[num_samples];         // pre-demod correlation output
     float dphi_hat[num_samples];            // carrier offset estimate
 
     // create transmit/receive interpolator/decimator
@@ -91,8 +91,8 @@ int main(int argc, char*argv[])
 
     // generate synchronization pattern (BPSK) and interpolate
     for (i=0; i<num_sync_symbols + 2*m; i++) {
-        float complex sym = 0.0f;
-    
+        _Fcomplex sym = 0.0f;
+
         if (i < num_sync_symbols) {
             sym = rand() % 2 ? -1.0f : 1.0f;
             seq[i] = sym;
@@ -107,7 +107,7 @@ int main(int argc, char*argv[])
 
     // interpolate input
     for (i=0; i<num_symbols; i++) {
-        float complex sym = i < num_sync_symbols ? seq[i] : 0.0f;
+        _Fcomplex sym = i < num_sync_symbols ? seq[i] : 0.0f;
 
         firinterp_crcf_execute(interp, sym, &x[k*i]);
     }
@@ -125,7 +125,7 @@ int main(int argc, char*argv[])
     float dphi_est = 0.0f;  // carrier frequency offset estimate
     int delay_est  = 0;     // delay estimate
     for (i=0; i<num_samples; i++) {
-        
+
         // correlate
         bpresync_cccf_push(sync, y[i]);
         bpresync_cccf_execute(sync, &rxy[i], &dphi_hat[i]);
@@ -135,7 +135,7 @@ int main(int argc, char*argv[])
             printf("****** preamble found, rxy = %12.8f (dphi-hat: %12.8f), i=%3u ******\n",
                     cabsf(rxy[i]), dphi_hat[i], i);
         }
-        
+
         // retain maximum
         if (cabsf(rxy[i]) > rxy_max) {
             rxy_max   = cabsf(rxy[i]);
@@ -147,7 +147,7 @@ int main(int argc, char*argv[])
     // destroy objects
     firinterp_crcf_destroy(interp);
     bpresync_cccf_destroy(sync);
-    
+
     // print results
     printf("\n");
     printf("rxy (max) : %12.8f\n", rxy_max);
@@ -155,7 +155,7 @@ int main(int argc, char*argv[])
     printf("delay est.: %12d ,error=%3d sample(s)\n", delay_est, k*num_sync_symbols - delay_est);
     printf("\n");
 
-    // 
+    //
     // export results
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/channel_cccf_example.c b/examples/channel_cccf_example.c
index d400c9c9..35fbb519 100644
--- a/examples/channel_cccf_example.c
+++ b/examples/channel_cccf_example.c
@@ -90,11 +90,11 @@ int main(int argc, char*argv[])
     // derived/fixed values
     unsigned int num_samples = num_symbols*k;
 
-    float complex x[num_samples];    // input (interpolated) samples
-    float complex y[num_samples];    // channel output samples
-    float complex sym_out[num_symbols + 64];// synchronized symbols
+    _Fcomplex x[num_samples];    // input (interpolated) samples
+    _Fcomplex y[num_samples];    // channel output samples
+    _Fcomplex sym_out[num_symbols + 64];// synchronized symbols
 
-    // 
+    //
     // generate input sequence using symbol stream generator
     //
     symstreamcf gen = symstreamcf_create_linear(LIQUID_FIRFILT_ARKAISER,k,m,beta,ms);
@@ -119,11 +119,11 @@ int main(int argc, char*argv[])
     // destroy channel
     channel_cccf_destroy(channel);
 
-    // 
+    //
     // create and run symbol synchronizer
     //
     symtrack_cccf symtrack = symtrack_cccf_create(LIQUID_FIRFILT_RRC,k,m,beta,ms);
-    
+
     // set tracking bandwidth
     symtrack_cccf_set_bandwidth(symtrack,0.05f);
 
diff --git a/examples/compand_cf_example.c b/examples/compand_cf_example.c
index d6276179..d8bf490a 100644
--- a/examples/compand_cf_example.c
+++ b/examples/compand_cf_example.c
@@ -21,7 +21,7 @@ int main() {
     fprintf(fid,"clear all\n");
     fprintf(fid,"close all\n");
 
-    float complex x, y, z;
+    _Fcomplex x, y, z;
     int i, j;
 
     for (i=0; i<n+1; i++) {
@@ -61,4 +61,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/conversion_example.c b/examples/conversion_example.c
index 0fefc65a..8eaf2e3d 100644
--- a/examples/conversion_example.c
+++ b/examples/conversion_example.c
@@ -56,7 +56,7 @@ int main()
     unsigned int i;
     for (i=0; i<num_samples; i++) {
         // STEP 1: generate input signal (filtered noise with offset tone)
-        float complex v1 = (randnf() + randnf()*_Complex_I) + 3.0f*cexpf(-_Complex_I*0.2f*i);
+        _Fcomplex v1 = (randnf() + randnf()*_Complex_I) + 3.0f*cexpf(-_Complex_I*0.2f*i);
         iirfilt_crcf_execute(filter_tx, v1, &v1);
 
         // save spectrum
@@ -71,7 +71,7 @@ int main()
         spgramf_push(spgram_dac, v2);
 
         // STEP 3: mix signal down and filter off image
-        float complex v3;
+        _Fcomplex v3;
         nco_crcf_mix_down(mixer_rx, v2, &v3);
         iirfilt_crcf_execute(filter_rx, v3, &v3);
         nco_crcf_step(mixer_rx);
@@ -98,7 +98,7 @@ int main()
     nco_crcf_destroy(mixer_rx);
     iirfilt_crcf_destroy(filter_rx);
 
-    // 
+    //
     // export output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -111,7 +111,7 @@ int main()
     fprintf(fid,"psd_tx = zeros(1,nfft);\n");
     fprintf(fid,"psd_dac= zeros(1,nfft);\n");
     fprintf(fid,"psd_rx = zeros(1,nfft);\n");
-    
+
     for (i=0; i<nfft; i++) {
         fprintf(fid,"psd_tx (%6u) = %12.4e;\n", i+1, psd_tx [i]);
         fprintf(fid,"psd_dac(%6u) = %12.4e;\n", i+1, psd_dac[i]);
@@ -136,4 +136,3 @@ int main()
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/cpfskmodem_example.c b/examples/cpfskmodem_example.c
index 6858c392..af1c9214 100644
--- a/examples/cpfskmodem_example.c
+++ b/examples/cpfskmodem_example.c
@@ -1,4 +1,4 @@
-// 
+//
 // cpfskmodem_example.c
 //
 // This example demostrates the continuous phase frequency-shift keying
@@ -82,8 +82,8 @@ int main(int argc, char*argv[])
 
     // arrays
     unsigned int  sym_in [num_symbols]; // input symbols
-    float complex x      [num_samples]; // transmitted signal
-    float complex y      [num_samples]; // received signal
+    _Fcomplex x      [num_samples]; // transmitted signal
+    _Fcomplex y      [num_samples]; // received signal
     unsigned int  sym_out[num_symbols]; // output symbols
 
     // create modem objects
@@ -92,7 +92,7 @@ int main(int argc, char*argv[])
 
     // print modulator
     cpfskmod_print(mod);
-    
+
     // get full symbol delay
     unsigned int delay = cpfskmod_get_delay(mod) + cpfskdem_get_delay(dem);
     printf("delay: %u samples\n", delay);
@@ -131,7 +131,7 @@ int main(int argc, char*argv[])
     float psd[nfft];
     spgramcf_estimate_psd(nfft, x, num_samples, psd);
 
-    // 
+    //
     // export results
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/cpfskmodem_psd_example.c b/examples/cpfskmodem_psd_example.c
index 08dd6585..598728ea 100644
--- a/examples/cpfskmodem_psd_example.c
+++ b/examples/cpfskmodem_psd_example.c
@@ -1,4 +1,4 @@
-// 
+//
 // cpfsk_psd_example.c
 //
 // This example demonstrates the differences in power spectral
@@ -69,10 +69,10 @@ int main(int argc, char*argv[])
     cpfskmod mod_3 = cpfskmod_create(bps, h, k, m, beta, LIQUID_CPFSK_GMSK);
 
     // buffers
-    float complex buf_0[k];
-    float complex buf_1[k];
-    float complex buf_2[k];
-    float complex buf_3[k];
+    _Fcomplex buf_0[k];
+    _Fcomplex buf_1[k];
+    _Fcomplex buf_2[k];
+    _Fcomplex buf_3[k];
 
     // create PSD estimators
     // spectral periodogram options
@@ -94,14 +94,14 @@ int main(int argc, char*argv[])
         cpfskmod_modulate(mod_1, sym, buf_1);
         cpfskmod_modulate(mod_2, sym, buf_2);
         cpfskmod_modulate(mod_3, sym, buf_3);
-        
+
         // estimate PSD
         spgramcf_write(spgram_0, buf_0, k);
         spgramcf_write(spgram_1, buf_1, k);
         spgramcf_write(spgram_2, buf_2, k);
         spgramcf_write(spgram_3, buf_3, k);
     }
-    
+
     // compute power spectral density estimate output
     float psd_0[nfft]; spgramcf_get_psd(spgram_0, psd_0);
     float psd_1[nfft]; spgramcf_get_psd(spgram_1, psd_1);
@@ -120,7 +120,7 @@ int main(int argc, char*argv[])
     spgramcf_destroy(spgram_2);
     spgramcf_destroy(spgram_3);
 
-    // 
+    //
     // export results
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/detector_cccf_example.c b/examples/detector_cccf_example.c
index 82f19875..96de57c0 100644
--- a/examples/detector_cccf_example.c
+++ b/examples/detector_cccf_example.c
@@ -1,4 +1,4 @@
-// 
+//
 // detector_example.c
 //
 // This example demonstrates the binary pre-demodulator synchronizer. A random
@@ -71,12 +71,12 @@ int main(int argc, char*argv[])
     float gamma = powf(10.0f, (SNRdB + noise_floor)/20.0f);
 
     // arrays
-    float complex s[n];             // synchronization pattern (samples)
-    float complex x[num_samples];   // transmitted signal
-    float complex y[num_samples];   // received signal
+    _Fcomplex s[n];             // synchronization pattern (samples)
+    _Fcomplex x[num_samples];   // transmitted signal
+    _Fcomplex y[num_samples];   // received signal
 
     // generate synchronization pattern (OFDM symbol, slightly over-sampled)
-    float complex S[n];
+    _Fcomplex S[n];
     for (i=0; i<n; i++)
         S[i] = (i < 0.4*n || i > 0.6*n) ? randnf() + _Complex_I*randnf() : 0.0f;
     fft_run(n, S, s, LIQUID_FFT_BACKWARD, 0);
@@ -112,7 +112,7 @@ int main(int argc, char*argv[])
 
         // carrier offset
         y[i] *= cexpf(_Complex_I*(dphi*i + phi));
-        
+
         // noise
         y[i] += nstd*(randnf() + _Complex_I*randnf())*M_SQRT1_2;
     }
@@ -128,7 +128,7 @@ int main(int argc, char*argv[])
     int signal_detected = 0;
     unsigned int index = 0;
     for (i=0; i<num_samples; i++) {
-        
+
         // correlate
         int detected = detector_cccf_correlate(sync, y[i], &tau_hat, &dphi_hat, &gamma_hat);
 
@@ -142,7 +142,7 @@ int main(int argc, char*argv[])
 
     // destroy objects
     detector_cccf_destroy(sync);
-    
+
     // print results
     printf("\n");
     printf("signal detected :   %s\n", signal_detected ? "yes" : "no");
@@ -153,7 +153,7 @@ int main(int argc, char*argv[])
     printf("gamma estimate  : %8.3f, actual=%8.3f (error=%8.3f) dB\n",        20*log10f(gamma_hat), 20*log10f(gamma), 20*log10(gamma/gamma_hat));
     printf("\n");
 
-    // 
+    //
     // export results
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/dotprod_cccf_example.c b/examples/dotprod_cccf_example.c
index 7e83cee2..53eabb8c 100644
--- a/examples/dotprod_cccf_example.c
+++ b/examples/dotprod_cccf_example.c
@@ -10,21 +10,21 @@
 
 int main() {
     // input array
-    float complex x[] = { 1 + 1 * _Complex_I,
+    _Fcomplex x[] = { 1 + 1 * _Complex_I,
                           2 + 1 * _Complex_I,
                           3 + 1 * _Complex_I,
                           4 + 1 * _Complex_I,
                           5 + 1 * _Complex_I};
 
     // coefficients array
-    float complex h[] = { 1 + 1 * _Complex_I,
+    _Fcomplex h[] = { 1 + 1 * _Complex_I,
                          -1 + 1 * _Complex_I,
                           1 + 1 * _Complex_I,
                          -1 + 1 * _Complex_I,
                           1 + 1 * _Complex_I};
 
     // dot product result
-    float complex y;
+    _Fcomplex y;
 
     // run regular dot product
     dotprod_cccf_run(x,h,5,&y);
@@ -38,5 +38,3 @@ int main() {
 
     return 0;
 }
-
-
diff --git a/examples/dsssframesync_example.c b/examples/dsssframesync_example.c
index 1f382b6e..97ea2a18 100644
--- a/examples/dsssframesync_example.c
+++ b/examples/dsssframesync_example.c
@@ -91,8 +91,8 @@ int main(int argc, char * argv[])
 
     // generate the frame in blocks
     unsigned int buf_len  = 256;
-    float complex x[buf_len];
-    float complex y[buf_len];
+    _Fcomplex x[buf_len];
+    _Fcomplex y[buf_len];
 
     int   frame_complete = 0;
     float phi            = 0.0f;
diff --git a/examples/eqlms_cccf_blind_example.c b/examples/eqlms_cccf_blind_example.c
index a80b7d1a..11254298 100644
--- a/examples/eqlms_cccf_blind_example.c
+++ b/examples/eqlms_cccf_blind_example.c
@@ -1,4 +1,4 @@
-// 
+//
 // eqlms_cccf_blind_example.c
 //
 // This example tests the least mean-squares (LMS) equalizer (EQ) on a
@@ -109,15 +109,15 @@ int main(int argc, char*argv[])
     unsigned int num_samples = k*num_symbols;
 
     // bookkeeping variables
-    float complex syms_tx[num_symbols]; // transmitted data symbols
-    float complex x[num_samples];       // interpolated time series
-    float complex y[num_samples];       // channel output
-    float complex z[num_samples];       // equalized output
-    float complex syms_rx[num_symbols]; // received data symbols
+    _Fcomplex syms_tx[num_symbols]; // transmitted data symbols
+    _Fcomplex x[num_samples];       // interpolated time series
+    _Fcomplex y[num_samples];       // channel output
+    _Fcomplex z[num_samples];       // equalized output
+    _Fcomplex syms_rx[num_symbols]; // received data symbols
 
     float hm[hm_len];                   // matched filter response
-    float complex hc[hc_len];           // channel filter coefficients
-    float complex hp[hp_len];           // equalizer filter coefficients
+    _Fcomplex hc[hc_len];           // channel filter coefficients
+    _Fcomplex hp[hp_len];           // equalizer filter coefficients
 
     unsigned int i;
 
@@ -143,7 +143,7 @@ int main(int argc, char*argv[])
     // interpolate
     for (i=0; i<num_symbols; i++)
         firinterp_crcf_execute(interp, syms_tx[i], &x[i*k]);
-    
+
     // push through channel
     float nstd = powf(10.0f, -SNRdB/20.0f);
     for (i=0; i<num_samples; i++) {
@@ -170,7 +170,7 @@ int main(int argc, char*argv[])
     nco_crcf nco = nco_crcf_create(LIQUID_VCO);
     nco_crcf_pll_set_bandwidth(nco, 0.02f);
 
-    float complex d_hat = 0.0f;
+    _Fcomplex d_hat = 0.0f;
     unsigned int num_symbols_rx = 0;
     for (i=0; i<num_samples; i++) {
         // print filtered evm (emperical rms error)
@@ -191,7 +191,7 @@ int main(int argc, char*argv[])
         eqlms_cccf_step_blind(eq, d_hat);
 
         // apply carrier recovery
-        float complex v;
+        _Fcomplex v;
         nco_crcf_mix_down(nco, d_hat, &v);
 
         // save resulting data symbol
@@ -200,7 +200,7 @@ int main(int argc, char*argv[])
 
         // demodulate
         unsigned int sym_out;   // output symbol
-        float complex d_prime;  // estimated input sample
+        _Fcomplex d_prime;  // estimated input sample
         modem_demodulate(demod, v, &sym_out);
         modem_get_demodulator_sample(demod, &d_prime);
         float phase_error = modem_get_demodulator_phase_error(demod);
@@ -227,7 +227,7 @@ int main(int argc, char*argv[])
     modem_destroy(mod);
     modem_destroy(demod);
 
-    // 
+    //
     // export output
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -309,7 +309,7 @@ int main(int argc, char*argv[])
     fprintf(fid,"legend('transmit','channel','equalizer','composite','half-power points','location','northeast');\n");
     fprintf(fid,"axis([-0.5 0.5 -12 8]);\n");
     fprintf(fid,"grid on;\n");
-    
+
     fclose(fid);
     printf("results written to '%s'\n", OUTPUT_FILENAME);
 
diff --git a/examples/eqlms_cccf_block_example.c b/examples/eqlms_cccf_block_example.c
index d1963094..58b5d55c 100644
--- a/examples/eqlms_cccf_block_example.c
+++ b/examples/eqlms_cccf_block_example.c
@@ -1,4 +1,4 @@
-// 
+//
 // eqlms_cccf_block_example.c
 //
 // This example tests the least mean-squares (LMS) equalizer (EQ) on a
@@ -89,11 +89,11 @@ int main(int argc, char*argv[])
 
     // derived/fixed values
     unsigned int    buf_len = 37;
-    float complex   buf_input  [buf_len];
-    float complex   buf_channel[buf_len];
-    float complex   buf_output [buf_len];
+    _Fcomplex   buf_input  [buf_len];
+    _Fcomplex   buf_channel[buf_len];
+    _Fcomplex   buf_output [buf_len];
 
-    // 
+    //
     // generate input sequence using symbol stream generator
     //
     symstreamcf gen = symstreamcf_create_linear(LIQUID_FIRFILT_ARKAISER,k,m,beta,ms);
@@ -101,7 +101,7 @@ int main(int argc, char*argv[])
     //
     // create multi-path channel filter
     //
-    float complex hc[hc_len];
+    _Fcomplex hc[hc_len];
     for (i=0; i<hc_len; i++)
         hc[i] = (i==0) ? 0.5f : (randnf() + _Complex_I*randnf())*0.2f;
     firfilt_cccf channel = firfilt_cccf_create(hc, hc_len);
@@ -131,7 +131,7 @@ int main(int argc, char*argv[])
 
         // run equalizer
         eqlms_cccf_execute_block(eq, k, buf_channel, buf_len, buf_output);
-        
+
         // save results to output file
         for (i=0; i<buf_len; i++) {
             fprintf(fid,"x(end+1) = %12.4e + %12.4ei;\n", crealf(buf_input  [i]), cimagf(buf_input  [i]));
diff --git a/examples/eqlms_cccf_decisiondirected_example.c b/examples/eqlms_cccf_decisiondirected_example.c
index 27150b3c..f9c16472 100644
--- a/examples/eqlms_cccf_decisiondirected_example.c
+++ b/examples/eqlms_cccf_decisiondirected_example.c
@@ -1,4 +1,4 @@
-// 
+//
 // eqlms_cccf_decisiondirected_example.c
 //
 // Tests least mean-squares (LMS) equalizer (EQ) on a signal with a known
@@ -105,14 +105,14 @@ int main(int argc, char*argv[])
     unsigned int num_samples = k*num_symbols;
 
     // bookkeeping variables
-    float complex sym_tx[num_symbols];  // transmitted data sequence
-    float complex x[num_samples];       // interpolated time series
-    float complex y[num_samples];       // channel output
-    float complex z[num_samples];       // equalized output
+    _Fcomplex sym_tx[num_symbols];  // transmitted data sequence
+    _Fcomplex x[num_samples];       // interpolated time series
+    _Fcomplex y[num_samples];       // channel output
+    _Fcomplex z[num_samples];       // equalized output
 
     float hm[hm_len];                   // matched filter response
-    float complex hc[hc_len];           // channel filter coefficients
-    float complex hp[hp_len];           // equalizer filter coefficients
+    _Fcomplex hc[hc_len];           // channel filter coefficients
+    _Fcomplex hp[hp_len];           // equalizer filter coefficients
 
     unsigned int i;
 
@@ -138,7 +138,7 @@ int main(int argc, char*argv[])
     // interpolate
     for (i=0; i<num_symbols; i++)
         firinterp_crcf_execute(interp, sym_tx[i], &x[i*k]);
-    
+
     // push through channel
     float nstd = powf(10.0f, -SNRdB/20.0f);
     for (i=0; i<num_samples; i++) {
@@ -160,7 +160,7 @@ int main(int argc, char*argv[])
     // filtered error vector magnitude (emperical RMS error)
     float evm_hat = 0.03f;
 
-    float complex d_hat = 0.0f;
+    _Fcomplex d_hat = 0.0f;
     for (i=0; i<num_samples; i++) {
         // print filtered evm (emperical rms error)
         if ( ((i+1)%50)==0 )
@@ -177,7 +177,7 @@ int main(int argc, char*argv[])
 
         // estimate transmitted signal
         unsigned int sym_out;   // output symbol
-        float complex d_prime;  // estimated input sample
+        _Fcomplex d_prime;  // estimated input sample
         modem_demodulate(demod, d_hat, &sym_out);
         modem_get_demodulator_sample(demod, &d_prime);
 
@@ -199,7 +199,7 @@ int main(int argc, char*argv[])
     modem_destroy(mod);
     modem_destroy(demod);
 
-    // 
+    //
     // export output
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -277,7 +277,7 @@ int main(int argc, char*argv[])
     fprintf(fid,"legend('transmit','channel','equalizer','composite','half-power points',1);\n");
     fprintf(fid,"axis([-0.5 0.5 -12 8]);\n");
     fprintf(fid,"grid on;\n");
-    
+
     fclose(fid);
     printf("results written to '%s'\n", OUTPUT_FILENAME);
 
diff --git a/examples/eqlms_cccf_example.c b/examples/eqlms_cccf_example.c
index bfed1576..98f89037 100644
--- a/examples/eqlms_cccf_example.c
+++ b/examples/eqlms_cccf_example.c
@@ -1,4 +1,4 @@
-// 
+//
 // eqlms_cccf_example.c
 //
 // Tests least mean-squares (LMS) equalizer (EQ) on a QPSK
@@ -20,11 +20,11 @@ int main() {
     unsigned int p=12;      // equalizer order
 
     // bookkeeping variables
-    float complex d[n];     // data sequence
-    float complex y[n];     // received data sequence (filtered by channel)
-    float complex d_hat[n]; // recovered data sequence
-    float complex h[h_len]; // channel filter coefficients
-    float complex w[p];     // equalizer filter coefficients
+    _Fcomplex d[n];     // data sequence
+    _Fcomplex y[n];     // received data sequence (filtered by channel)
+    _Fcomplex d_hat[n]; // recovered data sequence
+    _Fcomplex h[h_len]; // channel filter coefficients
+    _Fcomplex w[p];     // equalizer filter coefficients
     unsigned int i;
 
     // create equalizer (default initial coefficients)
@@ -73,7 +73,7 @@ int main() {
         printf("  w(%3u) = %12.8f + j*%12.8f\n", i, crealf(w[i]), cimagf(w[i]));
 
     // compute MSE
-    float complex e;
+    _Fcomplex e;
     float mse=0.0f;
     for (i=0; i<n; i++) {
         // compute mse
@@ -89,7 +89,7 @@ int main() {
     firfilt_cccf_destroy(feq);
 
 
-    // 
+    //
     // export data to file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/eqrls_cccf_example.c b/examples/eqrls_cccf_example.c
index 721eb9c3..eb38f9db 100644
--- a/examples/eqrls_cccf_example.c
+++ b/examples/eqrls_cccf_example.c
@@ -1,4 +1,4 @@
-// 
+//
 // eqrls_cccf_example.c
 //
 // Tests recursive least-squares (RLS) equalizer (EQ) on a QPSK
@@ -20,11 +20,11 @@ int main() {
     unsigned int p=12;      // equalizer order
 
     // bookkeeping variables
-    float complex d[n];     // data sequence
-    float complex y[n];     // received data sequence (filtered by channel)
-    float complex d_hat[n]; // recovered data sequence
-    float complex h[h_len]; // channel filter coefficients
-    float complex w[p];     // equalizer filter coefficients
+    _Fcomplex d[n];     // data sequence
+    _Fcomplex y[n];     // received data sequence (filtered by channel)
+    _Fcomplex d_hat[n]; // recovered data sequence
+    _Fcomplex h[h_len]; // channel filter coefficients
+    _Fcomplex w[p];     // equalizer filter coefficients
     unsigned int i;
 
     // create equalizer (default initial coefficients)
@@ -73,7 +73,7 @@ int main() {
         printf("  w(%3u) = %12.8f + j*%12.8f\n", i, crealf(w[i]), cimagf(w[i]));
 
     // compute MSE
-    float complex e;
+    _Fcomplex e;
     float mse=0.0f;
     for (i=0; i<n; i++) {
         // compute mse
@@ -89,7 +89,7 @@ int main() {
     firfilt_cccf_destroy(feq);
 
 
-    // 
+    //
     // export data to file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/fading_generator_example.c b/examples/fading_generator_example.c
index 03e77a5c..1c624ed5 100644
--- a/examples/fading_generator_example.c
+++ b/examples/fading_generator_example.c
@@ -35,7 +35,7 @@ int main() {
         fprintf(fid,"h(%3u) = %12.8e;\n", i+1, h[i]);
 
     // generate complex fading envelope
-    float complex x, y;
+    _Fcomplex x, y;
     float yi, yq;
     float s = sqrtf((omega*K)/(K+1));
     float sig = sqrtf(0.5f*omega/(K+1));
@@ -100,4 +100,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/fft_example.c b/examples/fft_example.c
index 70d0dd19..b5a03f0c 100644
--- a/examples/fft_example.c
+++ b/examples/fft_example.c
@@ -42,9 +42,9 @@ int main(int argc, char*argv[])
     }
 
     // allocate memory arrays
-    float complex * x = (float complex*) malloc(nfft*sizeof(float complex));
-    float complex * y = (float complex*) malloc(nfft*sizeof(float complex));
-    float complex * z = (float complex*) malloc(nfft*sizeof(float complex));
+    _Fcomplex * x = (_Fcomplex*) malloc(nfft*sizeof(_Fcomplex));
+    _Fcomplex * y = (_Fcomplex*) malloc(nfft*sizeof(_Fcomplex));
+    _Fcomplex * z = (_Fcomplex*) malloc(nfft*sizeof(_Fcomplex));
 
     // initialize input
     unsigned int i;
@@ -87,7 +87,7 @@ int main(int argc, char*argv[])
     // compute RMSE between original and result
     float rmse = 0.0f;
     for (i=0; i<nfft; i++) {
-        float complex d = x[i] - z[i];
+        _Fcomplex d = x[i] - z[i];
         rmse += crealf(d * conjf(d));
     }
     rmse = sqrtf( rmse / (float)nfft );
@@ -101,4 +101,3 @@ int main(int argc, char*argv[])
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/fftfilt_crcf_example.c b/examples/fftfilt_crcf_example.c
index 57f5b128..068d3665 100644
--- a/examples/fftfilt_crcf_example.c
+++ b/examples/fftfilt_crcf_example.c
@@ -2,7 +2,7 @@
 // fftfilt_crcf_example.c
 //
 // Complex FFT-based finite impulse response filter example. This example
-// demonstrates the functionality of firfilt by designing a low-order 
+// demonstrates the functionality of firfilt by designing a low-order
 // prototype and using it to filter a noisy signal.  The filter coefficients
 // are  real, but the input and output arrays are complex. The filter order
 // and cutoff frequency are specified at the beginning, and the result is
@@ -45,9 +45,9 @@ int main() {
     unsigned int i;
 
     // allocate memory for data arrays
-    float complex x[num_samples];   // input
-    float complex y0[num_samples];  // output (fftfilt)
-    float complex y1[num_samples];  // output (firfilt)
+    _Fcomplex x[num_samples];   // input
+    _Fcomplex y0[num_samples];  // output (fftfilt)
+    _Fcomplex y1[num_samples];  // output (firfilt)
 
     // generate input signal (noise)
     for (i=0; i<num_samples; i++)
@@ -75,7 +75,7 @@ int main() {
             "re{fir}", "re{fft}", "re{err}",
             "im{fir}", "im{fft}", "im{err}");
     for (i=0; i<num_samples; i++) {
-        float complex e = y0[i] - y1[i];
+        _Fcomplex e = y0[i] - y1[i];
         printf("  %6u : %8.5f : %8.5f (%8.5f), %8.5f : %8.5f (%8.5f)\n",
                 i,
                 crealf(y0[i]), crealf(y1[i]), crealf(e),
@@ -88,7 +88,7 @@ int main() {
     rmse = sqrtf( rmse/(float)num_samples );
     printf("  rmse : %12.4e\n", rmse);
 
-    // 
+    //
     // plot results to output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -132,4 +132,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/firdecim_crcf_example.c b/examples/firdecim_crcf_example.c
index b690de82..e1d07129 100644
--- a/examples/firdecim_crcf_example.c
+++ b/examples/firdecim_crcf_example.c
@@ -65,8 +65,8 @@ int main(int argc, char*argv[]) {
     }
 
     // data arrays
-    float complex x[M*num_samples]; // number of samples before decimation
-    float complex y[  num_samples]; // number of samples after decimation
+    _Fcomplex x[M*num_samples]; // number of samples before decimation
+    _Fcomplex y[  num_samples]; // number of samples after decimation
 
     // initialize input array
     unsigned int i;
@@ -89,7 +89,7 @@ int main(int argc, char*argv[]) {
     // destroy decimator object
     firdecim_crcf_destroy(decim);
 
-    // 
+    //
     // export results to file
     //
     FILE*fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/firfilt_cccf_example.c b/examples/firfilt_cccf_example.c
index a1d39993..a9dbc955 100644
--- a/examples/firfilt_cccf_example.c
+++ b/examples/firfilt_cccf_example.c
@@ -41,16 +41,16 @@ int main(int argc, char*argv[]) {
             exit(-1);
         }
     }
-    
+
     unsigned int i;
 
     // derived values
     unsigned int num_samples = 3*sequence_len;
 
     // data arrays
-    float complex sequence[sequence_len];   // sequence
-    float complex x[num_samples];           // input sequence
-    float complex rxy[num_samples];         // correlator output
+    _Fcomplex sequence[sequence_len];   // sequence
+    _Fcomplex x[num_samples];           // input sequence
+    _Fcomplex rxy[num_samples];         // correlator output
 
     // generate random sequence
     for (i=0; i<sequence_len; i++) {
@@ -75,7 +75,7 @@ int main(int argc, char*argv[]) {
     float nstd = powf(10.0f, -SNRdB/20.0f);
     for (i=0; i<num_samples; i++)
         cawgn(&x[i],nstd);
-        
+
     // compute cross-correlation
     for (i=0; i<num_samples; i++) {
         firfilt_cccf_push(q,x[i]);
@@ -83,7 +83,7 @@ int main(int argc, char*argv[]) {
     }
 
     // find peak
-    float complex rxy_peak = 0;
+    _Fcomplex rxy_peak = 0;
     for (i=0; i<num_samples; i++) {
         if (i==0 || cabsf(rxy[i]) > cabsf(rxy_peak))
             rxy_peak = rxy[i];
@@ -94,7 +94,7 @@ int main(int argc, char*argv[]) {
     // destroy allocated objects
     firfilt_cccf_destroy(q);
 
-    // 
+    //
     // write results to file
     //
     FILE* fid = fopen(OUTPUT_FILENAME, "w");
diff --git a/examples/firfilt_cccf_notch_example.c b/examples/firfilt_cccf_notch_example.c
index 6c7fc2cd..f2183e25 100644
--- a/examples/firfilt_cccf_notch_example.c
+++ b/examples/firfilt_cccf_notch_example.c
@@ -25,8 +25,8 @@ int main() {
     firfilt_cccf_print(q);
 
     // allocate memory for data arrays
-    float complex x[num_samples];   // original input
-    float complex y[num_samples];   // filtered signal
+    _Fcomplex x[num_samples];   // original input
+    _Fcomplex y[num_samples];   // filtered signal
 
     // generate input signal
     unsigned int i;
@@ -41,7 +41,7 @@ int main() {
     // destroy filter object
     firfilt_cccf_destroy(q);
 
-    // 
+    //
     // plot results to output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -98,4 +98,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/firfilt_crcf_dcblocker_example.c b/examples/firfilt_crcf_dcblocker_example.c
index c7ea332f..9a126cb5 100644
--- a/examples/firfilt_crcf_dcblocker_example.c
+++ b/examples/firfilt_crcf_dcblocker_example.c
@@ -24,9 +24,9 @@ int main() {
     firfilt_crcf_print(q);
 
     // allocate memory for data arrays
-    float complex x[num_samples];   // original input
-    float complex y[num_samples];   // input with DC offset
-    float complex z[num_samples];   // DC-blocked result
+    _Fcomplex x[num_samples];   // original input
+    _Fcomplex y[num_samples];   // input with DC offset
+    _Fcomplex z[num_samples];   // DC-blocked result
 
     // generate signals
     unsigned int i;
@@ -45,7 +45,7 @@ int main() {
     // destroy filter object
     firfilt_crcf_destroy(q);
 
-    // 
+    //
     // plot results to output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -99,4 +99,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/firfilt_crcf_example.c b/examples/firfilt_crcf_example.c
index 5e615f76..b60d973e 100644
--- a/examples/firfilt_crcf_example.c
+++ b/examples/firfilt_crcf_example.c
@@ -1,10 +1,10 @@
 //
 // firfilt_crcf_example.c
 //
-// Complex finite impulse response filter example. Demonstrates the 
-// functionality of firfilt by designing a low-order prototype and using it 
-// to filter a noisy signal.  The filter coefficients are real, but the 
-// input and output arrays are complex. The filter order and cutoff 
+// Complex finite impulse response filter example. Demonstrates the
+// functionality of firfilt by designing a low-order prototype and using it
+// to filter a noisy signal.  The filter coefficients are real, but the
+// input and output arrays are complex. The filter order and cutoff
 // frequency are specified at the beginning.
 //
 
@@ -31,8 +31,8 @@ int main() {
     unsigned int i;
 
     // allocate memory for data arrays
-    float complex x[n];
-    float complex y[n];
+    _Fcomplex x[n];
+    _Fcomplex y[n];
 
     // generate input signal (sine wave with decaying amplitude)
     unsigned int wlen = (unsigned int)roundf(0.75*n);
@@ -51,7 +51,7 @@ int main() {
 
     // compute response
     unsigned int nfft = 1024;
-    float complex H[nfft];
+    _Fcomplex H[nfft];
     for (i=0; i<nfft; i++) {
         float freq = ((float)i - 0.5f*(float)nfft) / (float)nfft;
         firfilt_crcf_freqresponse(q, freq, &H[i]);
@@ -60,7 +60,7 @@ int main() {
     // destroy filter object
     firfilt_crcf_destroy(q);
 
-    // 
+    //
     // plot results to output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -123,4 +123,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/firhilb_decim_example.c b/examples/firhilb_decim_example.c
index f70e72e8..e28a310f 100644
--- a/examples/firhilb_decim_example.c
+++ b/examples/firhilb_decim_example.c
@@ -27,7 +27,7 @@ int main() {
 
     // data arrays
     float x[2*num_samples];         // real input
-    float complex y[num_samples];   // complex output
+    _Fcomplex y[num_samples];   // complex output
 
     // initialize input array
     unsigned int i;
@@ -46,7 +46,7 @@ int main() {
     printf("firhilb decimated %u real samples to %u complex samples\n",
             2*num_samples, num_samples);
 
-    // 
+    //
     // export results to file
     //
     FILE*fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/firhilb_example.c b/examples/firhilb_example.c
index 42881698..c1226a88 100644
--- a/examples/firhilb_example.c
+++ b/examples/firhilb_example.c
@@ -33,9 +33,9 @@ int main() {
     firhilbf_print(qi);
 
     // data arrays
-    float complex x[  num_total_samples];   // complex input
+    _Fcomplex x[  num_total_samples];   // complex input
     float         y[2*num_total_samples];   // real output
-    float complex z[  num_total_samples];   // complex output
+    _Fcomplex z[  num_total_samples];   // complex output
 
     // initialize input array
     unsigned int i;
@@ -47,7 +47,7 @@ int main() {
 
     // execute interpolator (complex to real conversion)
     firhilbf_interp_execute_block(qi, x, num_total_samples, y);
-    
+
     // execute decimator (real to complex conversion)
     firhilbf_decim_execute_block(qd, y, num_total_samples, z);
 
@@ -55,7 +55,7 @@ int main() {
     firhilbf_destroy(qi);
     firhilbf_destroy(qd);
 
-    // 
+    //
     // export results to file
     //
     FILE*fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/firhilb_filter_example.c b/examples/firhilb_filter_example.c
index ae809ef6..d4dfb890 100644
--- a/examples/firhilb_filter_example.c
+++ b/examples/firhilb_filter_example.c
@@ -33,9 +33,9 @@ int main() {
     firhilbf_print(q0);
 
     // data arrays
-    float complex x[num_samples];     // complex input
+    _Fcomplex x[num_samples];     // complex input
     float         y[num_samples];     // real output
-    float complex z[num_samples];     // complex output
+    _Fcomplex z[num_samples];     // complex output
 
     // run transform
     unsigned int i;
@@ -59,7 +59,7 @@ int main() {
     firhilbf_destroy(q0);
     firhilbf_destroy(q1);
 
-    // 
+    //
     // export results to file
     //
     FILE*fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/firhilb_interp_example.c b/examples/firhilb_interp_example.c
index 207f2ec4..ad5d5dfe 100644
--- a/examples/firhilb_interp_example.c
+++ b/examples/firhilb_interp_example.c
@@ -25,7 +25,7 @@ int main() {
     unsigned int num_samples=128;   // number of samples
 
     // data arrays
-    float complex x[num_samples];   // complex input
+    _Fcomplex x[num_samples];   // complex input
     float y[2*num_samples];         // real output
 
     // initialize input array
@@ -45,7 +45,7 @@ int main() {
     printf("firhilb interpolated %u complex samples to %u real samples\n",
             num_samples, 2*num_samples);
 
-    // 
+    //
     // export results to file
     //
     FILE*fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/firinterp_crcf_example.c b/examples/firinterp_crcf_example.c
index 62d46b3c..ed96e268 100644
--- a/examples/firinterp_crcf_example.c
+++ b/examples/firinterp_crcf_example.c
@@ -69,8 +69,8 @@ int main(int argc, char*argv[]) {
     firinterp_crcf q = firinterp_crcf_create_kaiser(k,m,As);
 
     // generate input signal and interpolate
-    float complex x[num_syms_total];   // input symbols
-    float complex y[num_samples];   // output samples
+    _Fcomplex x[num_syms_total];   // input symbols
+    _Fcomplex y[num_samples];   // output samples
     unsigned int i;
     for (i=0; i<num_syms; i++) {
         x[i] = (rand() % 2 ? 1.0f : -1.0f) +
@@ -102,7 +102,7 @@ int main(int argc, char*argv[]) {
             printf("\n");
     }
 
-    // 
+    //
     // export output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/firinterp_firdecim_crcf_example.c b/examples/firinterp_firdecim_crcf_example.c
index 23f8618c..86d23153 100644
--- a/examples/firinterp_firdecim_crcf_example.c
+++ b/examples/firinterp_firdecim_crcf_example.c
@@ -86,13 +86,13 @@ int main(int argc, char*argv[]) {
     firdecim_crcf_set_scale(decim, 1.0f/(float)k);
 
     // allocate memory for buffers
-    float complex x[num_syms_total];   // input symbols
-    float complex y[num_samples];   // interpolated sequence
-    float complex z[num_syms_total];   // decimated (received) symbols
+    _Fcomplex x[num_syms_total];   // input symbols
+    _Fcomplex y[num_samples];   // interpolated sequence
+    _Fcomplex z[num_syms_total];   // decimated (received) symbols
 
     // generate input symbols, padded with zeros at the end
     for (i=0; i<num_syms_total; i++) {
-        float complex s = (rand() % 2 ? 1.0f : -1.0f) +
+        _Fcomplex s = (rand() % 2 ? 1.0f : -1.0f) +
                           (rand() % 2 ? 1.0f : -1.0f) * _Complex_I;
         x[i] = i < num_syms ? s : 0;
     }
diff --git a/examples/firpfbch2_crcf_example.c b/examples/firpfbch2_crcf_example.c
index 8fcbf701..2946e9d4 100644
--- a/examples/firpfbch2_crcf_example.c
+++ b/examples/firpfbch2_crcf_example.c
@@ -34,7 +34,7 @@ int main(int argc, char*argv[])
     unsigned int m = 4;             // filter semi-length (symbols)
     unsigned int num_symbols=20;    // number of symbols
     float As = 80.0f;               // filter stop-band attenuation
-    
+
     int dopt;
     while ((dopt = getopt(argc,argv,"hM:m:s:n:")) != EOF) {
         switch (dopt) {
@@ -66,8 +66,8 @@ int main(int argc, char*argv[])
     unsigned int num_samples = num_channels * num_symbols;
 
     // allocate arrays
-    float complex x[num_samples];
-    float complex y[num_samples];
+    _Fcomplex x[num_samples];
+    _Fcomplex y[num_samples];
 
     // generate input signal
     for (i=0; i<num_samples; i++) {
@@ -82,7 +82,7 @@ int main(int argc, char*argv[])
     firpfbch2_crcf_print(qs);
 
     // run channelizer
-    float complex Y[num_channels];
+    _Fcomplex Y[num_channels];
     for (i=0; i<num_samples; i+=num_channels/2) {
         // run analysis filterbank
         firpfbch2_crcf_execute(qa, &x[i], Y);
@@ -103,7 +103,7 @@ int main(int argc, char*argv[])
     float rmse = 0.0f;
     unsigned int delay = 2*num_channels*m - num_channels/2 + 1;
     for (i=0; i<num_samples; i++) {
-        float complex err = y[i] - (i < delay ? 0.0f : x[i-delay]);
+        _Fcomplex err = y[i] - (i < delay ? 0.0f : x[i-delay]);
         rmse += crealf( err*conjf(err) );
     }
     rmse = sqrtf( rmse/(float)num_samples );
@@ -132,7 +132,7 @@ int main(int argc, char*argv[])
 
     // save error vector
     for (i=delay; i<num_samples; i++) {
-        float complex e = y[i] - x[i-delay];
+        _Fcomplex e = y[i] - x[i-delay];
         fprintf(fid,"e(%4u) = %12.4e + j*%12.4e;\n", i+1, crealf(e), cimag(e));
     }
 
diff --git a/examples/firpfbch_crcf_analysis_example.c b/examples/firpfbch_crcf_analysis_example.c
index 2a622c81..c52b2017 100644
--- a/examples/firpfbch_crcf_analysis_example.c
+++ b/examples/firpfbch_crcf_analysis_example.c
@@ -30,8 +30,8 @@ int main() {
     unsigned int num_samples = num_frames * num_channels;
 
     // data arrays
-    float complex x[num_samples];  // time-domain input  [size: num_samples  x 1         ]
-    float complex y[num_samples];  // channelized output [size: num_channels x num_frames]
+    _Fcomplex x[num_samples];  // time-domain input  [size: num_samples  x 1         ]
+    _Fcomplex y[num_samples];  // channelized output [size: num_channels x num_frames]
 
     // initialize input with zeros
     for (i=0; i<num_samples; i++)
@@ -73,8 +73,8 @@ int main() {
 
     // destroy channelizer object
     firpfbch_crcf_destroy(q);
-    
-    // 
+
+    //
     // export results to file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -102,7 +102,7 @@ int main() {
     // save channelized output signals
     for (i=0; i<num_frames; i++) {
         for (k=0; k<num_channels; k++) {
-            float complex v = y[i*num_channels + k];
+            _Fcomplex v = y[i*num_channels + k];
             fprintf(fid,"  y(%3u,%6u) = %12.4e + 1i*%12.4e;\n", k+1, i+1, crealf(v), cimagf(v));
         }
     }
@@ -145,4 +145,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/firpfbch_crcf_example.c b/examples/firpfbch_crcf_example.c
index 3f4f065b..f0017025 100644
--- a/examples/firpfbch_crcf_example.c
+++ b/examples/firpfbch_crcf_example.c
@@ -51,28 +51,28 @@ int main() {
     firpfbch_crcf qs = firpfbch_crcf_create(LIQUID_SYNTHESIZER, num_channels, p, h);
     firpfbch_crcf qa = firpfbch_crcf_create(LIQUID_ANALYZER,    num_channels, p, g);
 
-    float complex x[num_samples];                   // random input (noise)
-    float complex Y0[num_symbols][num_channels];    // channelized output (filterbank)
-    float complex Y1[num_symbols][num_channels];    // channelized output
-    float complex z0[num_samples];                  // time-domain output (filterbank)
-    float complex z1[num_samples];                  // time-domain output
+    _Fcomplex x[num_samples];                   // random input (noise)
+    _Fcomplex Y0[num_symbols][num_channels];    // channelized output (filterbank)
+    _Fcomplex Y1[num_symbols][num_channels];    // channelized output
+    _Fcomplex z0[num_samples];                  // time-domain output (filterbank)
+    _Fcomplex z1[num_samples];                  // time-domain output
 
     // generate input sequence (complex noise)
     for (i=0; i<num_samples; i++)
         x[i] = randnf() * cexpf(_Complex_I*randf()*2*M_PI);
 
-    // 
+    //
     // ANALYZERS
     //
-    
-    // 
+
+    //
     // run analysis filter bank
     //
     for (i=0; i<num_symbols; i++)
         firpfbch_crcf_analyzer_execute(qa, &x[i*num_channels], &Y0[i][0]);
 
 
-    // 
+    //
     // run traditional down-converter (inefficient)
     //
     float dphi; // carrier frequency
@@ -104,17 +104,17 @@ int main() {
     }
 
 
-    // 
+    //
     // SYNTHESIZERS
     //
 
-    // 
+    //
     // run synthesis filter bank
     //
     for (i=0; i<num_symbols; i++)
         firpfbch_crcf_synthesizer_execute(qs, &Y0[i][0], &z0[i*num_channels]);
 
-    // 
+    //
     // run traditional up-converter (inefficient)
     //
 
@@ -122,7 +122,7 @@ int main() {
     for (i=0; i<num_samples; i++)
         z1[i] = 0.0f;
 
-    float complex y_hat;
+    _Fcomplex y_hat;
     for (i=0; i<num_channels; i++) {
         // reset filter
         firfilt_crcf_reset(fs);
@@ -162,7 +162,7 @@ int main() {
     // RESULTS
     //
 
-    // 
+    //
     // analyzers
     //
 
@@ -190,7 +190,7 @@ int main() {
 
 
     float mse_analyzer[num_channels];
-    float complex d;
+    _Fcomplex d;
     for (i=0; i<num_channels; i++) {
         mse_analyzer[i] = 0.0f;
         for (j=0; j<num_symbols; j++) {
@@ -207,7 +207,7 @@ int main() {
     printf("\n");
 
 
-    // 
+    //
     // synthesizers
     //
 
diff --git a/examples/firpfbch_crcf_synthesis_example.c b/examples/firpfbch_crcf_synthesis_example.c
index 529916c1..79982e8c 100644
--- a/examples/firpfbch_crcf_synthesis_example.c
+++ b/examples/firpfbch_crcf_synthesis_example.c
@@ -30,8 +30,8 @@ int main() {
     unsigned int num_samples = num_frames * num_channels;
 
     // data arrays
-    float complex x[num_channels][num_frames];  // channelized input
-    float complex y[num_samples];               // time-domain output [size: num_samples  x 1]
+    _Fcomplex x[num_channels][num_frames];  // channelized input
+    _Fcomplex y[num_samples];               // time-domain output [size: num_samples  x 1]
 
     // create narrow-band pulse
     unsigned int pulse_len = 17;        // pulse length [samples]
@@ -70,7 +70,7 @@ int main() {
 #endif
 
     // channelize input data
-    float complex v[num_channels];
+    _Fcomplex v[num_channels];
     for (i=0; i<num_frames; i++) {
         // assemble input vector
         for (k=0; k<num_channels; k++)
@@ -82,8 +82,8 @@ int main() {
 
     // destroy channelizer object
     firpfbch_crcf_destroy(q);
-    
-    // 
+
+    //
     // export results to file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -107,7 +107,7 @@ int main() {
     // save channelized input signals
     for (i=0; i<num_frames; i++) {
         for (k=0; k<num_channels; k++) {
-            float complex v = x[k][i];
+            _Fcomplex v = x[k][i];
             fprintf(fid,"  x(%3u,%6u) = %12.4e + 1i*%12.4e;\n", k+1, i+1, crealf(v), cimagf(v));
         }
     }
@@ -154,4 +154,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/firpfbchr_crcf_example.c b/examples/firpfbchr_crcf_example.c
index 39603d5d..317fca32 100644
--- a/examples/firpfbchr_crcf_example.c
+++ b/examples/firpfbchr_crcf_example.c
@@ -23,7 +23,7 @@ int main(int argc, char*argv[])
     unsigned int m =  5;            // filter semi-length (symbols)
     unsigned int num_blocks=1<<16;  // number of symbols
     float As = 60.0f;               // filter stop-band attenuation
-    
+
     unsigned int i;
     unsigned int channel_id = 3;
 
@@ -53,8 +53,8 @@ int main(int argc, char*argv[])
     spgramcf     p1   = spgramcf_create_default(nfft);
 
     // run channelizer
-    float complex buf_0[P];
-    float complex buf_1[M];
+    _Fcomplex buf_0[P];
+    _Fcomplex buf_1[M];
     for (i=0; i<num_blocks; i++) {
         // write samples to buffer
         msourcecf_write_samples(gen, buf_0, P);
diff --git a/examples/flexframesync_example.c b/examples/flexframesync_example.c
index bbda1d18..db17bd39 100644
--- a/examples/flexframesync_example.c
+++ b/examples/flexframesync_example.c
@@ -110,8 +110,8 @@ int main(int argc, char *argv[])
 
     // generate the frame in blocks
     unsigned int  buf_len = 256;
-    float complex x[buf_len];
-    float complex y[buf_len];
+    _Fcomplex x[buf_len];
+    _Fcomplex y[buf_len];
 
     int frame_complete = 0;
     float phi = 0.0f;
@@ -170,4 +170,3 @@ static int callback(unsigned char *  _header,
 
     return 0;
 }
-
diff --git a/examples/flexframesync_reconfig_example.c b/examples/flexframesync_reconfig_example.c
index ab397da1..41e60153 100644
--- a/examples/flexframesync_reconfig_example.c
+++ b/examples/flexframesync_reconfig_example.c
@@ -68,7 +68,7 @@ int main(int argc, char *argv[]) {
 
     // frame buffers, properties
     unsigned int  buf_len = 256;
-    float complex buf[buf_len];
+    _Fcomplex buf[buf_len];
 
     unsigned int j;
     for (j=0; j<num_frames; j++) {
@@ -119,4 +119,3 @@ int main(int argc, char *argv[]) {
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/framesync64_example.c b/examples/framesync64_example.c
index 943cf4d8..2a945828 100644
--- a/examples/framesync64_example.c
+++ b/examples/framesync64_example.c
@@ -99,9 +99,9 @@ int main(int argc, char*argv[])
         payload[i] = rand() & 0xff;
 
     // allocate memory for the frame samples
-    float complex frame[frame_len]; // generated frame
-    float complex y[num_samples];   // received sequence
-    
+    _Fcomplex frame[frame_len]; // generated frame
+    _Fcomplex y[num_samples];   // received sequence
+
     // generate the frame
     framegen64_execute(fg, header, payload, frame);
 
@@ -136,8 +136,8 @@ int main(int argc, char*argv[])
     // clean up allocated objects
     framegen64_destroy(fg);
     framesync64_destroy(fs);
-    
-    // 
+
+    //
     // export results
     //
     FILE* fid = fopen(OUTPUT_FILENAME, "w");
@@ -191,4 +191,3 @@ static int callback(unsigned char *  _header,
 
     return 0;
 }
-
diff --git a/examples/freqmodem_example.c b/examples/freqmodem_example.c
index e7d89354..e675a019 100644
--- a/examples/freqmodem_example.c
+++ b/examples/freqmodem_example.c
@@ -49,7 +49,7 @@ int main(int argc, char*argv[])
 
     unsigned int i;
     float         m[num_samples];       // message signal
-    float complex r[num_samples];       // received signal (complex baseband)
+    _Fcomplex r[num_samples];       // received signal (complex baseband)
     float         y[num_samples];       // demodulator output
 
     // generate message signal (sum of sines)
@@ -83,7 +83,7 @@ int main(int argc, char*argv[])
     rmse = sqrtf( rmse / (float)(num_samples-1) );
     printf("rmse = %12.4e\n", rmse);
 
-    // 
+    //
     // write results to output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/fskframesync_example.c b/examples/fskframesync_example.c
index c50c49b9..9b6dd9d6 100644
--- a/examples/fskframesync_example.c
+++ b/examples/fskframesync_example.c
@@ -100,9 +100,9 @@ int main(int argc, char*argv[])
 
     // allocate memory for the frame samples
     unsigned int  buf_len = 64;
-    float complex buf_tx[buf_len];  // receive buffer
-    float complex buf_rx[buf_len];  // transmit buffer
-    
+    _Fcomplex buf_tx[buf_len];  // receive buffer
+    _Fcomplex buf_rx[buf_len];  // transmit buffer
+
     // assemble the frame
     fskframegen_assemble(fg, header, payload, payload_len, check, fec0, fec1);
 
@@ -122,7 +122,7 @@ int main(int argc, char*argv[])
 
         // synchronize/receive the frame
         fskframesync_execute_block(fs, buf_rx, buf_len);
-        
+
         // estimate power spectral density
         spgramcf_write(periodogram, buf_rx, buf_len);
     }
@@ -136,7 +136,7 @@ int main(int argc, char*argv[])
     fskframegen_destroy(fg);
     fskframesync_destroy(fs);
 
-    // 
+    //
     // export results
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -198,4 +198,3 @@ static int callback(unsigned char *  _header,
 
     return 0;
 }
-
diff --git a/examples/fskmodem_example.c b/examples/fskmodem_example.c
index 05693121..d1211976 100644
--- a/examples/fskmodem_example.c
+++ b/examples/fskmodem_example.c
@@ -1,4 +1,4 @@
-// 
+//
 // fskmodem_example.c
 //
 // This example demostrates the M-ary frequency-shift keying
@@ -82,10 +82,10 @@ int main(int argc, char*argv[])
     fskdem dem = fskdem_create(m,k,bandwidth);
     fskdem_print(dem);
 
-    // 
-    float complex buf_tx[k];    // transmit buffer
-    float complex buf_rx[k];    // transmit buffer
-    
+    //
+    _Fcomplex buf_tx[k];    // transmit buffer
+    _Fcomplex buf_rx[k];    // transmit buffer
+
     // spectral periodogram
     spgramcf periodogram = spgramcf_create_default(nfft);
 
@@ -123,10 +123,10 @@ int main(int argc, char*argv[])
     spgramcf_get_psd(periodogram, psd);
     spgramcf_destroy(periodogram);
 
-    // 
+    //
     // export results
     //
-    
+
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
     fprintf(fid,"%% %s : auto-generated file\n", OUTPUT_FILENAME);
     fprintf(fid,"clear all\n");
diff --git a/examples/fskmodem_waterfall_example.c b/examples/fskmodem_waterfall_example.c
index f38e3206..e55bdba5 100644
--- a/examples/fskmodem_waterfall_example.c
+++ b/examples/fskmodem_waterfall_example.c
@@ -1,4 +1,4 @@
-// 
+//
 // fskmodem_waterfall_example.c
 //
 // This example demostrates the M-ary frequency-shift keying
@@ -82,9 +82,9 @@ int main(int argc, char*argv[])
     // create modulator/demodulator pair
     fskmod mod = fskmod_create(m,k,bandwidth);
 
-    float complex buf_tx[k];    // transmit buffer
-    float complex buf_rx[k];    // transmit buffer
-    
+    _Fcomplex buf_tx[k];    // transmit buffer
+    _Fcomplex buf_rx[k];    // transmit buffer
+
     // modulate, demodulate, count errors
     for (i=0; i<num_symbols; i++) {
         // generate random symbol
diff --git a/examples/gmskframesync_example.c b/examples/gmskframesync_example.c
index 3459de66..ed3f5fdc 100644
--- a/examples/gmskframesync_example.c
+++ b/examples/gmskframesync_example.c
@@ -128,10 +128,10 @@ int main(int argc, char*argv[])
     // allocate memory for full frame (with noise)
     unsigned int frame_len = gmskframegen_getframelen(fg);
     unsigned int num_samples = (frame_len * k) + 800;
-    float complex x[num_samples];
-    float complex y[num_samples];
+    _Fcomplex x[num_samples];
+    _Fcomplex y[num_samples];
 
-    // 
+    //
     // generate frame
     //
     unsigned int n=0;
@@ -165,7 +165,7 @@ int main(int argc, char*argv[])
     gmskframesync_destroy(fs);
 
 
-    // 
+    //
     // export output
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -229,4 +229,3 @@ int callback(unsigned char *  _header,
 
     return 0;
 }
-
diff --git a/examples/gmskmodem_example.c b/examples/gmskmodem_example.c
index 362b37d2..52eface3 100644
--- a/examples/gmskmodem_example.c
+++ b/examples/gmskmodem_example.c
@@ -1,4 +1,4 @@
-// 
+//
 // gmskmodem_example.c
 //
 
@@ -70,8 +70,8 @@ int main(int argc, char*argv[]) {
 
     unsigned int i;
     unsigned int s[num_symbols];
-    float complex x[num_samples];
-    float complex y[num_samples];
+    _Fcomplex x[num_samples];
+    _Fcomplex y[num_samples];
     unsigned int sym_out[num_symbols];
 
     // generate random data sequence
diff --git a/examples/iirdecim_crcf_example.c b/examples/iirdecim_crcf_example.c
index 35a4a4f4..31629935 100644
--- a/examples/iirdecim_crcf_example.c
+++ b/examples/iirdecim_crcf_example.c
@@ -62,8 +62,8 @@ int main(int argc, char*argv[]) {
     float delay = iirdecim_crcf_groupdelay(q,0.0f);
 
     // generate input signal and decimate
-    float complex x[num_samples];   // input samples
-    float complex y[num_samples/M]; // output samples
+    _Fcomplex x[num_samples];   // input samples
+    _Fcomplex y[num_samples/M]; // output samples
     unsigned int i;
     unsigned int w_len = num_samples > 4*delay ? num_samples - 4*delay : num_samples;
     for (i=0; i<num_samples; i++) {
@@ -94,7 +94,7 @@ int main(int argc, char*argv[]) {
     }
 #endif
 
-    // 
+    //
     // export output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -131,7 +131,7 @@ int main(int argc, char*argv[]) {
     fprintf(fid,"    xlabel('time');\n");
     fprintf(fid,"    ylabel('imag');\n");
     fprintf(fid,"    grid on;\n");
-    
+
     // plot spectral response
     fprintf(fid,"nfft = 2048;\n");
     fprintf(fid,"X  = 20*log10(abs(fftshift(fft(x/length(x),nfft))));\n");
diff --git a/examples/iirdes_analog_example.c b/examples/iirdes_analog_example.c
index efab30e3..18c84c7c 100644
--- a/examples/iirdes_analog_example.c
+++ b/examples/iirdes_analog_example.c
@@ -105,12 +105,12 @@ int main(int argc, char*argv[]) {
     unsigned int nza = 0;
 
     // complex analog zeros, poles, gain
-    float complex za[order];
-    float complex pa[order];
-    float complex ka;
+    _Fcomplex za[order];
+    _Fcomplex pa[order];
+    _Fcomplex ka;
 
     unsigned int i;
-    
+
     unsigned int r = order % 2;
     unsigned int L = (order-r)/2;
 
@@ -261,4 +261,3 @@ int main(int argc, char*argv[]) {
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/iirdes_pll_example.c b/examples/iirdes_pll_example.c
index 2c8f2f25..c5e24208 100644
--- a/examples/iirdes_pll_example.c
+++ b/examples/iirdes_pll_example.c
@@ -72,8 +72,8 @@ int main(int argc, char*argv[]) {
     }
 
     // data arrays
-    float complex x[n];         // input complex sinusoid
-    float complex y[n];         // output complex sinusoid
+    _Fcomplex x[n];         // input complex sinusoid
+    _Fcomplex y[n];         // output complex sinusoid
     float phase_error[n];       // output phase error
 
     // generate PLL filter
diff --git a/examples/iirfilt_cccf_example.c b/examples/iirfilt_cccf_example.c
index 34aebab5..187d5ffd 100644
--- a/examples/iirfilt_cccf_example.c
+++ b/examples/iirfilt_cccf_example.c
@@ -99,8 +99,8 @@ int main(int argc, char*argv[])
     unsigned int i;
 
     // allocate memory for data arrays
-    float complex x[n];
-    float complex y[n];
+    _Fcomplex x[n];
+    _Fcomplex y[n];
 
     // generate input signal (noisy sine wave with decaying amplitude)
     unsigned int wlen = (3*n)/4;
@@ -115,7 +115,7 @@ int main(int argc, char*argv[])
 
     // compute two-sided frequency response
     unsigned int nfft=512;
-    float complex H[nfft];
+    _Fcomplex H[nfft];
     for (i=0; i<nfft; i++) {
         float freq = (float)i / (float)nfft - 0.5f;
         iirfilt_cccf_freqresponse(q, freq, &H[i]);
@@ -124,7 +124,7 @@ int main(int argc, char*argv[])
     // destroy filter object
     iirfilt_cccf_destroy(q);
 
-    // 
+    //
     // plot results to output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -202,4 +202,3 @@ int main(int argc, char*argv[])
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/iirfilt_crcf_dcblocker_example.c b/examples/iirfilt_crcf_dcblocker_example.c
index d81321f7..69a35387 100644
--- a/examples/iirfilt_crcf_dcblocker_example.c
+++ b/examples/iirfilt_crcf_dcblocker_example.c
@@ -23,9 +23,9 @@ int main() {
     iirfilt_crcf_print(q);
 
     // allocate memory for data arrays
-    float complex x[num_samples];   // original input
-    float complex y[num_samples];   // input with DC offset
-    float complex z[num_samples];   // DC-blocked result
+    _Fcomplex x[num_samples];   // original input
+    _Fcomplex y[num_samples];   // input with DC offset
+    _Fcomplex z[num_samples];   // DC-blocked result
 
     // generate signals
     unsigned int i;
@@ -43,7 +43,7 @@ int main() {
     // destroy filter object
     iirfilt_crcf_destroy(q);
 
-    // 
+    //
     // plot results to output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -97,4 +97,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/iirfilt_crcf_example.c b/examples/iirfilt_crcf_example.c
index 71b22bad..cb62e1bc 100644
--- a/examples/iirfilt_crcf_example.c
+++ b/examples/iirfilt_crcf_example.c
@@ -37,8 +37,8 @@ int main() {
     unsigned int i;
 
     // allocate memory for data arrays
-    float complex x[n];
-    float complex y[n];
+    _Fcomplex x[n];
+    _Fcomplex y[n];
 
     // generate input signal (noisy sine wave with decaying amplitude)
     for (i=0; i<n; i++) {
@@ -51,7 +51,7 @@ int main() {
 
     // compute response
     unsigned int nfft=512;
-    float complex H[nfft];
+    _Fcomplex H[nfft];
     for (i=0; i<nfft; i++) {
         float freq = 0.5f * (float)i / (float)nfft;
         iirfilt_crcf_freqresponse(q, freq, &H[i]);
@@ -60,7 +60,7 @@ int main() {
     // destroy filter object
     iirfilt_crcf_destroy(q);
 
-    // 
+    //
     // plot results to output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -127,4 +127,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/iirhilb_example.c b/examples/iirhilb_example.c
index c2510a1b..4942e5c5 100644
--- a/examples/iirhilb_example.c
+++ b/examples/iirhilb_example.c
@@ -34,9 +34,9 @@ int main() {
     iirhilbf_print(qi);
 
     // data arrays
-    float complex x[  num_total_samples];   // complex input
+    _Fcomplex x[  num_total_samples];   // complex input
     float         y[2*num_total_samples];   // real output
-    float complex z[  num_total_samples];   // complex output
+    _Fcomplex z[  num_total_samples];   // complex output
 
     // initialize input array
     unsigned int i;
@@ -48,7 +48,7 @@ int main() {
 
     // execute interpolator (complex to real conversion)
     iirhilbf_interp_execute_block(qi, x, num_total_samples, y);
-    
+
     // execute decimator (real to complex conversion)
     iirhilbf_decim_execute_block(qd, y, num_total_samples, z);
 
@@ -56,7 +56,7 @@ int main() {
     iirhilbf_destroy(qi);
     iirhilbf_destroy(qd);
 
-    // 
+    //
     // export results to file
     //
     FILE*fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/iirhilb_filter_example.c b/examples/iirhilb_filter_example.c
index 21ddb1f6..0533a971 100644
--- a/examples/iirhilb_filter_example.c
+++ b/examples/iirhilb_filter_example.c
@@ -30,9 +30,9 @@ int main() {
     iirhilbf_print(q0);
 
     // data arrays
-    float complex x[num_samples];     // complex input
+    _Fcomplex x[num_samples];     // complex input
     float         y[num_samples];     // real output
-    float complex z[num_samples];     // complex output
+    _Fcomplex z[num_samples];     // complex output
 
     // run transform
     unsigned int i;
@@ -54,7 +54,7 @@ int main() {
     iirhilbf_destroy(q0);
     iirhilbf_destroy(q1);
 
-    // 
+    //
     // export results to file
     //
     FILE*fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/iirinterp_crcf_example.c b/examples/iirinterp_crcf_example.c
index 75cc3c13..f553d246 100644
--- a/examples/iirinterp_crcf_example.c
+++ b/examples/iirinterp_crcf_example.c
@@ -58,8 +58,8 @@ int main(int argc, char*argv[]) {
     float delay = iirinterp_crcf_groupdelay(q,0.0f);
 
     // generate input signal and interpolate
-    float complex x[  num_samples]; // input samples
-    float complex y[k*num_samples]; // output samples
+    _Fcomplex x[  num_samples]; // input samples
+    _Fcomplex y[k*num_samples]; // output samples
     unsigned int i;
     for (i=0; i<num_samples; i++) {
         // input signal (sinusoidal chirp)
@@ -76,7 +76,7 @@ int main(int argc, char*argv[]) {
     iirinterp_crcf_destroy(q);
 
 
-    // 
+    //
     // export output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/modem_arb_example.c b/examples/modem_arb_example.c
index ae17488f..9e37b18b 100644
--- a/examples/modem_arb_example.c
+++ b/examples/modem_arb_example.c
@@ -55,14 +55,14 @@ int main(int argc, char*argv[])
     unsigned int M = 1<<bps;    // constellation size
 
     // initialize constellation table
-    float complex constellation[M];
+    _Fcomplex constellation[M];
     // initialize constellation (spiral)
     for (i=0; i<M; i++) {
         float r   = (float)i / logf((float)M) + 4.0f;
         float phi = (float)i / logf((float)M);
         constellation[i] = r * cexpf(_Complex_I*phi);
     }
-    
+
     // create mod/demod objects
     modem mod   = modem_create_arbitrary(constellation, M);
     modem demod = modem_create_arbitrary(constellation, M);
@@ -70,7 +70,7 @@ int main(int argc, char*argv[])
     modem_print(mod);
 
     // run simulation
-    float complex x[n];
+    _Fcomplex x[n];
     unsigned int num_errors = 0;
 
     // run simple BER simulation
@@ -97,7 +97,7 @@ int main(int argc, char*argv[])
     modem_destroy(mod);
     modem_destroy(demod);
 
-    // 
+    //
     // export output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/modem_example.c b/examples/modem_example.c
index 0c178780..bb02b385 100644
--- a/examples/modem_example.c
+++ b/examples/modem_example.c
@@ -1,4 +1,4 @@
-// 
+//
 // modem_example.c
 //
 // This example demonstates the digital modulator/demodulator
@@ -74,7 +74,7 @@ int main(int argc, char*argv[])
     unsigned int i; // modulated symbol
     unsigned int s; // demodulated symbol
     unsigned int num_symbols = 1<<bps;
-    float complex x;
+    _Fcomplex x;
     unsigned int num_sym_errors = 0;
     unsigned int num_bit_errors = 0;
 
diff --git a/examples/modem_soft_example.c b/examples/modem_soft_example.c
index b38e0e7b..9aa95c53 100644
--- a/examples/modem_soft_example.c
+++ b/examples/modem_soft_example.c
@@ -1,4 +1,4 @@
-// 
+//
 // modem_soft_example.c
 //
 // This example demonstates soft demodulation of linear
@@ -75,7 +75,7 @@ int main(int argc, char*argv[])
     unsigned char soft_bits[bps];
     unsigned int s_soft;    // demodulated symbol (soft, compacted)
     unsigned int num_symbols = 1<<bps;
-    float complex x;
+    _Fcomplex x;
     unsigned int num_sym_errors = 0;
     unsigned int num_bit_errors = 0;
 
diff --git a/examples/msourcecf_example.c b/examples/msourcecf_example.c
index 986d3d73..8c3cad2f 100644
--- a/examples/msourcecf_example.c
+++ b/examples/msourcecf_example.c
@@ -15,7 +15,7 @@
 
 // user-defined callback; generate tones
 int callback(void *          _userdata,
-             float complex * _v,
+             _Fcomplex * _v,
              unsigned int    _n)
 {
     unsigned int * counter = (unsigned int*)_userdata;
@@ -43,7 +43,7 @@ int main()
     spgramcf periodogram = spgramcf_create_default(nfft);
 
     unsigned int buf_len = 1024;
-    float complex buf[buf_len];
+    _Fcomplex buf[buf_len];
 
     // create multi-signal source generator
     msourcecf gen = msourcecf_create_default();
@@ -67,7 +67,7 @@ int main()
 
         // push resulting sample through periodogram
         spgramcf_write(periodogram, buf, buf_len);
-        
+
         // accumulated samples
         total_samples += buf_len;
     }
@@ -81,7 +81,7 @@ int main()
     msourcecf_destroy(gen);
     spgramcf_destroy(periodogram);
 
-    // 
+    //
     // export output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -108,4 +108,3 @@ int main()
     printf("results written to %s.\n", OUTPUT_FILENAME);
     return 0;
 }
-
diff --git a/examples/msresamp2_crcf_example.c b/examples/msresamp2_crcf_example.c
index ea64b1ec..20f9b49f 100644
--- a/examples/msresamp2_crcf_example.c
+++ b/examples/msresamp2_crcf_example.c
@@ -83,8 +83,8 @@ int main(int argc, char*argv[])
     unsigned int wlen = round(0.75 * nx);
 
     // allocate memory for arrays
-    float complex x[nx];
-    float complex y[ny];
+    _Fcomplex x[nx];
+    _Fcomplex y[ny];
 
     // generate input signal: tone just before the edge of filter band
     float ftone = 0.95 * fc * ((type == LIQUID_RESAMP_DECIM) ? r : 1);
@@ -108,8 +108,8 @@ int main(int argc, char*argv[])
 
     // clean up allocated objects
     msresamp2_crcf_destroy(q);
-    
-    // 
+
+    //
     // analyze resulting signal
     //
 
@@ -120,8 +120,8 @@ int main(int argc, char*argv[])
     // run FFT and ensure that carrier has moved and that image
     // frequencies and distortion have been adequately suppressed
     unsigned int nfft = 4 << liquid_nextpow2(n*M);
-    float complex yfft[nfft];   // fft input
-    float complex Yfft[nfft];   // fft output
+    _Fcomplex yfft[nfft];   // fft input
+    _Fcomplex Yfft[nfft];   // fft output
     for (i=0; i<nfft; i++)
         yfft[i] = i < ny ? y[i] : 0.0f;
     fft_run(nfft, yfft, Yfft, LIQUID_FFT_FORWARD, 0);
@@ -161,7 +161,7 @@ int main(int argc, char*argv[])
     printf("  max sidelobe              :   %12.8f dB (expected at least %.2f dB)\n", max_sidelobe, -As);
 
 
-    // 
+    //
     // export results
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/msresamp_crcf_example.c b/examples/msresamp_crcf_example.c
index 1e47bb96..e7ae9254 100644
--- a/examples/msresamp_crcf_example.c
+++ b/examples/msresamp_crcf_example.c
@@ -72,8 +72,8 @@ int main(int argc, char*argv[])
     unsigned int ny_alloc = (unsigned int) (2*(float)nx * r);  // allocation for output
 
     // allocate memory for arrays
-    float complex x[nx];
-    float complex y[ny_alloc];
+    _Fcomplex x[nx];
+    _Fcomplex y[ny_alloc];
 
     // generate input signal
     float wsum = 0.0f;
@@ -94,9 +94,9 @@ int main(int argc, char*argv[])
 
     // clean up allocated objects
     msresamp_crcf_destroy(q);
-    
-    
-    // 
+
+
+    //
     // analyze resulting signal
     //
 
@@ -107,8 +107,8 @@ int main(int argc, char*argv[])
     // run FFT and ensure that carrier has moved and that image
     // frequencies and distortion have been adequately suppressed
     unsigned int nfft = 1 << liquid_nextpow2(ny);
-    float complex yfft[nfft];   // fft input
-    float complex Yfft[nfft];   // fft output
+    _Fcomplex yfft[nfft];   // fft input
+    _Fcomplex Yfft[nfft];   // fft output
     for (i=0; i<nfft; i++)
         yfft[i] = i < ny ? y[i] : 0.0f;
     fft_run(nfft, yfft, Yfft, LIQUID_FFT_FORWARD, 0);
@@ -148,7 +148,7 @@ int main(int argc, char*argv[])
     printf("  max sidelobe              :   %12.8f dB (expected at least %.2f dB)\n", max_sidelobe, -As);
 
 
-    // 
+    //
     // export results
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/msresamp_crcf_noise_example.c b/examples/msresamp_crcf_noise_example.c
index b5df1cad..162aa3e4 100644
--- a/examples/msresamp_crcf_noise_example.c
+++ b/examples/msresamp_crcf_noise_example.c
@@ -56,8 +56,8 @@ int main(int argc, char*argv[])
 
     // arrays
     unsigned int  buf_len = 1024;
-    float complex buf_x[  buf_len];
-    float complex buf_y[2*buf_len];
+    _Fcomplex buf_x[  buf_len];
+    _Fcomplex buf_y[2*buf_len];
 
     // create multi-signal source generator
     msourcecf gen = msourcecf_create_default();
diff --git a/examples/nco_crcf_mix_example.c b/examples/nco_crcf_mix_example.c
index 61069264..0ba163b9 100644
--- a/examples/nco_crcf_mix_example.c
+++ b/examples/nco_crcf_mix_example.c
@@ -1,4 +1,4 @@
-// 
+//
 // nco_crcf_mix_example.c
 //
 // This example demonstrates how to mix a signal down at complex
@@ -40,7 +40,7 @@ int main()
 
     //
     unsigned int  buf_len = 1024;
-    float complex buf[buf_len];
+    _Fcomplex buf[buf_len];
     unsigned int  total_samples = 0;
     while (total_samples < num_samples) {
         // write samples to buffer
diff --git a/examples/nco_example.c b/examples/nco_example.c
index 3579e163..2ab3ff8e 100644
--- a/examples/nco_example.c
+++ b/examples/nco_example.c
@@ -1,4 +1,4 @@
-// 
+//
 // nco_example.c
 //
 // This example demonstrates the most basic functionality of the
@@ -33,10 +33,10 @@ int main()
 
     unsigned int i;
     for (i=0; i<num_samples; i++) {
-        float complex y;
+        _Fcomplex y;
         nco_crcf_cexpf(q, &y);
         nco_crcf_step(q);
-        
+
         // push resulting sample through periodogram
         spgramcf_push(periodogram, y);
     }
diff --git a/examples/nco_pll_example.c b/examples/nco_pll_example.c
index e347a29f..112f611d 100644
--- a/examples/nco_pll_example.c
+++ b/examples/nco_pll_example.c
@@ -66,8 +66,8 @@ int main(int argc, char*argv[])
     nco_crcf_pll_set_bandwidth(nco_rx, pll_bandwidth);
 
     // generate input
-    float complex x[n];
-    float complex y[n];
+    _Fcomplex x[n];
+    _Fcomplex y[n];
     float phase_error[n];
 
     unsigned int i;
diff --git a/examples/nco_pll_modem_example.c b/examples/nco_pll_modem_example.c
index 61872804..4f746bab 100644
--- a/examples/nco_pll_modem_example.c
+++ b/examples/nco_pll_modem_example.c
@@ -98,7 +98,7 @@ int main(int argc, char*argv[]) {
     // run loop
     unsigned int i, M=1<<bps, sym_in, sym_out, num_errors=0;
     float phase_error;
-    float complex x, r, v, noise;
+    _Fcomplex x, r, v, noise;
     for (i=0; i<n; i++) {
         // generate random symbol
         sym_in = rand() % M;
@@ -114,7 +114,7 @@ int main(int argc, char*argv[]) {
         crandnf(&noise);
         r += noise * noise_power;
 
-        // 
+        //
         //v = nco_crcf_cexpf(nco_rx);
         nco_crcf_mix_down(nco_rx, r, &v);
 
diff --git a/examples/ofdmflexframesync_example.c b/examples/ofdmflexframesync_example.c
index a834929e..40d4dc4b 100644
--- a/examples/ofdmflexframesync_example.c
+++ b/examples/ofdmflexframesync_example.c
@@ -86,7 +86,7 @@ int main(int argc, char*argv[])
 
     // derived values
     unsigned int  buf_len = 256;
-    float complex buf[buf_len]; // time-domain buffer
+    _Fcomplex buf[buf_len]; // time-domain buffer
 
     // allocate memory for header, payload
     unsigned char header[8];
@@ -181,4 +181,3 @@ int callback(unsigned char *  _header,
 
     return 0;
 }
-
diff --git a/examples/ofdmframegen_example.c b/examples/ofdmframegen_example.c
index 7f33db42..1f008c1d 100644
--- a/examples/ofdmframegen_example.c
+++ b/examples/ofdmframegen_example.c
@@ -12,11 +12,11 @@
 
 int main() {
     // options
-    unsigned int num_subcarriers=64;// 
+    unsigned int num_subcarriers=64;//
     unsigned int cp_len=16;         // cyclic prefix length
     //unsigned int num_symbols=2;     // number of ofdm symbols
 
-    // 
+    //
     unsigned int frame_len = num_subcarriers + cp_len;
 
     //unsigned int num_samples = num_subcarriers * num_frames;
@@ -36,8 +36,8 @@ int main() {
     fprintf(fid,"x = zeros(1,frame_len);\n");
 
     unsigned int i;
-    float complex X[num_subcarriers];   // channelized symbols
-    float complex x[frame_len];         // time-domain samples
+    _Fcomplex X[num_subcarriers];   // channelized symbols
+    _Fcomplex x[frame_len];         // time-domain samples
 
     for (i=0; i<num_subcarriers; i++) {
         X[i] = i==4 ? 0.707f + _Complex_I*0.707f : 0.0f;
@@ -68,4 +68,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/ofdmframesync_example.c b/examples/ofdmframesync_example.c
index 5464d617..e01625d8 100644
--- a/examples/ofdmframesync_example.c
+++ b/examples/ofdmframesync_example.c
@@ -33,15 +33,15 @@ void usage()
 //  _p          : subcarrier allocation array [size: _M x 1]
 //  _M          : number of subcarriers
 //  _userdata   : user-defined data pointer
-static int callback(float complex * _X,
+static int callback(_Fcomplex * _X,
                     unsigned char * _p,
                     unsigned int    _M,
                     void *          _userdata);
 
 // custom data type to pass to callback function
 struct rx_symbols {
-    float complex syms_bpsk[2000];  // even subcarrier symbols
-    float complex syms_qpsk[2000];  // odd subcarrier symbols
+    _Fcomplex syms_bpsk[2000];  // even subcarrier symbols
+    _Fcomplex syms_qpsk[2000];  // odd subcarrier symbols
     unsigned int  num_bpsk;         // counter
     unsigned int  num_qpsk;         // counter
 };
@@ -83,8 +83,8 @@ int main(int argc, char*argv[])
     float        gamma       = powf(10.0f, (SNRdB + noise_floor)/20.0f);
 
     unsigned char p[M];
-    float complex X[M];             // channelized symbols
-    float complex y[num_samples];   // output time series
+    _Fcomplex X[M];             // channelized symbols
+    _Fcomplex y[num_samples];   // output time series
 
     // initialize subcarrier allocation
     ofdmframe_init_default_sctype(M, p);
@@ -170,7 +170,7 @@ int main(int argc, char*argv[])
     float        psd[nfft];     // PSD estimate output array
     spgramcf_estimate_psd(nfft, y, num_samples, psd);
 
-    // 
+    //
     // export output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -242,7 +242,7 @@ int main(int argc, char*argv[])
 //  _p          : subcarrier allocation array [size: _M x 1]
 //  _M          : number of subcarriers
 //  _userdata   : user-defined data pointer
-static int callback(float complex * _X,
+static int callback(_Fcomplex * _X,
                     unsigned char * _p,
                     unsigned int    _M,
                     void *          _userdata)
@@ -273,4 +273,3 @@ static int callback(float complex * _X,
     // return
     return 0;
 }
-
diff --git a/examples/pll_example.c b/examples/pll_example.c
index 3bbdbe09..bbb2b7a7 100644
--- a/examples/pll_example.c
+++ b/examples/pll_example.c
@@ -1,6 +1,6 @@
 //
 // pll_example.c
-// 
+//
 // Demonstrates a basic phase-locked loop to track the phase of a
 // complex sinusoid.
 //
@@ -28,9 +28,9 @@ int main() {
 
     //
     float theta[n];         // input phase
-    float complex x[n];     // input sinusoid
+    _Fcomplex x[n];     // input sinusoid
     float phi[n];           // output phase
-    float complex y[n];     // output sinusoid
+    _Fcomplex y[n];     // output sinusoid
 
     // generate iir loop filter object
     iirfilt_rrrf H = iirfilt_rrrf_create_pll(wn, zeta, K);
diff --git a/examples/poly_findroots_example.c b/examples/poly_findroots_example.c
index 045b21bb..d560cd2f 100644
--- a/examples/poly_findroots_example.c
+++ b/examples/poly_findroots_example.c
@@ -1,4 +1,4 @@
-// 
+//
 // poly_findroots_example.c
 //
 // test polynomial root-finding algorithm (Bairstow's method)
@@ -15,7 +15,7 @@ int main() {
 
     // generate polynomial
     float p[6] = {6,11,-33,-33,11,6};
-    float complex roots[n-1];
+    _Fcomplex roots[n-1];
 
     // print polynomial
     printf("polynomial:\n");
diff --git a/examples/qdetector_cccf_example.c b/examples/qdetector_cccf_example.c
index d79a244b..a93c7e20 100644
--- a/examples/qdetector_cccf_example.c
+++ b/examples/qdetector_cccf_example.c
@@ -1,4 +1,4 @@
-// 
+//
 // qdetector_example.c
 //
 // This example demonstrates the functionality of the qdetector object
@@ -76,7 +76,7 @@ int main(int argc, char*argv[])
     }
 
     // generate synchronization sequence (QPSK symbols)
-    float complex sequence[sequence_len];
+    _Fcomplex sequence[sequence_len];
     for (i=0; i<sequence_len; i++) {
         sequence[i] = (rand() % 2 ? 1.0f : -1.0f) * M_SQRT1_2 +
                       (rand() % 2 ? 1.0f : -1.0f) * M_SQRT1_2 * _Complex_I;
@@ -103,11 +103,11 @@ int main(int argc, char*argv[])
     unsigned int num_symbols = buf_len;
 
     // arrays
-    float complex y[num_samples];       // received signal
-    float complex syms_rx[num_symbols]; // recovered symbols
+    _Fcomplex y[num_samples];       // received signal
+    _Fcomplex syms_rx[num_symbols]; // recovered symbols
 
     // get pointer to sequence and generate full sequence
-    float complex * v = (float complex*) qdetector_cccf_get_sequence(q);
+    _Fcomplex * v = (_Fcomplex*) qdetector_cccf_get_sequence(q);
     unsigned int filter_delay = 15;
     firfilt_crcf filter = firfilt_crcf_create_kaiser(2*filter_delay+1, 0.4f, 60.0f, -tau);
     float        nstd        = powf(10.0f, -SNRdB/20.0f);
@@ -121,7 +121,7 @@ int main(int argc, char*argv[])
 
         // carrier offset
         y[i] *= cexpf(_Complex_I*(dphi*i + phi));
-        
+
         // noise
         y[i] += nstd*(randnf() + _Complex_I*randnf())*M_SQRT1_2;
     }
@@ -156,8 +156,8 @@ int main(int argc, char*argv[])
         nco_crcf_set_phase    (nco,  phi_hat);
 
         for (i=0; i<buf_len; i++) {
-            // 
-            float complex sample;
+            //
+            _Fcomplex sample;
             nco_crcf_mix_down(nco, v[i], &sample);
             nco_crcf_step(nco);
 
@@ -189,7 +189,7 @@ int main(int argc, char*argv[])
     }
     printf("\n");
 
-    // 
+    //
     // export results
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/qpacketmodem_example.c b/examples/qpacketmodem_example.c
index 980c755b..3db13d6e 100644
--- a/examples/qpacketmodem_example.c
+++ b/examples/qpacketmodem_example.c
@@ -84,8 +84,8 @@ int main(int argc, char *argv[])
     unsigned int frame_len = qpacketmodem_get_frame_len(q);
 
     // allocate memory for frame samples
-    float complex frame_tx[frame_len];
-    float complex frame_rx[frame_len];
+    _Fcomplex frame_tx[frame_len];
+    _Fcomplex frame_rx[frame_len];
 
     // encode frame
     qpacketmodem_encode(q, payload_tx, frame_tx);
@@ -136,4 +136,3 @@ int main(int argc, char *argv[])
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/qpacketmodem_performance_example.c b/examples/qpacketmodem_performance_example.c
index 300c516f..9e274802 100644
--- a/examples/qpacketmodem_performance_example.c
+++ b/examples/qpacketmodem_performance_example.c
@@ -15,7 +15,7 @@
 #include <assert.h>
 
 #include "liquid.h"
-    
+
 #define OUTPUT_FILENAME "qpacketmodem_performance_example.m"
 
 void usage()
@@ -87,8 +87,8 @@ int main(int argc, char *argv[])
     // initialize payload
     unsigned char payload_tx       [payload_len]; // payload (transmitted)
     unsigned char payload_rx       [payload_len]; // payload (received)
-    float complex frame_tx         [frame_len];   // frame samples (transmitted)
-    float complex frame_rx         [frame_len];   // frame samples (received)
+    _Fcomplex frame_tx         [frame_len];   // frame samples (transmitted)
+    _Fcomplex frame_rx         [frame_len];   // frame samples (received)
     unsigned int  num_bit_errors   [num_snr];     // bit errors for each SNR point
     unsigned int  num_packet_errors[num_snr];     // packet errors for each SNR point
     float         BER              [num_snr];     // bit error rate
@@ -140,7 +140,7 @@ int main(int argc, char *argv[])
     // destroy allocated objects
     qpacketmodem_destroy(q);
 
-    // 
+    //
     // export output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME, "w");
@@ -155,7 +155,7 @@ int main(int argc, char *argv[])
     fprintf(fid,"num_bit_trials    = %u;\n", num_bit_trials);
     fprintf(fid,"SNRdB_min         = %8.2f;\n", SNRdB_min);
     fprintf(fid,"SNRdB_max         = %8.2f;\n", SNRdB_max);
-    fprintf(fid,"scheme            = '%s/%s/%s';\n", 
+    fprintf(fid,"scheme            = '%s/%s/%s';\n",
             fec_scheme_str[fec0][1],
             fec_scheme_str[fec1][1],
             modulation_types[ms].name);
@@ -165,7 +165,7 @@ int main(int argc, char *argv[])
         fprintf(fid,"BER(%6u)   = %12.4e; ",  i+1, BER[i]);
         fprintf(fid,"PER(%6u)   = %12.4e;\n", i+1, PER[i]);
     }
-    
+
     // plot BER vs. SNR
     fprintf(fid,"\n");
     fprintf(fid,"figure;\n");
@@ -196,4 +196,3 @@ int main(int argc, char *argv[])
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/qpilotsync_example.c b/examples/qpilotsync_example.c
index 626dbfb6..21ba939b 100644
--- a/examples/qpilotsync_example.c
+++ b/examples/qpilotsync_example.c
@@ -67,10 +67,10 @@ int main(int argc, char *argv[])
 
     // allocate arrays
     unsigned char payload_sym_tx[payload_len];  // transmitted payload symbols
-    float complex payload_tx    [payload_len];  // transmitted payload samples
-    float complex frame_tx      [frame_len];    // transmitted frame samples
-    float complex frame_rx      [frame_len];    // received frame samples
-    float complex payload_rx    [payload_len];  // received payload samples
+    _Fcomplex payload_tx    [payload_len];  // transmitted payload samples
+    _Fcomplex frame_tx      [frame_len];    // transmitted frame samples
+    _Fcomplex frame_rx      [frame_len];    // received frame samples
+    _Fcomplex payload_rx    [payload_len];  // received payload samples
     unsigned char payload_sym_rx[payload_len];  // received payload symbols
 
     // create modem objects for payload
@@ -160,4 +160,3 @@ int main(int argc, char *argv[])
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/resamp2_cccf_example.c b/examples/resamp2_cccf_example.c
index 75f560c8..774b8b99 100644
--- a/examples/resamp2_cccf_example.c
+++ b/examples/resamp2_cccf_example.c
@@ -25,20 +25,20 @@ int main() {
     unsigned int i;
 
     // allocate memory for data arrays
-    float complex x [num_samples];  // input signal
-    float complex y0[num_samples];  //
-    float complex y1[num_samples];  //
+    _Fcomplex x [num_samples];  // input signal
+    _Fcomplex y0[num_samples];  //
+    _Fcomplex y1[num_samples];  //
 
     // generate the two signals
     iirfilt_crcf lowpass = iirfilt_crcf_create_lowpass(6,0.02);
     for (i=0; i<num_samples; i++) {
         // signal at negative frequency: tone
-        float complex x_neg = cexpf(-_Complex_I*2*M_PI*0.059f*i);
+        _Fcomplex x_neg = cexpf(-_Complex_I*2*M_PI*0.059f*i);
 
         // signal at positive frequency: filtered noise
-        float complex v;
+        _Fcomplex v;
         iirfilt_crcf_execute(lowpass, 4*randnf(), &v);
-        float complex x_pos = v * cexpf(_Complex_I*2*M_PI*0.073f*i);
+        _Fcomplex x_pos = v * cexpf(_Complex_I*2*M_PI*0.073f*i);
 
         // compsite
         x[i] = (x_neg + x_pos) * hamming(i,num_samples);
@@ -54,7 +54,7 @@ int main() {
     for (i=0; i<num_samples; i++)
         resamp2_cccf_filter_execute(q,x[i],&y0[i],&y1[i]);
 
-    // 
+    //
     // print results to file
     //
     FILE*fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/resamp2_crcf_decim_example.c b/examples/resamp2_crcf_decim_example.c
index adb11295..d70d4224 100644
--- a/examples/resamp2_crcf_decim_example.c
+++ b/examples/resamp2_crcf_decim_example.c
@@ -52,8 +52,8 @@ int main(int argc, char*argv[])
     unsigned int i;
 
     // allocate arrays
-    float complex x[2*num_samples]; // input array
-    float complex y[  num_samples]; // output array
+    _Fcomplex x[2*num_samples]; // input array
+    _Fcomplex y[  num_samples]; // output array
 
     // generate input
     unsigned int w_len = 2*num_samples - 4*m;   // window length
@@ -85,7 +85,7 @@ int main(int argc, char*argv[])
     // destroy half-band resampler
     resamp2_crcf_destroy(q);
 
-    // 
+    //
     // export results
     //
     FILE*fid = fopen(OUTPUT_FILENAME,"w");
@@ -95,7 +95,7 @@ int main(int argc, char*argv[])
     fprintf(fid,"num_samples=%u;\n", num_samples);
     fprintf(fid,"delay      =%u;\n", delay);
     fprintf(fid,"w_sum      =%12.8f;\n", w_sum);
-        
+
     for (i=0; i<num_samples; i++) {
         // save results to output file
         fprintf(fid,"x(%3u) = %12.8f + j*%12.8f;\n", 2*i+1,      crealf(x[2*i+0]),      cimagf(x[2*i+0]));
diff --git a/examples/resamp2_crcf_example.c b/examples/resamp2_crcf_example.c
index 9392cdab..45a970f0 100644
--- a/examples/resamp2_crcf_example.c
+++ b/examples/resamp2_crcf_example.c
@@ -29,9 +29,9 @@ int main() {
     unsigned int n = num_samples + 2*m + 1; // adjusted input sequence length
 
     // allocate memory for data arrays
-    float complex x[  n];
-    float complex y[2*n];
-    float complex z[  n];
+    _Fcomplex x[  n];
+    _Fcomplex y[2*n];
+    _Fcomplex z[  n];
 
     // generate the baseband signal (filter pulse)
     float h[num_samples];
@@ -67,7 +67,7 @@ int main() {
     rmse = sqrtf( rmse / (float)(n-2*m) );
     printf("rms error : %12.4e\n", rmse);
 
-    // 
+    //
     // print results to file
     //
     FILE*fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/resamp2_crcf_filter_example.c b/examples/resamp2_crcf_filter_example.c
index 4a33b3d5..e2e3b354 100644
--- a/examples/resamp2_crcf_filter_example.c
+++ b/examples/resamp2_crcf_filter_example.c
@@ -25,9 +25,9 @@ int main() {
     unsigned int N = num_samples + h_len;
 
     // arrays
-    float complex x[N];             // input time series
-    float complex y0[N];            // output time series (lower band)
-    float complex y1[N];            // output time series (upper band)
+    _Fcomplex x[N];             // input time series
+    _Fcomplex y0[N];            // output time series (lower band)
+    _Fcomplex y1[N];            // output time series (upper band)
 
     // generate input sequence
     unsigned int i;
@@ -52,7 +52,7 @@ int main() {
     // clean up allocated objects
     resamp2_crcf_destroy(q);
 
-    // 
+    //
     // export output file
     //
     FILE*fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/examples/resamp2_crcf_interp_example.c b/examples/resamp2_crcf_interp_example.c
index c966f632..c4d392dc 100644
--- a/examples/resamp2_crcf_interp_example.c
+++ b/examples/resamp2_crcf_interp_example.c
@@ -52,8 +52,8 @@ int main(int argc, char*argv[])
     unsigned int i;
 
     // allocate arrays
-    float complex x[  num_samples]; // input array
-    float complex y[2*num_samples]; // output array
+    _Fcomplex x[  num_samples]; // input array
+    _Fcomplex y[2*num_samples]; // output array
 
     // generate input
     unsigned int w_len = num_samples - 2*m; // window length
@@ -85,7 +85,7 @@ int main(int argc, char*argv[])
     // destroy half-band resampler
     resamp2_crcf_destroy(q);
 
-    // 
+    //
     // export results
     //
     FILE*fid = fopen(OUTPUT_FILENAME,"w");
@@ -94,7 +94,7 @@ int main(int argc, char*argv[])
     fprintf(fid,"num_samples=%u;\n", num_samples);
     fprintf(fid,"delay      =%u;\n", delay);
     fprintf(fid,"w_sum     =%12.8f;\n", w_sum);
-        
+
     for (i=0; i<num_samples; i++) {
         // save results to output file
         fprintf(fid,"x(%3u) = %12.8f + j*%12.8f;\n", i+1,   crealf(x[i    ]), cimagf(x[i    ]));
diff --git a/examples/resamp_crcf_example.c b/examples/resamp_crcf_example.c
index b1916a07..a8fe07c1 100644
--- a/examples/resamp_crcf_example.c
+++ b/examples/resamp_crcf_example.c
@@ -86,8 +86,8 @@ int main(int argc, char*argv[])
     unsigned int y_len = (unsigned int) ceilf(1.1 * nx * r) + 4;
 
     // arrays
-    float complex x[nx];
-    float complex y[y_len];
+    _Fcomplex x[nx];
+    _Fcomplex y[y_len];
 
     // create resampler
     resamp_crcf q = resamp_crcf_create(r,m,bw,As,npfb);
@@ -113,7 +113,7 @@ int main(int argc, char*argv[])
     // clean up allocated objects
     resamp_crcf_destroy(q);
 
-    // 
+    //
     // analyze resulting signal
     //
 
@@ -124,8 +124,8 @@ int main(int argc, char*argv[])
     // run FFT and ensure that carrier has moved and that image
     // frequencies and distortion have been adequately suppressed
     unsigned int nfft = 1 << liquid_nextpow2(ny);
-    float complex yfft[nfft];   // fft input
-    float complex Yfft[nfft];   // fft output
+    _Fcomplex yfft[nfft];   // fft input
+    _Fcomplex Yfft[nfft];   // fft output
     for (i=0; i<nfft; i++)
         yfft[i] = i < ny ? y[i] : 0.0f;
     fft_run(nfft, yfft, Yfft, LIQUID_FFT_FORWARD, 0);
diff --git a/examples/resamp_crcf_noise_example.c b/examples/resamp_crcf_noise_example.c
index b8d041ea..44b09f70 100644
--- a/examples/resamp_crcf_noise_example.c
+++ b/examples/resamp_crcf_noise_example.c
@@ -66,8 +66,8 @@ int main(int argc, char*argv[])
 
     // arrays
     unsigned int  buf_len = 1024;
-    float complex buf_x[  buf_len];
-    float complex buf_y[2*buf_len];
+    _Fcomplex buf_x[  buf_len];
+    _Fcomplex buf_y[2*buf_len];
 
     // create signal generator (wide-band noise)
     msourcecf gen = msourcecf_create_default();
diff --git a/examples/ricek_channel_example.c b/examples/ricek_channel_example.c
index a94030bc..55e6aeea 100644
--- a/examples/ricek_channel_example.c
+++ b/examples/ricek_channel_example.c
@@ -75,7 +75,7 @@ int main(int argc, char*argv[])
     unsigned int i;
 
     // allocate array for output samples
-    float complex * y = (float complex*) malloc(num_samples*sizeof(float complex));
+    _Fcomplex * y = (_Fcomplex*) malloc(num_samples*sizeof(_Fcomplex));
 
     // generate Doppler filter coefficients
     float h[h_len];
@@ -94,8 +94,8 @@ int main(int argc, char*argv[])
     firfilt_crcf fdoppler = firfilt_crcf_create(h,h_len);
 
     // generate complex circular Gauss random variables
-    float complex v;    // circular Gauss random variable (uncorrelated)
-    float complex x;    // circular Gauss random variable (correlated w/ Doppler filter)
+    _Fcomplex v;    // circular Gauss random variable (uncorrelated)
+    _Fcomplex x;    // circular Gauss random variable (correlated w/ Doppler filter)
     float s   = sqrtf((omega*K)/(K+1.0));
     float sig = sqrtf(0.5f*omega/(K+1.0));
     for (i=0; i<num_samples; i++) {
@@ -175,4 +175,3 @@ int main(int argc, char*argv[])
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/rresamp_crcf_example.c b/examples/rresamp_crcf_example.c
index c4605fb9..1167d720 100644
--- a/examples/rresamp_crcf_example.c
+++ b/examples/rresamp_crcf_example.c
@@ -69,8 +69,8 @@ int main(int argc, char*argv[])
     unsigned int n = 120e3 / (P > Q ? P : Q);
 
     // input/output buffers
-    float complex buf_x[Q]; // input
-    float complex buf_y[P]; // output
+    _Fcomplex buf_x[Q]; // input
+    _Fcomplex buf_y[P]; // output
 
     // create signal generator (wide-band noise)
     msourcecf gen = msourcecf_create_default();
diff --git a/examples/rresamp_crcf_rnyquist_example.c b/examples/rresamp_crcf_rnyquist_example.c
index 45aae649..9880e08e 100644
--- a/examples/rresamp_crcf_rnyquist_example.c
+++ b/examples/rresamp_crcf_rnyquist_example.c
@@ -69,9 +69,9 @@ int main(int argc, char*argv[])
     rresamp_crcf_print(q0);
 
     // input/output buffers
-    float complex buf_x[Q]; // input
-    float complex buf_y[P]; // interp
-    float complex buf_z[Q]; // decim
+    _Fcomplex buf_x[Q]; // input
+    _Fcomplex buf_y[P]; // interp
+    _Fcomplex buf_z[Q]; // decim
 
     // generate input symbols
     unsigned int i, n = 0;
diff --git a/examples/spgramcf_example.c b/examples/spgramcf_example.c
index 1ec82da5..8736f7d6 100644
--- a/examples/spgramcf_example.c
+++ b/examples/spgramcf_example.c
@@ -41,7 +41,7 @@ int main() {
         iirfilt_rrrf_execute(filter, randnf(), &v);
 
         // filter off negative image (gain of 2)
-        float complex y = 0;
+        _Fcomplex y = 0;
         firhilbf_r2c_execute(ht, v, &y);
 
         // scale and add noise
@@ -63,7 +63,7 @@ int main() {
     firhilbf_destroy(ht);
     spgramcf_destroy(q);
 
-    // 
+    //
     // export output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -74,7 +74,7 @@ int main() {
     fprintf(fid,"f    = [0:(nfft-1)]/nfft - 0.5;\n");
     fprintf(fid,"psd  = zeros(1,nfft);\n");
     fprintf(fid,"noise_floor = %12.6f;\n", noise_floor);
-    
+
     for (i=0; i<nfft; i++)
         fprintf(fid,"psd(%6u) = %12.4e;\n", i+1, psd[i]);
 
@@ -93,4 +93,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/spwaterfallcf_example.c b/examples/spwaterfallcf_example.c
index 33da0681..fdfdde50 100644
--- a/examples/spwaterfallcf_example.c
+++ b/examples/spwaterfallcf_example.c
@@ -21,7 +21,7 @@ int main()
 
     // create stream generator
     msourcecf gen = msourcecf_create_default();
-    
+
     // add noise source (wide band)
     msourcecf_add_noise(gen, 0.0f, 1.00f, -40);
 
@@ -42,7 +42,7 @@ int main()
 
     // create buffers
     unsigned int  buf_len = 64;
-    float complex buf[buf_len];
+    _Fcomplex buf[buf_len];
 
     // generate signals and push through spwaterfall object
     unsigned int total_samples   = 0;
@@ -82,5 +82,3 @@ int main()
     printf("done.\n");
     return 0;
 }
-
-
diff --git a/examples/symstreamcf_example.c b/examples/symstreamcf_example.c
index c3a4b743..4c5bcdce 100644
--- a/examples/symstreamcf_example.c
+++ b/examples/symstreamcf_example.c
@@ -29,7 +29,7 @@ int main()
     spgramcf periodogram = spgramcf_create_default(nfft);
 
     unsigned int buf_len = 1024;
-    float complex buf[buf_len];
+    _Fcomplex buf[buf_len];
 
     // create stream generator
     symstreamcf gen = symstreamcf_create_linear(ftype,k,m,beta,ms);
@@ -41,7 +41,7 @@ int main()
 
         // push resulting sample through periodogram
         spgramcf_write(periodogram, buf, buf_len);
-        
+
         // accumulated samples
         total_samples += buf_len;
     }
@@ -55,7 +55,7 @@ int main()
     symstreamcf_destroy(gen);
     spgramcf_destroy(periodogram);
 
-    // 
+    //
     // export output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -65,7 +65,7 @@ int main()
     fprintf(fid,"nfft = %u;\n", nfft);
     fprintf(fid,"f    = [0:(nfft-1)]/nfft - 0.5;\n");
     fprintf(fid,"H    = zeros(1,nfft);\n");
-    
+
     for (i=0; i<nfft; i++)
         fprintf(fid,"H(%6u) = %12.4e;\n", i+1, psd[i]);
 
@@ -82,4 +82,3 @@ int main()
     printf("done.\n");
     return 0;
 }
-
diff --git a/examples/symsync_crcf_example.c b/examples/symsync_crcf_example.c
index b3e4d131..afcd5f7c 100644
--- a/examples/symsync_crcf_example.c
+++ b/examples/symsync_crcf_example.c
@@ -84,9 +84,9 @@ int main(int argc, char*argv[]) {
     // derived values
     unsigned int num_samples = k*num_symbols;
 
-    float complex s[num_symbols];       // data symbols
-    float complex x[num_samples];       // interpolated samples
-    float complex y[num_symbols + 64];  // synchronized symbols
+    _Fcomplex s[num_symbols];       // data symbols
+    _Fcomplex x[num_samples];       // interpolated samples
+    _Fcomplex y[num_symbols + 64];  // synchronized symbols
 
     // generate random QPSK symbols
     for (i=0; i<num_symbols; i++) {
@@ -106,7 +106,7 @@ int main(int argc, char*argv[]) {
 
     // create symbol synchronizer
     symsync_crcf sync = symsync_crcf_create_rnyquist(ftype, k, m, beta, num_filters);
-    
+
     // set bandwidth
     symsync_crcf_set_lf_bw(sync,bandwidth);
 
@@ -136,7 +136,7 @@ int main(int argc, char*argv[]) {
 
     for (i=0; i<ny; i++)
         fprintf(fid,"y(%3u) = %12.8f + j*%12.8f;\n", i+1, crealf(y[i]), cimagf(y[i]));
-        
+
     fprintf(fid,"i0 = 1:round(0.5*ny);\n");
     fprintf(fid,"i1 = round(0.5*ny):ny;\n");
     fprintf(fid,"figure;\n");
diff --git a/examples/symsync_crcf_full_example.c b/examples/symsync_crcf_full_example.c
index a53f336a..b58d8baa 100644
--- a/examples/symsync_crcf_full_example.c
+++ b/examples/symsync_crcf_full_example.c
@@ -57,7 +57,7 @@ int main(int argc, char*argv[]) {
     float bt    =  0.02f;       // loop filter bandwidth
     float tau   = -0.2f;        // fractional symbol offset
     float r     =    1.00f;     // resampled rate
-    
+
     // use random data or 101010 phasing pattern
     int random_data=1;
 
@@ -134,11 +134,11 @@ int main(int argc, char*argv[]) {
 
     unsigned int num_samples = k*num_symbols;
     unsigned int num_samples_resamp = (unsigned int) ceilf(num_samples*r*1.1f) + 4;
-    float complex s[num_symbols];           // data symbols
-    float complex x[num_samples];           // interpolated samples
-    float complex y[num_samples_resamp];    // resampled data (resamp_crcf)
-    float complex z[k_out*num_symbols + 64];// synchronized samples
-    float complex sym_out[num_symbols + 64];// synchronized symbols
+    _Fcomplex s[num_symbols];           // data symbols
+    _Fcomplex x[num_samples];           // interpolated samples
+    _Fcomplex y[num_samples_resamp];    // resampled data (resamp_crcf)
+    _Fcomplex z[k_out*num_symbols + 64];// synchronized samples
+    _Fcomplex sym_out[num_symbols + 64];// synchronized symbols
 
     for (i=0; i<num_symbols; i++) {
         if (random_data) {
@@ -149,7 +149,7 @@ int main(int argc, char*argv[]) {
         }
     }
 
-    // 
+    //
     // create and run interpolator
     //
 
@@ -165,7 +165,7 @@ int main(int argc, char*argv[]) {
     assert(n == num_samples);
     firinterp_crcf_destroy(q);
 
-    // 
+    //
     // run resampler
     //
     unsigned int resamp_len = 10*k; // resampling filter semi-length (filter delay)
@@ -188,7 +188,7 @@ int main(int argc, char*argv[]) {
     }
     resamp_crcf_destroy(f);
 
-    // 
+    //
     // add noise
     //
     float nstd = powf(10.0f, -SNRdB/20.0f);
@@ -196,7 +196,7 @@ int main(int argc, char*argv[]) {
         y[i] += nstd*(randnf() + _Complex_I*randnf());
 
 
-    // 
+    //
     // create and run symbol synchronizer
     //
 
@@ -251,16 +251,16 @@ int main(int argc, char*argv[]) {
 
     for (i=0; i<num_samples; i++)
         fprintf(fid,"x(%3u) = %12.8f + j*%12.8f;\n", i+1, crealf(x[i]), cimagf(x[i]));
-        
+
     for (i=0; i<num_samples_resampled; i++)
         fprintf(fid,"y(%3u) = %12.8f + j*%12.8f;\n", i+1, crealf(y[i]), cimagf(y[i]));
-        
+
     for (i=0; i<num_samples_sync; i++)
         fprintf(fid,"z(%3u) = %12.8f + j*%12.8f;\n", i+1, crealf(z[i]), cimagf(z[i]));
-        
+
     for (i=0; i<num_symbols_sync; i++)
         fprintf(fid,"sym_out(%3u) = %12.8f + j*%12.8f;\n", i+1, crealf(sym_out[i]), cimagf(sym_out[i]));
-        
+
     for (i=0; i<num_samples_sync; i++)
         fprintf(fid,"tau_hat(%3u) = %12.8f;\n", i+1, tau_hat[i]);
 
diff --git a/examples/symsync_crcf_kaiser_example.c b/examples/symsync_crcf_kaiser_example.c
index 8fb0b40b..045c4c5c 100644
--- a/examples/symsync_crcf_kaiser_example.c
+++ b/examples/symsync_crcf_kaiser_example.c
@@ -49,7 +49,7 @@ int main(int argc, char*argv[])
 
     // Nyquist filter type
     liquid_firfilt_type ftype = LIQUID_FIRFILT_KAISER;
-    
+
     int dopt;
     while ((dopt = getopt(argc,argv,"uhk:m:b:B:s:w:n:t:")) != EOF) {
         switch (dopt) {
@@ -95,16 +95,16 @@ int main(int argc, char*argv[])
 
     // derived values
     unsigned int num_samples = k*num_symbols;
-    float complex x[num_samples];           // interpolated samples
-    float complex y[num_samples];           // received signal (with noise)
+    _Fcomplex x[num_samples];           // interpolated samples
+    _Fcomplex y[num_samples];           // received signal (with noise)
     float         tau_hat[num_samples];     // instantaneous timing offset estimate
-    float complex sym_out[num_symbols + 64];// synchronized symbols
+    _Fcomplex sym_out[num_symbols + 64];// synchronized symbols
 
     // create sequence of Nyquist-interpolated QPSK symbols
     firinterp_crcf interp = firinterp_crcf_create_prototype(ftype,k,m,beta,tau);
     for (i=0; i<num_symbols; i++) {
         // generate random QPSK symbol
-        float complex s = ( rand() % 2 ? M_SQRT1_2 : -M_SQRT1_2 ) +
+        _Fcomplex s = ( rand() % 2 ? M_SQRT1_2 : -M_SQRT1_2 ) +
                           ( rand() % 2 ? M_SQRT1_2 : -M_SQRT1_2 ) * _Complex_I;
 
         // interpolate symbol
@@ -163,16 +163,16 @@ int main(int argc, char*argv[])
 
     for (i=0; i<num_samples; i++)
         fprintf(fid,"x(%3u) = %12.8f + j*%12.8f;\n", i+1, crealf(x[i]), cimagf(x[i]));
-        
+
     for (i=0; i<num_samples; i++)
         fprintf(fid,"y(%3u) = %12.8f + j*%12.8f;\n", i+1, crealf(y[i]), cimagf(y[i]));
-        
+
     for (i=0; i<num_samples; i++)
         fprintf(fid,"tau_hat(%3u) = %12.8f;\n", i+1, tau_hat[i]);
-        
+
     for (i=0; i<num_symbols_sync; i++)
         fprintf(fid,"sym_out(%3u) = %12.8f + j*%12.8f;\n", i+1, crealf(sym_out[i]), cimagf(sym_out[i]));
-        
+
     fprintf(fid,"i0 = 1:round( 0.5*num_symbols );\n");
     fprintf(fid,"i1 = round( 0.5*num_symbols ):num_symbols;\n");
     fprintf(fid,"figure;\n");
diff --git a/examples/symtrack_cccf_example.c b/examples/symtrack_cccf_example.c
index 7f8257cf..57dd8326 100644
--- a/examples/symtrack_cccf_example.c
+++ b/examples/symtrack_cccf_example.c
@@ -90,9 +90,9 @@ int main(int argc, char*argv[])
 
     // buffers
     unsigned int    buf_len = 800;      // buffer size
-    float complex   x   [buf_len];      // original signal
-    float complex   y   [buf_len];      // channel output
-    float complex   syms[buf_len];      // recovered symbols
+    _Fcomplex   x   [buf_len];      // original signal
+    _Fcomplex   y   [buf_len];      // channel output
+    _Fcomplex   syms[buf_len];      // recovered symbols
     // window for saving last few symbols
     windowcf sym_buf = windowcf_create(buf_len);
 
@@ -153,7 +153,7 @@ int main(int argc, char*argv[])
     fprintf(fid,"close all;\n");
 
     // read buffer and write last symbols to file
-    float complex * rc;
+    _Fcomplex * rc;
     windowcf_read(sym_buf, &rc);
     fprintf(fid,"syms = zeros(1,%u);\n", buf_len);
     for (i=0; i<buf_len; i++)
diff --git a/include/liquid.internal.h b/include/liquid.internal.h
index 8a42195f..cc453961 100644
--- a/include/liquid.internal.h
+++ b/include/liquid.internal.h
@@ -135,8 +135,8 @@ struct fec_s {
 
     // Reed-Solomon decoder
     unsigned int num_blocks;    // number of blocks: ceil(dec_msg_len / nn)
-    unsigned int dec_block_len; // number of decoded bytes per block: 
-    unsigned int enc_block_len; // number of encoded bytes per block: 
+    unsigned int dec_block_len; // number of decoded bytes per block:
+    unsigned int enc_block_len; // number of encoded bytes per block:
     unsigned int res_block_len; // residual bytes in last block
     unsigned int pad;           // padding for each block
     unsigned char * tblock;     // decoder input sequence [size: 1 x n]
@@ -561,8 +561,8 @@ void fec_conv_init_v29p78(fec _q);
 // compute encoded message length for Reed-Solomon codes
 //  _dec_msg_len    :   decoded message length
 //  _nroots         :   number of roots in polynomial
-//  _nn             :   
-//  _kk             :   
+//  _nn             :
+//  _kk             :
 unsigned int fec_rs_get_enc_msg_len(unsigned int _dec_msg_len,
                                     unsigned int _nroots,
                                     unsigned int _nn,
@@ -815,7 +815,7 @@ LIQUID_FIRFARROW_DEFINE_INTERNAL_API(LIQUID_FIRFARROW_MANGLE_CRCF,
 
 
 
-// 
+//
 // iirfiltsos : infinite impulse respone filter (second-order sections)
 //
 #define LIQUID_IIRFILTSOS_MANGLE_RRRF(name)  LIQUID_CONCAT(iirfiltsos_rrrf,name)
@@ -937,7 +937,7 @@ void liquid_firdes_rkaiser_quadratic(unsigned int _k,
                                      float * _rho);
 
 // compute filter coefficients and determine resulting ISI
-//  
+//
 //  _k      :   filter over-sampling rate (samples/symbol)
 //  _m      :   filter delay (symbols)
 //  _beta   :   filter excess bandwidth factor (0,1)
@@ -998,10 +998,10 @@ void liquid_firdes_farcsech_freqresponse(unsigned int _k,
 //  _n      :   number of elements in _z
 //  _tol    :   tolerance for finding complex pairs
 //  _p      :   resulting pairs, pure real values of _z at end
-void liquid_cplxpair(float complex * _z,
+void liquid_cplxpair(_Fcomplex * _z,
                      unsigned int _n,
                      float _tol,
-                     float complex * _p);
+                     _Fcomplex * _p);
 
 // post-process cleanup used with liquid_cplxpair
 //
@@ -1015,7 +1015,7 @@ void liquid_cplxpair(float complex * _z,
 //  _p          :   pre-processed complex array [size: _n x 1]
 //  _n          :   array length
 //  _num_pairs  :   number of complex conjugate pairs
-void liquid_cplxpair_cleanup(float complex * _p,
+void liquid_cplxpair_cleanup(_Fcomplex * _p,
                              unsigned int _n,
                              unsigned int _num_pairs);
 
@@ -1038,22 +1038,22 @@ float ellipdegf(float _N,
                 unsigned int _n);
 
 // elliptic cd() function (_n recursions)
-float complex ellip_cdf(float complex _u,
+_Fcomplex ellip_cdf(_Fcomplex _u,
                         float _k,
                         unsigned int _n);
 
 // elliptic inverse cd() function (_n recursions)
-float complex ellip_acdf(float complex _u,
+_Fcomplex ellip_acdf(_Fcomplex _u,
                          float _k,
                          unsigned int _n);
 
 // elliptic sn() function (_n recursions)
-float complex ellip_snf(float complex _u,
+_Fcomplex ellip_snf(_Fcomplex _u,
                         float _k,
                         unsigned int _n);
 
 // elliptic inverse sn() function (_n recursions)
-float complex ellip_asnf(float complex _u,
+_Fcomplex ellip_asnf(_Fcomplex _u,
                          float _k,
                          unsigned int _n);
 
@@ -1082,7 +1082,7 @@ void bpacketsync_decode_payload(bpacketsync _q);
 void bpacketsync_reconfig(bpacketsync _q);
 
 
-// 
+//
 // flexframe
 //
 
@@ -1098,7 +1098,7 @@ void bpacketsync_reconfig(bpacketsync _q);
 #define FLEXFRAME_H_MOD          (LIQUID_MODEM_QPSK)     // modulation scheme
 
 
-// 
+//
 // gmskframe
 //
 
@@ -1111,7 +1111,7 @@ void bpacketsync_reconfig(bpacketsync _q);
 #define GMSKFRAME_H_FEC            (LIQUID_FEC_HAMMING128) // header FEC
 
 
-// 
+//
 // ofdmflexframe
 //
 
@@ -1231,14 +1231,14 @@ void QSOURCE(_generate)(QSOURCE() _q,                                       \
                                                                             \
 void QSOURCE(_generate_into)(QSOURCE() _q,                                  \
                              TO *      _buf);                               \
-    
+
 LIQUID_QSOURCE_DEFINE_API(LIQUID_QSOURCE_MANGLE_CFLOAT, liquid_float_complex)
 
 //
 // MODULE : math
 //
 
-// 
+//
 // basic trigonometric functions
 //
 float liquid_sinf(float _x);
@@ -1250,24 +1250,24 @@ void  liquid_sincosf(float _x,
 float liquid_expf(float _x);
 float liquid_logf(float _x);
 
-// 
+//
 // complex math operations
 //
 
 // complex square root
-float complex liquid_csqrtf(float complex _z);
+_Fcomplex liquid_csqrtf(_Fcomplex _z);
 
 // complex exponent, logarithm
-float complex liquid_cexpf(float complex _z);
-float complex liquid_clogf(float complex _z);
+_Fcomplex liquid_cexpf(_Fcomplex _z);
+_Fcomplex liquid_clogf(_Fcomplex _z);
 
 // complex arcsin, arccos, arctan
-float complex liquid_casinf(float complex _z);
-float complex liquid_cacosf(float complex _z);
-float complex liquid_catanf(float complex _z);
+_Fcomplex liquid_casinf(_Fcomplex _z);
+_Fcomplex liquid_cacosf(_Fcomplex _z);
+_Fcomplex liquid_catanf(_Fcomplex _z);
 
 // faster approximation to arg{*}
-float liquid_cargf_approx(float complex _z);
+float liquid_cargf_approx(_Fcomplex _z);
 
 
 // internal trig helper functions
@@ -1488,7 +1488,7 @@ void MODEM(_demodulate_linear_array_ref)(T              _v,     \
 
 
 // define internal modem APIs
-LIQUID_MODEM_DEFINE_INTERNAL_API(LIQUID_MODEM_MANGLE_FLOAT,float,float complex)
+LIQUID_MODEM_DEFINE_INTERNAL_API(LIQUID_MODEM_MANGLE_FLOAT,float,_Fcomplex)
 
 // APSK constants (container for apsk structure definitions)
 struct liquid_apsk_s {
@@ -1511,23 +1511,23 @@ extern struct liquid_apsk_s liquid_apsk256;
 
 
 // 'square' 32-QAM (first quadrant)
-extern const float complex modem_arb_sqam32[8];
+extern const _Fcomplex modem_arb_sqam32[8];
 
 // 'square' 128-QAM (first quadrant)
-extern const float complex modem_arb_sqam128[32];
+extern const _Fcomplex modem_arb_sqam128[32];
 
 // V.29 star constellation
-extern const float complex modem_arb_V29[16];
+extern const _Fcomplex modem_arb_V29[16];
 
 // Virginia Tech logo
-extern const float complex modem_arb_vt64[64];
+extern const _Fcomplex modem_arb_vt64[64];
 
 // optimal QAM constellations
-extern const float complex modem_arb16opt[16];
-extern const float complex modem_arb32opt[32];
-extern const float complex modem_arb64opt[64];
-extern const float complex modem_arb128opt[128];
-extern const float complex modem_arb256opt[256];
+extern const _Fcomplex modem_arb16opt[16];
+extern const _Fcomplex modem_arb32opt[32];
+extern const _Fcomplex modem_arb64opt[64];
+extern const _Fcomplex modem_arb128opt[128];
+extern const _Fcomplex modem_arb256opt[256];
 
 
 //
@@ -1544,8 +1544,8 @@ extern const float complex modem_arb256opt[256];
 //  _M_S0   :   total number of enabled subcarriers in S0
 void ofdmframe_init_S0(unsigned char * _p,
                        unsigned int    _M,
-                       float complex * _S0,
-                       float complex * _s0,
+                       _Fcomplex * _S0,
+                       _Fcomplex * _s0,
                        unsigned int *  _M_S0);
 
 // generate long sequence symbols
@@ -1556,13 +1556,13 @@ void ofdmframe_init_S0(unsigned char * _p,
 //  _M_S1   :   total number of enabled subcarriers in S1
 void ofdmframe_init_S1(unsigned char * _p,
                        unsigned int    _M,
-                       float complex * _S1,
-                       float complex * _s1,
+                       _Fcomplex * _S1,
+                       _Fcomplex * _s1,
                        unsigned int *  _M_S1);
 
 // generate symbol (add cyclic prefix/postfix, overlap)
 void ofdmframegen_gensymbol(ofdmframegen    _q,
-                            float complex * _buffer);
+                            _Fcomplex * _buffer);
 
 void ofdmframesync_cpcorrelate(ofdmframesync _q);
 void ofdmframesync_findrxypeak(ofdmframesync _q);
@@ -1575,24 +1575,24 @@ void ofdmframesync_execute_S1( ofdmframesync _q);
 void ofdmframesync_execute_rxsymbols(ofdmframesync _q);
 
 void ofdmframesync_S0_metrics(ofdmframesync _q,
-                              float complex * _G,
-                              float complex * _s_hat);
+                              _Fcomplex * _G,
+                              _Fcomplex * _s_hat);
 
 // estimate short sequence gain
 //  _q      :   ofdmframesync object
 //  _x      :   input array (time)
 //  _G      :   output gain (freq)
 void ofdmframesync_estimate_gain_S0(ofdmframesync   _q,
-                                    float complex * _x,
-                                    float complex * _G);
+                                    _Fcomplex * _x,
+                                    _Fcomplex * _G);
 
 // estimate long sequence gain
 //  _q      :   ofdmframesync object
 //  _x      :   input array (time)
 //  _G      :   output gain (freq)
 void ofdmframesync_estimate_gain_S1(ofdmframesync _q,
-                                    float complex * _x,
-                                    float complex * _G);
+                                    _Fcomplex * _x,
+                                    _Fcomplex * _G);
 
 // estimate complex equalizer gain from G0 and G1
 //  _q      :   ofdmframesync object
@@ -1609,7 +1609,7 @@ void ofdmframesync_estimate_eqgain_poly(ofdmframesync _q,
 // recover symbol, correcting for gain, pilot phase, etc.
 void ofdmframesync_rxsymbol(ofdmframesync _q);
 
-// 
+//
 // MODULE : nco (numerically-controlled oscillator)
 //
 
@@ -1631,7 +1631,7 @@ void NCO(_pll_reset)(NCO() _q);                                 \
 // Define nco internal APIs
 LIQUID_NCO_DEFINE_INTERNAL_API(LIQUID_NCO_MANGLE_FLOAT,
                                float,
-                               float complex)
+                               _Fcomplex)
 
 // Numerically-controlled synthesizer (direct digital synthesis)
 #define LIQUID_SYNTH_DEFINE_INTERNAL_API(SYNTH,T,TC)            \
@@ -1648,7 +1648,7 @@ void SYNTH(_pll_reset)(SYNTH() _q);                             \
 LIQUID_SYNTH_DEFINE_INTERNAL_API(SYNTH_MANGLE_FLOAT,
                                  float,
                                  liquid_float_complex)
-// 
+//
 // MODULE : optim (non-linear optimization)
 //
 
@@ -1757,7 +1757,7 @@ struct chromosome_s {
 struct gasearch_s {
     chromosome * population;            // population of chromosomes
     unsigned int population_size;       // size of the population
-    unsigned int selection_size;        // number of 
+    unsigned int selection_size;        // number of
     float mutation_rate;                // rate of mutation
 
     unsigned int num_parameters;        // number of parameters to optimize
@@ -1817,7 +1817,7 @@ void optim_sort(float *_v,
 
 #define randf_inline() ((float) rand() / (float) RAND_MAX)
 
-float complex icrandnf();
+_Fcomplex icrandnf();
 
 // generate x ~ Gamma(delta,1)
 float randgammaf_delta(float _delta);
@@ -1924,4 +1924,3 @@ extern unsigned int liquid_c_leading_zeros[256];
 // byte reversal and manipulation
 extern const unsigned char liquid_reverse_byte_gentab[256];
 #endif // __LIQUID_INTERNAL_H__
-
diff --git a/sandbox/am_demod_dsb_peak_detect_test.c b/sandbox/am_demod_dsb_peak_detect_test.c
index 93fda9c0..dbf3b591 100644
--- a/sandbox/am_demod_dsb_peak_detect_test.c
+++ b/sandbox/am_demod_dsb_peak_detect_test.c
@@ -21,7 +21,7 @@ int main(int argc, char*argv[])
     // buffers
     unsigned int i;
     float         x[num_samples];
-    float complex y[num_samples];
+    _Fcomplex y[num_samples];
     float         z[num_samples];
 
     // generate 'audio' signal (simple windowed sum of tones)
diff --git a/sandbox/am_demod_dsb_pll_carrier_test.c b/sandbox/am_demod_dsb_pll_carrier_test.c
index ef481aae..4b56fe16 100644
--- a/sandbox/am_demod_dsb_pll_carrier_test.c
+++ b/sandbox/am_demod_dsb_pll_carrier_test.c
@@ -21,7 +21,7 @@ int main(int argc, char*argv[])
     // buffers
     unsigned int i;
     float         x[num_samples];
-    float complex y[num_samples];
+    _Fcomplex y[num_samples];
     float         z[num_samples];
 
     // generate 'audio' signal (simple windowed sum of tones)
@@ -56,7 +56,7 @@ int main(int argc, char*argv[])
     iirfilt_crcf dcblock = iirfilt_crcf_create_dc_blocker(0.02f);
     for (i=0; i<num_samples; i++) {
         // mix signal down
-        float complex v;
+        _Fcomplex v;
         nco_crcf_mix_down(mixer, y[i], &v);
 
         // compute phase error
diff --git a/sandbox/am_demod_dsb_pll_costas_test.c b/sandbox/am_demod_dsb_pll_costas_test.c
index 797fd6c0..d5225b36 100644
--- a/sandbox/am_demod_dsb_pll_costas_test.c
+++ b/sandbox/am_demod_dsb_pll_costas_test.c
@@ -22,7 +22,7 @@ int main(int argc, char*argv[])
     // buffers
     unsigned int i;
     float         x[num_samples];
-    float complex y[num_samples];
+    _Fcomplex y[num_samples];
     float         z[num_samples];
     float         p[num_samples]; // phase error
 
@@ -57,7 +57,7 @@ int main(int argc, char*argv[])
     nco_crcf_pll_set_bandwidth(mixer,0.01f);
     for (i=0; i<num_samples; i++) {
         // mix signal down
-        float complex v;
+        _Fcomplex v;
         nco_crcf_mix_down(mixer, y[i], &v);
 
         // compute phase error
diff --git a/sandbox/am_demod_ssb_pll_carrier_test.c b/sandbox/am_demod_ssb_pll_carrier_test.c
index 97ae0f3a..935814c4 100644
--- a/sandbox/am_demod_ssb_pll_carrier_test.c
+++ b/sandbox/am_demod_ssb_pll_carrier_test.c
@@ -24,7 +24,7 @@ int main(int argc, char*argv[])
     // buffers
     unsigned int i;
     float         x[num_samples];
-    float complex y[num_samples];
+    _Fcomplex y[num_samples];
     float         z[num_samples];
 
     // generate 'audio' signal (simple windowed sum of tones)
@@ -39,7 +39,7 @@ int main(int argc, char*argv[])
     // modulate signal (SSB with carrier)
     firhilbf hilbert = firhilbf_create(m, As);
     for (i=0; i<num_samples; i++) {
-        float complex mp;
+        _Fcomplex mp;
         firhilbf_r2c_execute(hilbert, mod_index*x[i], &mp);
         y[i] = 1.0f + (usb ? mp : conjf(mp));
 
@@ -68,7 +68,7 @@ int main(int argc, char*argv[])
     firhilbf_reset(hilbert);
     for (i=0; i<num_samples; i++) {
         // mix signal down
-        float complex v;
+        _Fcomplex v;
         nco_crcf_mix_down(mixer, y[i], &v);
 
         // compute phase error
diff --git a/sandbox/bpresync_test.c b/sandbox/bpresync_test.c
index 113d563b..bbbec543 100644
--- a/sandbox/bpresync_test.c
+++ b/sandbox/bpresync_test.c
@@ -1,4 +1,4 @@
-// 
+//
 // bpresync_test.c
 //
 // This example demonstrates the binary pre-demodulator synchronizer. A random
@@ -32,7 +32,7 @@ void usage()
 }
 
 void bpresync_test(bpresync_cccf   _q,
-                   float complex * _x,
+                   _Fcomplex * _x,
                    unsigned int    _n,
                    float           _SNRdB,
                    float           _dphi_max,
@@ -74,7 +74,7 @@ int main(int argc, char*argv[])
     unsigned int i;
 
     // arrays
-    float complex seq[k*num_sync_symbols];  // synchronization pattern (samples)
+    _Fcomplex seq[k*num_sync_symbols];  // synchronization pattern (samples)
     float rxy_max[num_trials];
     float dphi_err[num_trials];
     float delay_err[num_trials];
@@ -83,7 +83,7 @@ int main(int argc, char*argv[])
     unsigned int n=0;
     for (i=0; i<num_sync_symbols; i++) {
         float sym = rand() % 2 ? -1.0f : 1.0f;
-        
+
         unsigned int j;
         for (j=0; j<k; j++)
             seq[n++] = sym;
@@ -123,8 +123,8 @@ int main(int argc, char*argv[])
     printf("    rxy_max (average)       :   %12.8f\n", rxy_max_avg);
     printf("    dphi estimate (RMSE)    :   %12.8f\n", dphi_err_rmse);
     printf("    delay estimate (RMSE)   :   %12.8f\n", delay_err_rmse);
-    
-    // 
+
+    //
     // export results
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -155,7 +155,7 @@ int main(int argc, char*argv[])
 }
 
 void bpresync_test(bpresync_cccf   _q,
-                   float complex * _x,
+                   _Fcomplex * _x,
                    unsigned int    _n,
                    float           _SNRdB,
                    float           _dphi_max,
@@ -177,7 +177,7 @@ void bpresync_test(bpresync_cccf   _q,
     firfarrow_crcf fdelay = firfarrow_crcf_create(h_len, order, fc, As);
 
     unsigned int num_samples = _n + max_delay + (h_len-1)/2;
-    float complex y[num_samples];
+    _Fcomplex y[num_samples];
 
     unsigned int t;
     for (t=0; t<_num_trials; t++) {
@@ -227,7 +227,7 @@ void bpresync_test(bpresync_cccf   _q,
         _delay_err[t] = 0.0f;
         for (i=0; i<num_samples; i++) {
             // push through correlator
-            float complex rxy;
+            _Fcomplex rxy;
             float         dphi_est;
             bpresync_cccf_push(_q, y[i]);
             bpresync_cccf_execute(_q, &rxy, &dphi_est);
@@ -264,4 +264,3 @@ void bpresync_test(bpresync_cccf   _q,
     // destroy Farrow filter
     firfarrow_crcf_destroy(fdelay);
 }
-
diff --git a/sandbox/cpmodem_test.c b/sandbox/cpmodem_test.c
index d7961163..60353c7d 100644
--- a/sandbox/cpmodem_test.c
+++ b/sandbox/cpmodem_test.c
@@ -63,13 +63,13 @@ int main(int argc, char*argv[]) {
 
     // generate input
     float dphi[num_samples];        // transmitted instantaneous frequency
-    float complex x[num_samples];   // transmitted signal
-    float complex y[num_samples];   // received signal
+    _Fcomplex x[num_samples];   // transmitted signal
+    _Fcomplex y[num_samples];   // received signal
     float dphi_hat[num_samples];    // received instantaneous frequency
 
     unsigned int n=0;               // sample counter
     unsigned int s;                 // symbol counter
-    unsigned int i;                 // 
+    unsigned int i;                 //
     for (s=0; s<num_symbols; s++) {
         unsigned int symbol = rand() % M;
 
@@ -85,7 +85,7 @@ int main(int argc, char*argv[]) {
             // generate complex sinusoid
             nco_crcf_cexpf(nco_tx, &x[n]);
             nco_crcf_step(nco_tx);
-            
+
             // save frequency
             dphi[n] = f;
             n++;
@@ -99,9 +99,9 @@ int main(int argc, char*argv[]) {
     }
 
     // run loop
-    float complex yn = 0.0f;
+    _Fcomplex yn = 0.0f;
     for (i=0; i<num_samples; i++) {
-        float complex r = y[i] * conjf(yn);
+        _Fcomplex r = y[i] * conjf(yn);
 
         dphi_hat[i] = cargf(r);
 
diff --git a/sandbox/ellip_func_test.c b/sandbox/ellip_func_test.c
index c3a8a840..5f4bbcb0 100644
--- a/sandbox/ellip_func_test.c
+++ b/sandbox/ellip_func_test.c
@@ -12,24 +12,23 @@
 
 int main() {
 
-    float complex u = 0.7f;
+    _Fcomplex u = 0.7f;
     float k = 0.8f;
     unsigned int n=7;
 
-    float complex cd = ellip_cdf(u,k,n);
-    float complex sn = ellip_snf(u,k,n);
+    _Fcomplex cd = ellip_cdf(u,k,n);
+    _Fcomplex sn = ellip_snf(u,k,n);
     printf("u   : %12.8f + j*%12.8f\n", crealf(u), cimagf(u));
     printf("k   : %12.8f\n", k);
     printf("cd  : %12.8f + j*%12.8f\n", crealf(cd), cimagf(cd));
     printf("sn  : %12.8f + j*%12.8f\n", crealf(sn), cimagf(sn));
 
     printf("\n");
-    float complex acd = ellip_acdf(cd,k,n);
-    float complex asn = ellip_asnf(sn,k,n);
+    _Fcomplex acd = ellip_acdf(cd,k,n);
+    _Fcomplex asn = ellip_asnf(sn,k,n);
     printf("acd : %12.8f + j*%12.8f\n", crealf(acd), cimagf(acd));
     printf("asn : %12.8f + j*%12.8f\n", crealf(asn), cimagf(asn));
 
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/ellip_test.c b/sandbox/ellip_test.c
index f84d3685..c892e68e 100644
--- a/sandbox/ellip_test.c
+++ b/sandbox/ellip_test.c
@@ -57,32 +57,31 @@ int main() {
         u[i] = (2.0f*t - 1.0f)/N;
         printf("u[%3u]      : %12.8f\n", i, u[i]);
     }
-    float complex zeta[L];
+    _Fcomplex zeta[L];
     for (i=0; i<L; i++) {
         zeta[i] = ellip_cdf(u[i],k,n);
         printf("zeta[%3u]   : %12.8f + j*%12.8f\n", i, crealf(zeta[i]), cimagf(zeta[i]));
     }
 
     // compute filter zeros
-    float complex za[L];
+    _Fcomplex za[L];
     for (i=0; i<L; i++) {
         za[i] = _Complex_I * Wp / (k*zeta[i]);
         printf("za[%3u]     : %12.8f + j*%12.8f\n", i, crealf(za[i]), cimagf(za[i]));
     }
 
-    float complex v0 = -_Complex_I*ellip_asnf(_Complex_I/ep, k1, n)/N;
+    _Fcomplex v0 = -_Complex_I*ellip_asnf(_Complex_I/ep, k1, n)/N;
     printf("v0          : %12.8f + j*%12.8f\n", crealf(v0), cimagf(v0));
 
-    float complex pa[L];
+    _Fcomplex pa[L];
     for (i=0; i<L; i++) {
         pa[i] = Wp*_Complex_I*ellip_cdf(u[i]-_Complex_I*v0, k, n);
         printf("pa[%3u]     : %12.8f + j*%12.8f\n", i, crealf(pa[i]), cimagf(pa[i]));
     }
-    float complex pa0 = Wp * _Complex_I*ellip_snf(_Complex_I*v0, k, n);
+    _Fcomplex pa0 = Wp * _Complex_I*ellip_snf(_Complex_I*v0, k, n);
     printf("pa0         : %12.8f + j*%12.8f\n", crealf(pa0), cimagf(pa0));
 
 
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/eqlms_cccf_test.c b/sandbox/eqlms_cccf_test.c
index 0f5cad99..1f4af0c7 100644
--- a/sandbox/eqlms_cccf_test.c
+++ b/sandbox/eqlms_cccf_test.c
@@ -1,4 +1,4 @@
-// 
+//
 // eqlms_cccf_test.c
 //
 // Tests least mean-squares (LMS) equalizer (EQ).
@@ -30,10 +30,10 @@ int main() {
     unsigned int num_samples = k*num_symbols;
 
     // data arrays
-    float complex s[num_symbols];   // original QPSK symbols
-    float complex x[num_samples];   // interpolated samples
-    float complex y[num_samples];   // received samples
-    float complex z[num_samples];   // recovered samples
+    _Fcomplex s[num_symbols];   // original QPSK symbols
+    _Fcomplex x[num_samples];   // interpolated samples
+    _Fcomplex y[num_samples];   // received samples
+    _Fcomplex z[num_samples];   // recovered samples
 
     // generate data sequence
     unsigned int i;
@@ -42,7 +42,7 @@ int main() {
                (rand() % 2 ? 1.0f : -1.0f) * _Complex_I;
     }
 
-    // interpolate 
+    // interpolate
     unsigned int h_len = 2*k*m+1;
     float hm[h_len];
 #if 1
@@ -66,7 +66,7 @@ int main() {
     firinterp_crcf_destroy(interp);
 
     // generate channel filter
-    float complex hc[hc_len];
+    _Fcomplex hc[hc_len];
     for (i=0; i<hc_len; i++)
         hc[i] = (i==0) ? 1.0f : 0.1f*randnf()*cexpf(_Complex_I*2*M_PI*randf());
 
@@ -77,11 +77,11 @@ int main() {
         firfilt_cccf_execute(fchannel, &y[i]);
     }
     firfilt_cccf_destroy(fchannel);
-    
+
     // initialize equalizer
 #if 1
     // initialize with delta at center
-    float complex h[p]; // coefficients
+    _Fcomplex h[p]; // coefficients
     unsigned int p0 = (p-1)/2;  // center index
     for (i=0; i<p; i++)
         h[i] = (i==p0) ? 1.0f : 0.0f;
@@ -89,24 +89,24 @@ int main() {
     // initialize with square-root raised cosine
     p = 2*k*m+1;
     float h_tmp[p];
-    float complex h[p];
+    _Fcomplex h[p];
     design_rrc_filter(k,m,beta,0.0f,h_tmp);
     for (i=0; i<p; i++)
         h[i] = h_tmp[i] / k;
 #endif
-    
+
     // run equalizer
-    float complex w0[p];
-    float complex w1[p];
-    memmove(w0, h, p*sizeof(float complex));
+    _Fcomplex w0[p];
+    _Fcomplex w1[p];
+    memmove(w0, h, p*sizeof(_Fcomplex));
     windowcf buffer = windowcf_create(p);
     for (i=0; i<num_samples; i++) {
         // push value into buffer
         windowcf_push(buffer, y[i]);
 
         // compute d_hat
-        float complex d_hat = 0.0f;
-        float complex * r;
+        _Fcomplex d_hat = 0.0f;
+        _Fcomplex * r;
         windowcf_read(buffer, &r);
         unsigned int j;
         for (j=0; j<p; j++)
@@ -122,11 +122,11 @@ int main() {
         if ( (i%k) != 0 ) continue;
 
         // estimate transmitted QPSK symbol
-        float complex d_prime = (crealf(d_hat) > 0.0f ? 1.0f : -1.0f) +
+        _Fcomplex d_prime = (crealf(d_hat) > 0.0f ? 1.0f : -1.0f) +
                                 (cimagf(d_hat) > 0.0f ? 1.0f : -1.0f) * _Complex_I;
 
         // compute error
-        float complex alpha = d_prime - d_hat;
+        _Fcomplex alpha = d_prime - d_hat;
 
         // compute signal energy
         float ex2 = 1.414f;
diff --git a/sandbox/fct_test.c b/sandbox/fct_test.c
index b17d2c7b..72d6930b 100644
--- a/sandbox/fct_test.c
+++ b/sandbox/fct_test.c
@@ -22,10 +22,10 @@ int main() {
     idct(y,z,n);
 
     // run equivalent ffts
-    float complex x0[2*n];
-    float complex y0[2*n];
-    float complex y1[2*n];
-    float complex z0[2*n];
+    _Fcomplex x0[2*n];
+    _Fcomplex y0[2*n];
+    _Fcomplex y1[2*n];
+    _Fcomplex z0[2*n];
 
     // create the plan
     int method = 0;
@@ -44,7 +44,7 @@ int main() {
     for (i=0; i<2*n; i++)
         y1[i] = y0[i]*cexpf(_Complex_I*M_PI*i/(float)(2*n)) / n;
     fft_execute(pr);
-    
+
     // destroy fft plans
     fft_destroy_plan(pf);
     fft_destroy_plan(pr);
@@ -72,4 +72,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/fec_g2412product_test.c b/sandbox/fec_g2412product_test.c
index 9807022b..17c83ddc 100644
--- a/sandbox/fec_g2412product_test.c
+++ b/sandbox/fec_g2412product_test.c
@@ -91,7 +91,7 @@ int main(int argc, char*argv[])
 
         msg_org[i] = p & 1;
         p = ((p << 1) & 0xfe) | liquid_bdotprod(p,0xad);
-        
+
         msg_org[i] = 0;
     }
 
@@ -136,7 +136,7 @@ int main(int argc, char*argv[])
     float nstd  = powf(10.0f, -SNRdB/20.0f);
     modem mod = modem_create(LIQUID_MODEM_BPSK);
     for (i=0; i<576; i++) {
-        float complex v;
+        _Fcomplex v;
         unsigned int  s;
         modem_modulate(mod, msg_enc[i], &v);
         v += nstd*(randnf() + randnf()*_Complex_I) * M_SQRT1_2;
@@ -162,7 +162,7 @@ int main(int argc, char*argv[])
     for (i=0; i<144; i++)
         num_errors += (msg_dec[i] & 1) == (msg_org[i] & 1) ? 0 : 1;
     printf("bit errors: %u / %u\n", num_errors, 144);
-    
+
     // clean up allocated objects
     g2412p_destroy(q);
 
@@ -233,7 +233,7 @@ void g2412p_encode(g2412p          _q,
 #if DEBUG
         printf(" %2u: 0x%.3x > 0x%.6x\n", r, sym_org, sym_enc);
 #endif
-        
+
         //
         for (c=0; c<24; c++) {
             unsigned int bit = (sym_enc >> (24-c-1)) & 1;
@@ -257,7 +257,7 @@ void g2412p_encode(g2412p          _q,
 #if DEBUG
         printf(" %2u: 0x%.3x > 0x%.6x\n", c, sym_org, sym_enc);
 #endif
-        
+
         // append only parity bits (no need to overwrite original bits)
         for (r=12; r<24; r++) {
             unsigned int bit = (sym_enc >> (24-r-1)) & 1;
@@ -292,7 +292,7 @@ void g2412p_decode(g2412p          _q,
     }
     printf("steps: %u\n", i);
 #endif
-    
+
     // print
 #if DEBUG
     g2412p_print(_q);
@@ -338,7 +338,7 @@ int g2412p_iterate(g2412p _q)
     return rc;
 }
 
-// 
+//
 int g2412p_step(g2412p _q)
 {
     // TODO: determine if parity check passed
diff --git a/sandbox/fec_secded_punctured_test.c b/sandbox/fec_secded_punctured_test.c
index 2bc8b5bb..6e4fe691 100644
--- a/sandbox/fec_secded_punctured_test.c
+++ b/sandbox/fec_secded_punctured_test.c
@@ -101,11 +101,11 @@ int main(int argc, char*argv[])
     float SNRdB_step = (SNRdB_max - SNRdB_min) / (num_steps-1);
 
     unsigned int i;
-    
+
     // arrays
     unsigned char m[p];     // original message [64 x 1]
     unsigned char v[p+1];   // encoded/transmitted message
-    float complex y[k];     // received message with noise
+    _Fcomplex y[k];     // received message with noise
     unsigned char r[p+1];   // received vector (hard decision)
     unsigned char m_hat[p]; // estimated original message
 
@@ -204,7 +204,7 @@ int main(int argc, char*argv[])
                 0.5f*erfcf(1.0f/sigma));
     }
 
-    // 
+    //
     // export output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME, "w");
@@ -249,7 +249,7 @@ void secded7264_encode_symbol_punctured(unsigned char * _sym_dec,
                                         unsigned int    _p)
 {
     unsigned int i;
-    
+
     // compute parity
     unsigned char m[8];
     for (i=0; i<8; i++)
@@ -282,4 +282,3 @@ void secded7264_decode_symbol_punctured(unsigned char * _sym_enc,
     for (i=0; i<_p; i++)
         _sym_dec[i] = m_hat[i];
 }
-
diff --git a/sandbox/fec_spc2216_test.c b/sandbox/fec_spc2216_test.c
index bd52600f..a2ebe5da 100644
--- a/sandbox/fec_spc2216_test.c
+++ b/sandbox/fec_spc2216_test.c
@@ -22,7 +22,7 @@
 
 //
 // SEC-DED(22,16) product code test (soft decoding)
-//  ________________ 
+//  ________________
 // [            |   ]
 // [            |   ]
 // [   16 x 16  | 6 ]
@@ -139,7 +139,7 @@ int main(int argc, char*argv[])
 {
     srand(time(NULL));
     unsigned int i;
-    
+
     // error vector
     unsigned char e[61];
 #if 0
@@ -250,7 +250,7 @@ int main(int argc, char*argv[])
     int rc = spc2216_decode_sym_soft(msg_rec_soft, m_hat);
 #endif
 
-    // 
+    //
     // run SNR trials
     //
     float SNRdB_min = -1.0f;                // signal-to-noise ratio (minimum)
@@ -259,7 +259,7 @@ int main(int argc, char*argv[])
     unsigned int num_trials=10000;          // number of trials
 
     // arrays
-    float complex sym_rec[8*61];            // received BPSK symbols
+    _Fcomplex sym_rec[8*61];            // received BPSK symbols
     unsigned int bit_errors_hard[num_snr];
     unsigned int bit_errors_soft[num_snr];
 
@@ -334,7 +334,7 @@ int main(int argc, char*argv[])
                 msg_LLR[i] = (unsigned char) LLR;
             }
             spc2216_decode_soft(msg_LLR, msg_dec_soft);
-            
+
             // tabulate results
             bit_errors_hard[s] += count_bit_errors_array(msg_org, msg_dec_hard, 32);
             bit_errors_soft[s] += count_bit_errors_array(msg_org, msg_dec_soft, 32);
@@ -350,7 +350,7 @@ int main(int argc, char*argv[])
                 bit_errors_soft[s], (float)(bit_errors_soft[s]) / (float)(num_trials*32*8),
                 0.5f*erfcf(1.0f/nstd));
     }
-    // 
+    //
     // export output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME, "w");
@@ -429,7 +429,7 @@ void spc2216_decode(unsigned char * _msg_rec,
     unsigned int i;
     unsigned char sym_enc[3];   // encoded 22-bit message
     unsigned char e_hat[3];     // estimated error vector
-    
+
     // transpose
     spc2216_transpose_row(m_hat, parity_row, w);
 
@@ -511,7 +511,7 @@ void spc2216_decode(unsigned char * _msg_rec,
     }
 
     //printf("number of uncorrected errors: %u\n", num_uncorrected_errors);
-    
+
     // copy decoded message to output
     memmove(_msg_dec, m_hat, 32*sizeof(unsigned char));
 }
@@ -561,14 +561,14 @@ void spc2216_unpack(unsigned char * _v,
     unsigned int i;
     unsigned int k=0;
     for (i=0; i<16; i++) {
-        //liquid_unpack_array(&_pr[k], &_v[32*8+k], 
+        //liquid_unpack_array(&_pr[k], &_v[32*8+k],
         liquid_unpack_array(&_v[32], 29, k, 6, &_pr[i]);
         k += 6;
     }
 
     // unpack column parities
     for (i=0; i<22; i++) {
-        //liquid_unpack_array(&_pr[k], &_v[32*8+k], 
+        //liquid_unpack_array(&_pr[k], &_v[32*8+k],
         liquid_unpack_array(&_v[32], 29, k, 6, &_pc[i]);
         k += 6;
     }
@@ -674,7 +674,7 @@ void spc2216_transpose_block(unsigned char * _m,
         exit(1);
     }
     unsigned int c = _n / 8;    // number of byte columns
-    
+
     unsigned char w0;
     unsigned char w1;
     for (k=0; k<c; k++) {
@@ -697,7 +697,7 @@ void spc2216_transpose_block(unsigned char * _m,
 void spc2216_print_decoded(unsigned char * _m)
 {
     unsigned int i;
-    
+
     for (i=0; i<16; i++) {
         printf("    ");
         print_bitstring(_m[2*i+0],8);
@@ -719,7 +719,7 @@ void spc2216_print_encoded(unsigned char * _v)
     // print unpacked version
 #if 0
     spc2216_print_decoded(m);
-    
+
     unsigned int i;
     printf("rows:\n");
     for (i=0; i<16; i++) {
@@ -744,7 +744,7 @@ void spc2216_print_unpacked(unsigned char * _m,
                             unsigned char * _pc)
 {
     unsigned int i;
-    
+
     for (i=0; i<16; i++) {
         printf("    ");
         print_bitstring(_m[2*i+0],8);
@@ -777,7 +777,7 @@ void spc2216_decode_soft(unsigned char * _msg_rec,
     unsigned char w[256];           // 256 = 16 x 16 bits
     unsigned char parity_row[96];   //  96 = 16 rows @ 6 bits
     unsigned char parity_col[132];  // 132 = 22 cols @ 6 bits
-    
+
     // unpack encoded soft bits:
     memmove(w,           _msg_rec,         256);
     memmove(parity_row, &_msg_rec[256],     96);
@@ -805,7 +805,7 @@ void spc2216_decode_soft(unsigned char * _msg_rec,
     }
 #endif
 
-    // 
+    //
     unsigned char sym_rec[22];  // encoded 22-bit message
     unsigned char sym_dec[22];  // decoded 22-bit message
     int syndrome_flag;
@@ -940,7 +940,7 @@ int spc2216_decode_sym_soft(unsigned char * _msg_rec,
         sym_enc[1] |= _msg_rec[ 6 + i] > 128 ? 1 : 0;
         sym_enc[2] |= _msg_rec[14 + i] > 128 ? 1 : 0;
     }
-        
+
     int syndrome_flag = fec_secded2216_estimate_ehat(sym_enc, e_hat);
 
 #if DEBUG_SPC2216
@@ -964,7 +964,7 @@ int spc2216_decode_sym_soft(unsigned char * _msg_rec,
     sym_enc[0] ^= e_hat[0];
     sym_enc[1] ^= e_hat[1];
     sym_enc[2] ^= e_hat[2];
-    
+
 #if DEBUG_SPC2216
     printf(" output : ");
     print_bitstring(sym_enc[0], 6);
@@ -1001,7 +1001,6 @@ int spc2216_decode_sym_soft(unsigned char * _msg_rec,
         printf("%3u,", _msg_dec[i]);
     printf("\n");
 #endif
-    
+
     return syndrome_flag;
 }
-
diff --git a/sandbox/fecsoft_ber_test.c b/sandbox/fecsoft_ber_test.c
index 3f660824..939746c1 100644
--- a/sandbox/fecsoft_ber_test.c
+++ b/sandbox/fecsoft_ber_test.c
@@ -1,4 +1,4 @@
-// 
+//
 // fecsoft_ber_test.c
 //
 // Simulate error rate using soft vs. hard decoding
@@ -74,7 +74,7 @@ int main(int argc, char *argv[]) {
     float rate = (float)n / (float)n_enc;
     unsigned char msg_org[n];            // original data message
     unsigned char msg_enc[n_enc];        // encoded data message
-    float complex sym_rec[8*n_enc];      // received BPSK symbols
+    _Fcomplex sym_rec[8*n_enc];      // received BPSK symbols
     unsigned char msg_cor_soft[8*n_enc]; // corrupted data message (soft bits)
     unsigned char msg_cor_hard[n_enc];   // corrupted data message (hard bits)
     unsigned char msg_dec_soft[n];       // decoded data message (soft bits)
@@ -92,10 +92,10 @@ int main(int argc, char *argv[]) {
     //
     float SNRdB_step = (SNRdB_max - SNRdB_min) / (num_snr-1);
 
-    // 
+    //
     // start trials
     //
-    
+
     printf("  %8s %8s [%8s] %8s %12s %8s %12s %12s\n",
             "SNR [dB]", "Eb/N0", "trials", "soft", "(BER)", "hard", "(BER)", "uncoded");
     unsigned int s;
@@ -159,7 +159,7 @@ int main(int argc, char *argv[]) {
             // decode
             fec_decode(     q, n, msg_cor_hard, msg_dec_hard);
             fec_decode_soft(q, n, msg_cor_soft, msg_dec_soft);
-            
+
             // tabulate results
             bit_errors_soft[s] += count_bit_errors_array(msg_org, msg_dec_soft, n);
             bit_errors_hard[s] += count_bit_errors_array(msg_org, msg_dec_hard, n);
@@ -178,7 +178,7 @@ int main(int argc, char *argv[]) {
     // clean up objects
     fec_destroy(q);
 
-    // 
+    //
     // export output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME, "w");
@@ -229,4 +229,3 @@ int main(int argc, char *argv[]) {
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/fecsoft_conv_test.c b/sandbox/fecsoft_conv_test.c
index db882d97..e5ecf53c 100644
--- a/sandbox/fecsoft_conv_test.c
+++ b/sandbox/fecsoft_conv_test.c
@@ -1,4 +1,4 @@
-// 
+//
 // sandbox/fecsoft_conv_test.c
 //
 // This script simulates soft vs. hard decoding of convolutional codes.
@@ -74,17 +74,17 @@ int main(int argc, char *argv[]) {
     fec q = fec_create(fs, NULL);
     fec_print(q);
 
-    // 
+    //
     // data arrays
     //
 #if 0
     unsigned int sym_org;       // original symbol
-    float complex sym_enc[7];   // encoded symbol
-    float complex sym_rec[7];   // received symbol
+    _Fcomplex sym_enc[7];   // encoded symbol
+    _Fcomplex sym_rec[7];   // received symbol
 #endif
     unsigned char msg_org[n];           // original message
     unsigned char msg_enc[k];           // encoded message
-    float complex mod_sym[8*k];         // modulated symbols
+    _Fcomplex mod_sym[8*k];         // modulated symbols
     unsigned char msg_rec_soft[8*k];    // received 'soft' bits
     unsigned char msg_rec_hard[8*k];    // received 'hard' bits
     unsigned char msg_dec_soft[n];      // soft-decision decoding
@@ -98,7 +98,7 @@ int main(int argc, char *argv[]) {
     //
     float SNRdB_step = (SNRdB_max - SNRdB_min) / (num_snr-1);
 
-    // 
+    //
     // start trials
     //
 #if 0
@@ -108,7 +108,7 @@ int main(int argc, char *argv[]) {
     fecsoft_hamming74_decode(sym_enc, &sym_dec_soft);
     exit(1);
 #endif
-    
+
     printf("  %8s [%6s] %6s %6s\n", "SNR [dB]", "trials", "soft", "hard");
     unsigned int s;
     for (s=0; s<num_snr; s++) {
@@ -176,7 +176,7 @@ int main(int argc, char *argv[]) {
                 fec_conv_decode_soft(q, n, msg_rec_hard, msg_dec_hard);
                 fec_conv_decode_soft(q, n, msg_rec_soft, msg_dec_soft);
             }
-            
+
             // count bit errors and tabulate results
             bit_errors_hard[s] += count_bit_errors_array(msg_org, msg_dec_hard, n);
             bit_errors_soft[s] += count_bit_errors_array(msg_org, msg_dec_soft, n);
@@ -194,7 +194,7 @@ int main(int argc, char *argv[]) {
     fec_destroy(q);
 
 
-    // 
+    //
     // export output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME, "w");
@@ -260,4 +260,3 @@ void fec_conv_punctured_decode_soft(fec _q,
     printf("fec_conv_punctured_decode_soft(): libfec not installed; this sandbox program won't run\n");
 }
 #endif
-
diff --git a/sandbox/fecsoft_ldpc_test.c b/sandbox/fecsoft_ldpc_test.c
index 29a36bfb..11d57e34 100644
--- a/sandbox/fecsoft_ldpc_test.c
+++ b/sandbox/fecsoft_ldpc_test.c
@@ -72,7 +72,7 @@ int main(int argc, char*argv[])
     // arrays
     unsigned char x[m];     // original message signal
     unsigned char c[n];     // transmitted codeword
-    float complex y[n];     // received message with noise
+    _Fcomplex y[n];     // received message with noise
     float LLR[n];           // log-likelihood ratio
     unsigned char c_hat[n]; // estimated codeword
     unsigned char x_hat[n]; // estimated message signal
@@ -139,7 +139,7 @@ int main(int argc, char*argv[])
     smatrixb_destroy(H);
     smatrixb_destroy(G);
 
-    // 
+    //
     // export output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME, "w");
@@ -177,4 +177,3 @@ int main(int argc, char*argv[])
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/fft_dual_radix_test.c b/sandbox/fft_dual_radix_test.c
index b1afd2cd..b59a84bd 100644
--- a/sandbox/fft_dual_radix_test.c
+++ b/sandbox/fft_dual_radix_test.c
@@ -47,8 +47,8 @@ void usage()
 
 // super slow DFT, but functionally correct
 void dft_run(unsigned int    _nfft,
-             float complex * _x,
-             float complex * _y,
+             _Fcomplex * _x,
+             _Fcomplex * _y,
              int             _dir,
              int             _flags);
 
@@ -82,9 +82,9 @@ int main(int argc, char*argv[]) {
     unsigned int k;
 
     // create and initialize data arrays
-    float complex x[n];
-    float complex y[n];
-    float complex y_test[n];
+    _Fcomplex x[n];
+    _Fcomplex y[n];
+    _Fcomplex y_test[n];
     for (i=0; i<n; i++) {
         //x[i] = randnf() + _Complex_I*randnf();
         x[i] = (float)i + _Complex_I*(3 - (float)i);
@@ -98,12 +98,12 @@ int main(int argc, char*argv[]) {
     //
 
     // compute twiddle factors (roots of unity)
-    float complex twiddle[n];
+    _Fcomplex twiddle[n];
     for (i=0; i<n; i++)
         twiddle[i] = cexpf(-_Complex_I*2*M_PI*(float)i / (float)n);
 
     // temporary buffer
-    float complex t[n];
+    _Fcomplex t[n];
     for (i=0; i<n; i++)
         t[i] = x[i];
 
@@ -122,8 +122,8 @@ int main(int argc, char*argv[]) {
 #endif
 
         // for now, copy to temp buffer, compute FFT, and store result
-        float complex t0[p];
-        float complex t1[p];
+        _Fcomplex t0[p];
+        _Fcomplex t1[p];
         for (k=0; k<p; k++) t0[k] = t[q*k+i];
         dft_run(p, t0, t1, DFT_FORWARD, 0);
         for (k=0; k<p; k++) t[q*k+i] = t1[k];
@@ -141,7 +141,7 @@ int main(int argc, char*argv[]) {
 #if DEBUG
         printf("  i=%3u/%3u\n", i, q);
 #endif
-        for (k=0; k<p; k++) 
+        for (k=0; k<p; k++)
             t[q*k+i] *= twiddle[i*k];
 
 #if DEBUG
@@ -160,10 +160,10 @@ int main(int argc, char*argv[]) {
 #if DEBUG
         printf("  i=%3u/%3u\n", i, p);
 #endif
-        
+
         // for now, copy to temp buffer, compute FFT, and store result
-        float complex t0[q];
-        float complex t1[q];
+        _Fcomplex t0[q];
+        _Fcomplex t1[q];
         for (k=0; k<q; k++) t0[k] = t[q*i+k];
         dft_run(q, t0, t1, DFT_FORWARD, 0);
         for (k=0; k<q; k++) t[q*i+k] = t1[k];
@@ -181,7 +181,7 @@ int main(int argc, char*argv[]) {
         }
     }
 
-    // 
+    //
     // print results
     //
     for (i=0; i<n; i++) {
@@ -205,8 +205,8 @@ int main(int argc, char*argv[]) {
 
 // super slow DFT, but functionally correct
 void dft_run(unsigned int    _nfft,
-             float complex * _x,
-             float complex * _y,
+             _Fcomplex * _x,
+             _Fcomplex * _y,
              int             _dir,
              int             _flags)
 {
@@ -223,4 +223,3 @@ void dft_run(unsigned int    _nfft,
         }
     }
 }
-
diff --git a/sandbox/fft_mixed_radix_test.c b/sandbox/fft_mixed_radix_test.c
index e7a9e028..ca5ae1bd 100644
--- a/sandbox/fft_mixed_radix_test.c
+++ b/sandbox/fft_mixed_radix_test.c
@@ -47,8 +47,8 @@ void usage()
 
 // super slow DFT, but functionally correct
 void dft_run(unsigned int    _nfft,
-             float complex * _x,
-             float complex * _y,
+             _Fcomplex * _x,
+             _Fcomplex * _y,
              int             _dir,
              int             _flags);
 
@@ -62,8 +62,8 @@ void dft_run(unsigned int    _nfft,
 //
 // NOTES : the butterfly decimates in time, storing the output as
 //         contiguous samples in the same buffer.
-void fftmr_bfly(float complex * _x,
-                float complex * _twiddle,
+void fftmr_bfly(_Fcomplex * _x,
+                _Fcomplex * _twiddle,
                 unsigned int    _nfft,
                 unsigned int    _stride,
                 unsigned int    _m,
@@ -74,7 +74,7 @@ void fftmr_bfly(float complex * _x,
 #endif
 
     // create temporary buffer the size of the FFT
-    float complex * x_tmp = (float complex *) malloc(_p*sizeof(float complex));
+    _Fcomplex * x_tmp = (_Fcomplex *) malloc(_p*sizeof(_Fcomplex));
 
     unsigned int i;
     unsigned int k;
@@ -88,14 +88,14 @@ void fftmr_bfly(float complex * _x,
         // copy input to temporary buffer
         for (i=0; i<_p; i++)
             x_tmp[i] = _x[n + i*_m];
-        
+
         // compute DFT, applying appropriate twiddle factors
         unsigned int twiddle_base = n;
         for (i=0; i<_p; i++) {
 #if DEBUG
             printf("      ----\n");
 #endif
-            float complex y = x_tmp[0];
+            _Fcomplex y = x_tmp[0];
             unsigned int twiddle_index = 0;
             for (k=1; k<_p; k++) {
                 twiddle_index = (twiddle_index + _stride*twiddle_base) % _nfft;
@@ -129,9 +129,9 @@ void fftmr_bfly(float complex * _x,
 //  _xstride    :   input buffer stride
 //  _m_vect     :   array of radix values [size: num_factors x 1]
 //  _p_vect     :   array of DFT values [size: num_factors x 1]
-void fftmr_cycle(float complex * _x,
-                 float complex * _y,
-                 float complex * _twiddle,
+void fftmr_cycle(_Fcomplex * _x,
+                 _Fcomplex * _y,
+                 _Fcomplex * _twiddle,
                  unsigned int    _nfft,
                  unsigned int    _xoffset,
                  unsigned int    _xstride,
@@ -145,7 +145,7 @@ void fftmr_cycle(float complex * _x,
     // increment factor pointers
     _m_vect++;
     _p_vect++;
-    
+
 #if DEBUG
     printf("fftmr_cycle:    offset=%3u, stride=%3u, p=%3u, m=%3u\n", _xoffset, _xstride, p, m);
 #endif
@@ -175,7 +175,7 @@ void fftmr_cycle(float complex * _x,
     // run m-point DFT
     fftmr_bfly(_y, _twiddle, _nfft, _xstride, m, p);
 }
-                      
+
 
 int main(int argc, char*argv[]) {
     // transform size
@@ -199,7 +199,7 @@ int main(int argc, char*argv[]) {
 
     unsigned int i;
     unsigned int k;
-    
+
     // find 'prime' factors
     unsigned int n = nfft;
     unsigned int p[MAX_FACTORS];
@@ -231,9 +231,9 @@ int main(int argc, char*argv[]) {
         printf("  p=%3u, m=%3u\n", p[i], m[i]);
 
     // create and initialize data arrays
-    float complex * x      = (float complex *) malloc(nfft * sizeof(float complex));
-    float complex * y      = (float complex *) malloc(nfft * sizeof(float complex));
-    float complex * y_test = (float complex *) malloc(nfft * sizeof(float complex));
+    _Fcomplex * x      = (_Fcomplex *) malloc(nfft * sizeof(_Fcomplex));
+    _Fcomplex * y      = (_Fcomplex *) malloc(nfft * sizeof(_Fcomplex));
+    _Fcomplex * y_test = (_Fcomplex *) malloc(nfft * sizeof(_Fcomplex));
     if (x == NULL || y == NULL || y_test == NULL) {
         fprintf(stderr,"error: %s, not enough memory for allocation\n", argv[0]);
         exit(1);
@@ -248,7 +248,7 @@ int main(int argc, char*argv[]) {
     dft_run(nfft, x, y_test, DFT_FORWARD, 0);
 
     // compute twiddle factors (roots of unity)
-    float complex * twiddle = (float complex *) malloc(nfft * sizeof(float complex));
+    _Fcomplex * twiddle = (_Fcomplex *) malloc(nfft * sizeof(_Fcomplex));
     if (x == NULL || y == NULL || y_test == NULL) {
         fprintf(stderr,"error: %s, not enough memory for twiddle factors\n", argv[0]);
         exit(1);
@@ -259,7 +259,7 @@ int main(int argc, char*argv[]) {
     // call mixed-radix function
     fftmr_cycle(x, y, twiddle, nfft, 0, 1, m, p);
 
-    // 
+    //
     // print results
     //
     for (i=0; i<nfft; i++) {
@@ -289,8 +289,8 @@ int main(int argc, char*argv[]) {
 
 // super slow DFT, but functionally correct
 void dft_run(unsigned int    _nfft,
-             float complex * _x,
-             float complex * _y,
+             _Fcomplex * _x,
+             _Fcomplex * _y,
              int             _dir,
              int             _flags)
 {
@@ -307,4 +307,3 @@ void dft_run(unsigned int    _nfft,
         }
     }
 }
-
diff --git a/sandbox/fft_rader_prime_radix2_test.c b/sandbox/fft_rader_prime_radix2_test.c
index 24294b60..eff02fd2 100644
--- a/sandbox/fft_rader_prime_radix2_test.c
+++ b/sandbox/fft_rader_prime_radix2_test.c
@@ -54,8 +54,8 @@ void usage()
 
 // super slow DFT, but functionally correct
 void dft_run(unsigned int    _nfft,
-             float complex * _x,
-             float complex * _y,
+             _Fcomplex * _x,
+             _Fcomplex * _y,
              int             _dir,
              int             _flags);
 
@@ -93,9 +93,9 @@ int main(int argc, char*argv[]) {
     unsigned int i;
 
     // create and initialize data arrays
-    float complex * x      = (float complex *) malloc(nfft * sizeof(float complex));
-    float complex * y      = (float complex *) malloc(nfft * sizeof(float complex));
-    float complex * y_test = (float complex *) malloc(nfft * sizeof(float complex));
+    _Fcomplex * x      = (_Fcomplex *) malloc(nfft * sizeof(_Fcomplex));
+    _Fcomplex * y      = (_Fcomplex *) malloc(nfft * sizeof(_Fcomplex));
+    _Fcomplex * y_test = (_Fcomplex *) malloc(nfft * sizeof(_Fcomplex));
     if (x == NULL || y == NULL || y_test == NULL) {
         fprintf(stderr,"error: %s, not enough memory for allocation\n", argv[0]);
         exit(1);
@@ -109,7 +109,7 @@ int main(int argc, char*argv[]) {
     // compute output for testing
     dft_run(nfft, x, y_test, DFT_FORWARD, 0);
 
-    // 
+    //
     // run Rader's algorithm
     //
 
@@ -193,8 +193,8 @@ int main(int argc, char*argv[]) {
     // compute DFT of sequence { exp(-j*2*pi*g^i/nfft }, size: nfft_prime
     // NOTE: R[0] = -1, |R[k]| = sqrt(nfft) for k != 0
     // NOTE: R can be pre-computed
-    float complex * r = (float complex*)malloc((nfft_prime)*sizeof(float complex));
-    float complex * R = (float complex*)malloc((nfft_prime)*sizeof(float complex));
+    _Fcomplex * r = (_Fcomplex*)malloc((nfft_prime)*sizeof(_Fcomplex));
+    _Fcomplex * R = (_Fcomplex*)malloc((nfft_prime)*sizeof(_Fcomplex));
     for (i=0; i<nfft_prime; i++)
         r[i] = cexpf(-_Complex_I*2*M_PI*s[i%(nfft-1)]/(float)(nfft));
     dft_run(nfft_prime, r, R, DFT_FORWARD, 0);
@@ -205,8 +205,8 @@ int main(int argc, char*argv[]) {
 
     // compute nfft_prime-length DFT of permuted sequence with
     // nfft_prime-nfft+1 zeros inserted after first element
-    float complex * xp = (float complex*)malloc((nfft_prime)*sizeof(float complex));
-    float complex * Xp = (float complex*)malloc((nfft_prime)*sizeof(float complex));
+    _Fcomplex * xp = (_Fcomplex*)malloc((nfft_prime)*sizeof(_Fcomplex));
+    _Fcomplex * Xp = (_Fcomplex*)malloc((nfft_prime)*sizeof(_Fcomplex));
     xp[0] = x[ s[nfft-2] ];
     for (i=0; i<nfft_prime-nfft+1; i++)
         xp[i+1] = 0.0f;
@@ -247,7 +247,7 @@ int main(int argc, char*argv[]) {
     free(Xp);
     free(s);
 
-    // 
+    //
     // print results
     //
     for (i=0; i<nfft; i++) {
@@ -276,8 +276,8 @@ int main(int argc, char*argv[]) {
 
 // super slow DFT, but functionally correct
 void dft_run(unsigned int    _nfft,
-             float complex * _x,
-             float complex * _y,
+             _Fcomplex * _x,
+             _Fcomplex * _y,
              int             _dir,
              int             _flags)
 {
@@ -383,4 +383,3 @@ unsigned int modpow(unsigned int _base,
 
     return c;
 }
-
diff --git a/sandbox/fft_rader_prime_test.c b/sandbox/fft_rader_prime_test.c
index b200beac..28306b43 100644
--- a/sandbox/fft_rader_prime_test.c
+++ b/sandbox/fft_rader_prime_test.c
@@ -52,8 +52,8 @@ void usage()
 
 // super slow DFT, but functionally correct
 void dft_run(unsigned int    _nfft,
-             float complex * _x,
-             float complex * _y,
+             _Fcomplex * _x,
+             _Fcomplex * _y,
              int             _dir,
              int             _flags);
 
@@ -91,9 +91,9 @@ int main(int argc, char*argv[]) {
     unsigned int i;
 
     // create and initialize data arrays
-    float complex * x      = (float complex *) malloc(nfft * sizeof(float complex));
-    float complex * y      = (float complex *) malloc(nfft * sizeof(float complex));
-    float complex * y_test = (float complex *) malloc(nfft * sizeof(float complex));
+    _Fcomplex * x      = (_Fcomplex *) malloc(nfft * sizeof(_Fcomplex));
+    _Fcomplex * y      = (_Fcomplex *) malloc(nfft * sizeof(_Fcomplex));
+    _Fcomplex * y_test = (_Fcomplex *) malloc(nfft * sizeof(_Fcomplex));
     if (x == NULL || y == NULL || y_test == NULL) {
         fprintf(stderr,"error: %s, not enough memory for allocation\n", argv[0]);
         exit(1);
@@ -107,7 +107,7 @@ int main(int argc, char*argv[]) {
     // compute output for testing
     dft_run(nfft, x, y_test, DFT_FORWARD, 0);
 
-    // 
+    //
     // run Rader's algorithm
     //
 
@@ -131,15 +131,15 @@ int main(int argc, char*argv[]) {
     // compute DFT of sequence { exp(-j*2*pi*g^i/nfft }, size: nfft-1
     // NOTE: R[0] = -1, |R[k]| = sqrt(nfft) for k != 0
     // NOTE: R can be pre-computed
-    float complex * r = (float complex*)malloc((nfft-1)*sizeof(float complex));
-    float complex * R = (float complex*)malloc((nfft-1)*sizeof(float complex));
+    _Fcomplex * r = (_Fcomplex*)malloc((nfft-1)*sizeof(_Fcomplex));
+    _Fcomplex * R = (_Fcomplex*)malloc((nfft-1)*sizeof(_Fcomplex));
     for (i=0; i<nfft-1; i++)
         r[i] = cexpf(-_Complex_I*2*M_PI*s[i]/(float)(nfft));
     dft_run(nfft-1, r, R, DFT_FORWARD, 0);
 
     // compute DFT of permuted sequence, size: nfft-1
-    float complex * xp = (float complex*)malloc((nfft-1)*sizeof(float complex));
-    float complex * Xp = (float complex*)malloc((nfft-1)*sizeof(float complex));
+    _Fcomplex * xp = (_Fcomplex*)malloc((nfft-1)*sizeof(_Fcomplex));
+    _Fcomplex * Xp = (_Fcomplex*)malloc((nfft-1)*sizeof(_Fcomplex));
     for (i=0; i<nfft-1; i++) {
         // reverse sequence
         unsigned int k = s[nfft-1-i-1];
@@ -171,7 +171,7 @@ int main(int argc, char*argv[]) {
     free(Xp);
     free(s);
 
-    // 
+    //
     // print results
     //
     for (i=0; i<nfft; i++) {
@@ -200,8 +200,8 @@ int main(int argc, char*argv[]) {
 
 // super slow DFT, but functionally correct
 void dft_run(unsigned int    _nfft,
-             float complex * _x,
-             float complex * _y,
+             _Fcomplex * _x,
+             _Fcomplex * _y,
              int             _dir,
              int             _flags)
 {
@@ -307,4 +307,3 @@ unsigned int modpow(unsigned int _base,
 
     return c;
 }
-
diff --git a/sandbox/fft_recursive_test.c b/sandbox/fft_recursive_test.c
index 1c07bb37..8c9884e1 100644
--- a/sandbox/fft_recursive_test.c
+++ b/sandbox/fft_recursive_test.c
@@ -48,14 +48,14 @@ void usage()
 
 // recursive FFT algorithm
 void fft_recursion(unsigned int    _nfft,
-                   float complex * _x,
-                   float complex * _y,
+                   _Fcomplex * _x,
+                   _Fcomplex * _y,
                    int             _dir);
 
 // super slow DFT, but functionally correct
 void dft_run(unsigned int    _nfft,
-             float complex * _x,
-             float complex * _y,
+             _Fcomplex * _x,
+             _Fcomplex * _y,
              int             _dir);
 
 int main(int argc, char*argv[])
@@ -82,9 +82,9 @@ int main(int argc, char*argv[])
     unsigned int i;
 
     // create and initialize data arrays
-    float complex x[nfft];
-    float complex y[nfft];
-    float complex y_test[nfft];
+    _Fcomplex x[nfft];
+    _Fcomplex y[nfft];
+    _Fcomplex y_test[nfft];
     for (i=0; i<nfft; i++) {
         //x[i] = randnf() + _Complex_I*randnf();
         x[i] = (float)i + _Complex_I*(3 - (float)i);
@@ -106,7 +106,7 @@ int main(int argc, char*argv[])
     printf("running recursion...\n");
     fft_recursion(nfft, x, y, DFT_FORWARD);
 
-    // 
+    //
     // print results
     //
     for (i=0; i<nfft; i++) {
@@ -130,8 +130,8 @@ int main(int argc, char*argv[])
 
 // recursive...
 void fft_recursion(unsigned int    _nfft,
-                   float complex * _x,
-                   float complex * _y,
+                   _Fcomplex * _x,
+                   _Fcomplex * _y,
                    int             _dir)
 {
     // determine if _nfft is divisible by ...
@@ -158,7 +158,7 @@ void fft_recursion(unsigned int    _nfft,
     unsigned int k;
 
     // initialize twiddle factors
-    float complex twiddle[_nfft];
+    _Fcomplex twiddle[_nfft];
     float d = _dir == DFT_FORWARD ? -1.0f : 1.0f;
     for (i=0; i<_nfft; i++)
         twiddle[i] = cexpf(d*_Complex_I*2*M_PI*(float)i/(float)_nfft);
@@ -169,8 +169,8 @@ void fft_recursion(unsigned int    _nfft,
 #endif
     for (i=0; i<q; i++) {
         // copy to temp buffer, compute FFT, return result
-        float complex t0[p];
-        float complex t1[p];
+        _Fcomplex t0[p];
+        _Fcomplex t1[p];
 
         // copy to temporary buffer
         for (k=0; k<p; k++)
@@ -196,8 +196,8 @@ void fft_recursion(unsigned int    _nfft,
 #endif
     for (i=0; i<p; i++) {
         // copy to temp buffer...
-        float complex t0[q];
-        float complex t1[q];
+        _Fcomplex t0[q];
+        _Fcomplex t1[q];
 
         for (k=0; k<q; k++)
             t0[k] = _x[q*i+k];
@@ -208,7 +208,7 @@ void fft_recursion(unsigned int    _nfft,
         for (k=0; k<q; k++)
             _y[k*p+i] = t1[k];
             //_x[q*i+k] = t1[k];
-        
+
 #if DEBUG
         printf("i=%3u/%3u\n", i, p);
         for (k=0; k<q; k++)
@@ -219,8 +219,8 @@ void fft_recursion(unsigned int    _nfft,
 
 // super slow DFT, but functionally correct
 void dft_run(unsigned int    _nfft,
-             float complex * _x,
-             float complex * _y,
+             _Fcomplex * _x,
+             _Fcomplex * _y,
              int             _dir)
 {
     unsigned int i;
@@ -236,4 +236,3 @@ void dft_run(unsigned int    _nfft,
         }
     }
 }
-
diff --git a/sandbox/firdes_fexp_test.c b/sandbox/firdes_fexp_test.c
index 5c435b88..2edf1fff 100644
--- a/sandbox/firdes_fexp_test.c
+++ b/sandbox/firdes_fexp_test.c
@@ -96,8 +96,8 @@ int main(int argc, char*argv[]) {
     //
 
     float H_prime[h_len];           // frequency response of Nyquist filter
-    float complex h_tx[h_len];      // impulse response of square-root Nyquist filter
-    float complex H_tx[h_len];      // frequency response of square-root Nyquist filter
+    _Fcomplex h_tx[h_len];      // impulse response of square-root Nyquist filter
+    _Fcomplex H_tx[h_len];      // frequency response of square-root Nyquist filter
 
     // compute frequency response of Nyquist filter
     for (i=0; i<h_len; i++) {
@@ -145,9 +145,9 @@ int main(int argc, char*argv[]) {
     isi_rms = sqrtf(isi_rms / (float)(2*m-1));
     printf("\n");
     printf("ISI (RMS) = %12.8f dB\n", 20*log10f(isi_rms));
-    
 
-    // 
+
+    //
     // export output file
     //
     FILE*fid = fopen(OUTPUT_FILENAME,"w");
@@ -167,7 +167,7 @@ int main(int argc, char*argv[]) {
     // print results
     for (i=0; i<h_len; i++)   fprintf(fid,"ht(%3u) = %12.4e;\n", i+1, ht[i]);
     for (i=0; i<h_len; i++)   fprintf(fid,"hr(%3u) = %12.4e;\n", i+1, hr[i]);
-    
+
     fprintf(fid,"hc = k*conv(ht,hr);\n");
 
     // plot results
@@ -243,4 +243,3 @@ float firdes_freqresponse_fexp(float _f,
 
     return 0.0f;
 }
-
diff --git a/sandbox/firdes_gmskrx_test.c b/sandbox/firdes_gmskrx_test.c
index 4df49ea3..9c55bc09 100644
--- a/sandbox/firdes_gmskrx_test.c
+++ b/sandbox/firdes_gmskrx_test.c
@@ -84,17 +84,17 @@ int main(int argc, char*argv[]) {
 
     // temporary arrays
     float h_primef[h_len];          // temporary buffer for real coefficients
-    float g_primef[h_len];          // 
-
-    float complex h_tx[h_len];      // impulse response of transmit filter
-    float complex h_prime[h_len];   // impulse response of 'prototype' filter
-    float complex g_prime[h_len];   // impulse response of 'gain' filter
-    float complex h_hat[h_len];     // impulse response of receive filter
-    
-    float complex H_tx[h_len];      // frequency response of transmit filter
-    float complex H_prime[h_len];   // frequency response of 'prototype' filter
-    float complex G_prime[h_len];   // frequency response of 'gain' filter
-    float complex H_hat[h_len];     // frequency response of receive filter
+    float g_primef[h_len];          //
+
+    _Fcomplex h_tx[h_len];      // impulse response of transmit filter
+    _Fcomplex h_prime[h_len];   // impulse response of 'prototype' filter
+    _Fcomplex g_prime[h_len];   // impulse response of 'gain' filter
+    _Fcomplex h_hat[h_len];     // impulse response of receive filter
+
+    _Fcomplex H_tx[h_len];      // frequency response of transmit filter
+    _Fcomplex H_prime[h_len];   // frequency response of 'prototype' filter
+    _Fcomplex G_prime[h_len];   // frequency response of 'gain' filter
+    _Fcomplex H_hat[h_len];     // frequency response of receive filter
 
     // create 'prototype' matched filter
     // for now use raised-cosine
@@ -170,9 +170,9 @@ int main(int argc, char*argv[]) {
     isi_rms = sqrtf(isi_rms / (float)(2*m-1));
     printf("\n");
     printf("ISI (RMS) = %12.8f dB\n", 20*log10f(isi_rms));
-    
 
-    // 
+
+    //
     // export output file
     //
     FILE*fid = fopen(OUTPUT_FILENAME,"w");
@@ -193,7 +193,7 @@ int main(int argc, char*argv[]) {
     for (i=0; i<h_len; i++)   fprintf(fid,"ht(%3u) = %12.4e;\n", i+1, ht[i] / k);
     for (i=0; i<h_len; i++)   fprintf(fid,"hr(%3u) = %12.4e;\n", i+1, hr[i] * k);
     for (i=0; i<h_len; i++)   fprintf(fid,"hp(%3u) = %12.4e;\n", i+1, h_primef[i]);
-    
+
     fprintf(fid,"hc = k*conv(ht,hr);\n");
 
     // plot results
@@ -240,4 +240,3 @@ int main(int argc, char*argv[]) {
 
     return 0;
 }
-
diff --git a/sandbox/firpfbch2_analysis_equivalence_test.c b/sandbox/firpfbch2_analysis_equivalence_test.c
index fcac0fec..97d6844c 100644
--- a/sandbox/firpfbch2_analysis_equivalence_test.c
+++ b/sandbox/firpfbch2_analysis_equivalence_test.c
@@ -99,17 +99,17 @@ int main(int argc, char*argv[])
     }
 
     // generate DFT object
-    float complex x[num_channels];  // time-domain buffer
-    float complex X[num_channels];  // freq-domain buffer
+    _Fcomplex x[num_channels];  // time-domain buffer
+    _Fcomplex X[num_channels];  // freq-domain buffer
 #if 1
     fftplan fft = fft_create_plan(num_channels, X, x, LIQUID_FFT_BACKWARD, 0);
 #else
     fftplan fft = fft_create_plan(num_channels, X, x, LIQUID_FFT_FORWARD, 0);
 #endif
 
-    float complex y[num_samples];                   // time-domain input
-    float complex Y0[2*num_symbols][num_channels];  // channelizer output
-    float complex Y1[2*num_symbols][num_channels];  // conventional output
+    _Fcomplex y[num_samples];                   // time-domain input
+    _Fcomplex Y0[2*num_symbols][num_channels];  // channelizer output
+    _Fcomplex Y1[2*num_symbols][num_channels];  // conventional output
 
     // generate input sequence
     for (i=0; i<num_samples; i++) {
@@ -119,7 +119,7 @@ int main(int argc, char*argv[])
         printf("y[%3u] = %12.8f + %12.8fj\n", i, crealf(y[i]), cimagf(y[i]));
     }
 
-    // 
+    //
     // run analysis filter bank
     //
 #if 0
@@ -127,8 +127,8 @@ int main(int argc, char*argv[])
 #else
     unsigned int filter_index = num_channels/2-1;
 #endif
-    float complex y_hat;    // input sample
-    float complex * r;      // buffer read pointer
+    _Fcomplex y_hat;    // input sample
+    _Fcomplex * r;      // buffer read pointer
     int toggle = 0;         // flag indicating buffer/filter alignment
 
     //
@@ -181,7 +181,7 @@ int main(int argc, char*argv[])
     fft_destroy_plan(fft);
 
 
-    // 
+    //
     // run traditional down-converter (inefficient)
     //
     // generate filter object
@@ -239,11 +239,11 @@ int main(int argc, char*argv[])
         printf("\n");
     }
 
-    // 
+    //
     // compare results
-    // 
+    //
     float mse[num_channels];
-    float complex d;
+    _Fcomplex d;
     for (i=0; i<num_channels; i++) {
         mse[i] = 0.0f;
         for (j=0; j<2*num_symbols; j++) {
@@ -264,4 +264,3 @@ int main(int argc, char*argv[])
     return 0;
 
 }
-
diff --git a/sandbox/firpfbch2_test.c b/sandbox/firpfbch2_test.c
index 8794c5d2..96592667 100644
--- a/sandbox/firpfbch2_test.c
+++ b/sandbox/firpfbch2_test.c
@@ -113,17 +113,17 @@ int main(int argc, char*argv[])
     }
 
     // generate DFT object
-    float complex x[num_channels];  // time-domain buffer
-    float complex X[num_channels];  // freq-domain buffer
+    _Fcomplex x[num_channels];  // time-domain buffer
+    _Fcomplex X[num_channels];  // freq-domain buffer
 #if 1
     fftplan fft = fft_create_plan(num_channels, X, x, LIQUID_FFT_BACKWARD, 0);
 #else
     fftplan fft = fft_create_plan(num_channels, X, x, LIQUID_FFT_FORWARD, 0);
 #endif
 
-    float complex y[num_samples];                   // time-domain input
-    float complex Y0[2*num_symbols][num_channels];  // channelizer output
-    float complex z[num_samples];                   // time-domain output
+    _Fcomplex y[num_samples];                   // time-domain input
+    _Fcomplex Y0[2*num_symbols][num_channels];  // channelizer output
+    _Fcomplex z[num_samples];                   // time-domain output
 
     // generate input sequence
     for (i=0; i<num_samples; i++) {
@@ -134,11 +134,11 @@ int main(int argc, char*argv[])
         printf("y[%3u] = %12.8f + %12.8fj\n", i, crealf(y[i]), cimagf(y[i]));
     }
 
-    // 
+    //
     // run analysis filter bank
     //
-    float complex y_hat;    // input sample
-    float complex * r;      // buffer read pointer
+    _Fcomplex y_hat;    // input sample
+    _Fcomplex * r;      // buffer read pointer
     int toggle = 0;         // flag indicating buffer/filter alignment
 
     //
@@ -282,8 +282,8 @@ int main(int argc, char*argv[])
 #else
     fft = fft_create_plan(num_channels, X, x, LIQUID_FFT_FORWARD, 0);
 #endif
-    
-    // 
+
+    //
     // run synthesis filter bank
     //
     toggle = 0;
@@ -317,10 +317,10 @@ int main(int argc, char*argv[])
             windowcf_push(buffer[j], x[j]);
 
         // compute filter outputs
-        float complex * r0;
-        float complex * r1;
-        float complex z0;
-        float complex z1;
+        _Fcomplex * r0;
+        _Fcomplex * r1;
+        _Fcomplex z0;
+        _Fcomplex z1;
         for (j=0; j<num_channels/2; j++) {
             // buffer index
             unsigned int b = (toggle == 0) ? j : j+num_channels/2;
@@ -329,8 +329,8 @@ int main(int argc, char*argv[])
             windowcf_read(w1[b], &r1);
 
             // buffer pointers
-            float complex * p0 = toggle ? r0 : r1;
-            float complex * p1 = toggle ? r1 : r0;
+            _Fcomplex * p0 = toggle ? r0 : r1;
+            _Fcomplex * p1 = toggle ? r1 : r0;
 
 #if DEBUG
             // plot registers
@@ -357,7 +357,7 @@ int main(int argc, char*argv[])
         toggle = 1-toggle;
     }
     assert( n == num_samples );
-    
+
     // print output
     printf("\n");
     printf("filterbank synthesizer:\n");
@@ -377,4 +377,3 @@ int main(int argc, char*argv[])
     return 0;
 
 }
-
diff --git a/sandbox/firpfbch_analysis_alignment_test.c b/sandbox/firpfbch_analysis_alignment_test.c
index 857a0a34..9fd2ebe3 100644
--- a/sandbox/firpfbch_analysis_alignment_test.c
+++ b/sandbox/firpfbch_analysis_alignment_test.c
@@ -14,11 +14,11 @@
 // forward declaration of internal methods
 
 void firpfbch_crcf_analyzer_push(firpfbch_crcf _q,
-                                 float complex _x);
+                                 _Fcomplex _x);
 
 void firpfbch_crcf_analyzer_run(firpfbch_crcf   _q,
                                 unsigned int    _k,
-                                float complex * _X);
+                                _Fcomplex * _X);
 
 int main() {
     // options
@@ -34,9 +34,9 @@ int main() {
     unsigned int num_samples = num_channels * num_frames;   // total number of samples
 
     // data arrays
-    float complex x[num_samples];
-    float complex Y0[num_frames][num_channels];
-    float complex Y1[num_frames][num_channels];
+    _Fcomplex x[num_samples];
+    _Fcomplex Y0[num_frames][num_channels];
+    _Fcomplex Y1[num_frames][num_channels];
 
     // create analyzer objects
     firpfbch_crcf ca0 = firpfbch_crcf_create_rnyquist(LIQUID_ANALYZER, num_channels, m, beta, ftype);
@@ -51,7 +51,7 @@ int main() {
 
     // push several dummy samples into first analyzer (emulates
     // timing offset)
-    float complex x_hat;
+    _Fcomplex x_hat;
     for (i=0; i<delay; i++) {
         x_hat = randnf()*cexpf(_Complex_I*2*M_PI*randf());
 
@@ -102,12 +102,12 @@ int main() {
     }
 
 
-    // 
+    //
     // compare results
     //
 
     float mse[num_channels];
-    float complex d;
+    _Fcomplex d;
     for (i=0; i<num_channels; i++) {
         mse[i] = 0.0f;
 
@@ -145,4 +145,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/firpfbch_analysis_equivalence_test.c b/sandbox/firpfbch_analysis_equivalence_test.c
index ec48c8fc..eb43dc2d 100644
--- a/sandbox/firpfbch_analysis_equivalence_test.c
+++ b/sandbox/firpfbch_analysis_equivalence_test.c
@@ -69,8 +69,8 @@ int main() {
     }
 
     // generate DFT object
-    float complex x[num_channels];  // time-domain buffer
-    float complex X[num_channels];  // freq-domain buffer
+    _Fcomplex x[num_channels];  // time-domain buffer
+    _Fcomplex X[num_channels];  // freq-domain buffer
 #if 0
     fftplan fft = fft_create_plan(num_channels, X, x, LIQUID_FFT_BACKWARD, 0);
 #else
@@ -80,15 +80,15 @@ int main() {
     // generate filter object
     firfilt_crcf f = firfilt_crcf_create(h, h_len);
 
-    float complex y[num_samples];                   // time-domain input
-    float complex Y0[num_symbols][num_channels];    // channelized output
-    float complex Y1[num_symbols][num_channels];    // channelized output
+    _Fcomplex y[num_samples];                   // time-domain input
+    _Fcomplex Y0[num_symbols][num_channels];    // channelized output
+    _Fcomplex Y1[num_symbols][num_channels];    // channelized output
 
     // generate input sequence (complex noise)
     for (i=0; i<num_samples; i++)
         y[i] = randnf() * cexpf(_Complex_I*randf()*2*M_PI);
 
-    // 
+    //
     // run analysis filter bank
     //
 #if 0
@@ -96,8 +96,8 @@ int main() {
 #else
     unsigned int filter_index = num_channels-1;
 #endif
-    float complex y_hat;    // input sample
-    float complex * r;      // read pointer
+    _Fcomplex y_hat;    // input sample
+    _Fcomplex * r;      // read pointer
     for (i=0; i<num_symbols; i++) {
 
         // load buffers
@@ -128,7 +128,7 @@ int main() {
             Y0[i][j] = x[j];
     }
 
-    // 
+    //
     // run traditional down-converter (inefficient)
     //
     float dphi; // carrier frequency
@@ -190,11 +190,11 @@ int main() {
         printf("\n");
     }
 
-    // 
+    //
     // compare results
-    // 
+    //
     float mse[num_channels];
-    float complex d;
+    _Fcomplex d;
     for (i=0; i<num_channels; i++) {
         mse[i] = 0.0f;
         for (j=0; j<num_symbols; j++) {
@@ -214,4 +214,3 @@ int main() {
     return 0;
 
 }
-
diff --git a/sandbox/firpfbch_analysis_test.c b/sandbox/firpfbch_analysis_test.c
index 5519e860..d6cb205f 100644
--- a/sandbox/firpfbch_analysis_test.c
+++ b/sandbox/firpfbch_analysis_test.c
@@ -19,13 +19,13 @@ int main() {
     firpfbch ca1 = firpfbch_create(num_channels, m, As, 0, FIRPFBCH_NYQUIST, 0);
 
     unsigned int i, j;
-    float complex x[num_channels];  // time-domain input
-    float complex y0[num_channels]; // channelized output
-    float complex y1[num_channels]; // channelized output
+    _Fcomplex x[num_channels];  // time-domain input
+    _Fcomplex y0[num_channels]; // channelized output
+    _Fcomplex y1[num_channels]; // channelized output
 
 #if 0
     // push samples channelizer 1
-    float complex x_hat;
+    _Fcomplex x_hat;
     for (i=0; i<delay; i++) {
         // generate random sample
         x_hat = randnf() * cexpf(_Complex_I*randf()*2*M_PI);
@@ -48,14 +48,14 @@ int main() {
         for (j=0; j<num_channels; j++)
             x[j] = randnf() * cexpf(_Complex_I*randf()*2*M_PI);
 
-        // 
+        //
         // analyzer 0 : run individual sample exection
         //
 
         // push samples into channelizer 1
         for (j=0; j<num_channels; j++) {
             firpfbch_analyzer_push(ca0, x[j]);
-    
+
             // run analyzer every time, just for kicks
             firpfbch_analyzer_run(ca0, y0);
         }
@@ -67,8 +67,8 @@ int main() {
 
         // save run state ONLY at the appropriate time
         firpfbch_analyzer_saverunstate(ca0);
-        
-        // 
+
+        //
         // analyzer 1 : run regular execution
         //
         firpfbch_analyzer_execute(ca1, x, y1);
@@ -82,12 +82,12 @@ int main() {
                     cimagf(y1[j]));
         }
 
-        // 
+        //
         // compare result
-        // 
+        //
         float mse = 0.0f;
         for (j=0; j<num_channels; j++) {
-            float complex d = y0[j] - y1[j];
+            _Fcomplex d = y0[j] - y1[j];
             mse += crealf( d*conjf(d) );
         }
         mse /= num_channels;
@@ -101,4 +101,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/firpfbch_synthesis_equivalence_test.c b/sandbox/firpfbch_synthesis_equivalence_test.c
index 7ec89c41..8810e9ef 100644
--- a/sandbox/firpfbch_synthesis_equivalence_test.c
+++ b/sandbox/firpfbch_synthesis_equivalence_test.c
@@ -69,8 +69,8 @@ int main() {
     }
 
     // generate inverse DFT object
-    float complex x[num_channels];  // time-domain buffer
-    float complex X[num_channels];  // freq-domain buffer
+    _Fcomplex x[num_channels];  // time-domain buffer
+    _Fcomplex X[num_channels];  // freq-domain buffer
 #if 1
     fftplan ifft = fft_create_plan(num_channels, X, x, LIQUID_FFT_BACKWARD, 0);
 #else
@@ -80,9 +80,9 @@ int main() {
     // generate filter object
     firfilt_crcf f = firfilt_crcf_create(h, h_len);
 
-    float complex Y[num_symbols][num_channels];     // channelized input
-    float complex y0[num_samples];                  // time-domain output
-    float complex y1[num_samples];                  // time-domain output
+    _Fcomplex Y[num_symbols][num_channels];     // channelized input
+    _Fcomplex y0[num_samples];                  // time-domain output
+    _Fcomplex y1[num_samples];                  // time-domain output
 
     // generate input sequence (complex noise)
     for (i=0; i<num_symbols; i++) {
@@ -95,11 +95,11 @@ int main() {
 #endif
     }
 
-    // 
+    //
     // run synthesis filter bank
     //
 
-    float complex * r;      // read pointer
+    _Fcomplex * r;      // read pointer
     for (i=0; i<num_symbols; i++) {
 
         // load buffers
@@ -121,7 +121,7 @@ int main() {
         }
     }
 
-    // 
+    //
     // run traditional up-converter (inefficient)
     //
 
@@ -131,7 +131,7 @@ int main() {
 
     unsigned int n;
     float dphi; // carrier frequency
-    float complex y_hat;
+    _Fcomplex y_hat;
     for (i=0; i<num_channels; i++) {
         // reset filter
         firfilt_crcf_reset(f);
@@ -170,7 +170,7 @@ int main() {
     firfilt_crcf_destroy(f);
 
 
-    // 
+    //
     // print channelizer outputs
     //
     printf("\n");
@@ -183,11 +183,11 @@ int main() {
     }
 
 
-    // 
+    //
     // compare results
-    // 
+    //
     float mse = 0.0f;
-    float complex d;
+    _Fcomplex d;
     for (i=0; i<num_samples; i++) {
         d = y0[i] - y1[i];
         mse += crealf(d*conjf(d));
@@ -200,4 +200,3 @@ int main() {
     return 0;
 
 }
-
diff --git a/sandbox/fskcorr_test.c b/sandbox/fskcorr_test.c
index 47f65840..d81b8c05 100644
--- a/sandbox/fskcorr_test.c
+++ b/sandbox/fskcorr_test.c
@@ -1,4 +1,4 @@
-// 
+//
 // fskcorr_test.c
 //
 // This example tests detection of FSK sequences.
@@ -57,10 +57,10 @@ int main(int argc, char*argv[])
     float xcorr_norm = liquid_sumsqf(buf_mf, p*n);
 
     // allocate memory arrays
-    float complex * buf_0 = (float complex*) malloc(M*sizeof(float complex));
-    float complex * buf_1 = (float complex*) malloc(M*sizeof(float complex));
-    float complex * buf_2 = (float complex*) malloc(M*sizeof(float complex));
-    float complex * buf_3 = (float complex*) malloc(M*sizeof(float complex));
+    _Fcomplex * buf_0 = (_Fcomplex*) malloc(M*sizeof(_Fcomplex));
+    _Fcomplex * buf_1 = (_Fcomplex*) malloc(M*sizeof(_Fcomplex));
+    _Fcomplex * buf_2 = (_Fcomplex*) malloc(M*sizeof(_Fcomplex));
+    _Fcomplex * buf_3 = (_Fcomplex*) malloc(M*sizeof(_Fcomplex));
     windowcf buf_rx = windowcf_create(M);
 
     // create fft plans
@@ -89,7 +89,7 @@ int main(int argc, char*argv[])
     fprintf(fid,"llr = [];\n");
     for (i=0; i<n+200; i++) {
         // clear input, generate symbol
-        memset(buf_0, 0x0, M*sizeof(float complex));
+        memset(buf_0, 0x0, M*sizeof(_Fcomplex));
         if (i < n)
             buf_0[ seq[i] ? i1 : i0 ] = gain;
         else
@@ -107,9 +107,9 @@ int main(int argc, char*argv[])
         for (j=0; j<M; j++) {
             if (!timer) {
                 timer = M/p;
-                float complex * r;
+                _Fcomplex * r;
                 windowcf_read(buf_rx, &r);
-                memmove(buf_2, r, M*sizeof(float complex));
+                memmove(buf_2, r, M*sizeof(_Fcomplex));
                 fft_execute(fft);
                 float r2 = liquid_sumsqcf(buf_3, M);
                 float g  = 1.0f / (sqrtf(r2) + 1e-6f);
@@ -127,7 +127,7 @@ int main(int argc, char*argv[])
                 float y2 = liquid_sumsqf(rf, p*n);
                 rxy /= sqrtf(xcorr_norm*y2) + 1e-6f;
                 fprintf(fid,"rxy(end+1) = %12.4e;\n", rxy);
-               
+
                 printf(" %12.4e { %12.6f, %12.6f } : llr:%12.6f, rxy:%10.6f\n", r2, v0, v1, llr, rxy);
             }
             windowcf_push(buf_rx,buf_1[j]);
diff --git a/sandbox/fskmodem_test.c b/sandbox/fskmodem_test.c
index 1dc35111..4e63d576 100644
--- a/sandbox/fskmodem_test.c
+++ b/sandbox/fskmodem_test.c
@@ -1,4 +1,4 @@
-// 
+//
 // fskmodem_test.c
 //
 // This example demostrates the M-ary frequency-shift keying
@@ -116,8 +116,8 @@ int main(int argc, char*argv[])
 
     // arrays
     unsigned int  sym_in[num_symbols];      // input symbols
-    float complex x[num_samples];           // transmitted signal
-    float complex y[num_samples];           // received signal
+    _Fcomplex x[num_samples];           // transmitted signal
+    _Fcomplex y[num_samples];           // received signal
     unsigned int  sym_out[num_symbols];     // output symbols
 
     // determine demodulation mapping between tones and frequency bins
@@ -151,7 +151,7 @@ int main(int argc, char*argv[])
 
         // generate random phase
         float phi  = randf() * 2 * M_PI;
-        
+
         // modulate symbol
         for (j=0; j<k; j++)
             x[i*k+j] = cexpf(_Complex_I*phi + _Complex_I*j*dphi);
@@ -163,7 +163,7 @@ int main(int argc, char*argv[])
 
 #if 0
     // demodulate signal: high SNR method
-    float complex buf_time[k];
+    _Fcomplex buf_time[k];
     unsigned int n = 0;
     j = 0;
     for (i=0; i<num_samples; i++) {
@@ -176,7 +176,7 @@ int main(int argc, char*argv[])
             n = 0;
 
             // estimate frequency
-            float complex metric = 0;
+            _Fcomplex metric = 0;
             unsigned int s;
             for (s=1; s<k; s++)
                 metric += buf_time[s] * conjf(buf_time[s-1]);
@@ -188,8 +188,8 @@ int main(int argc, char*argv[])
     }
 #else
     // demodulate signal: least-squares method
-    float complex buf_time[K];
-    float complex buf_freq[K];
+    _Fcomplex buf_time[K];
+    _Fcomplex buf_freq[K];
     fftplan fft = fft_create_plan(K, buf_time, buf_freq, LIQUID_FFT_FORWARD, 0);
 
     for (i=0; i<K; i++)
@@ -240,10 +240,10 @@ int main(int argc, char*argv[])
     float psd[nfft];
     spgramcf_estimate_psd(nfft, y, num_samples, psd);
 
-    // 
+    //
     // export results
     //
-    
+
     // truncate to at most 10 symbols
     if (num_symbols > 10)
         num_symbols = 10;
diff --git a/sandbox/gmskmodem_coherent_test.c b/sandbox/gmskmodem_coherent_test.c
index 066c376e..9c7e2c95 100644
--- a/sandbox/gmskmodem_coherent_test.c
+++ b/sandbox/gmskmodem_coherent_test.c
@@ -1,4 +1,4 @@
-// 
+//
 // gmskmodem_coherent_test.c
 //
 // This example demostrates the continuous phase frequency-shift keying
@@ -59,9 +59,9 @@ int main(int argc, char*argv[])
 
     // arrays
     unsigned int  sym_in [num_symbols];     // input symbols
-    float complex x      [num_samples];     // transmitted signal
-    float complex y      [num_samples];     // received signal
-    float complex z      [num_samples];     // received signal
+    _Fcomplex x      [num_samples];     // transmitted signal
+    _Fcomplex y      [num_samples];     // received signal
+    _Fcomplex z      [num_samples];     // received signal
 
     // create modem objects
     gmskmod mod = gmskmod_create(k, m, beta);
@@ -97,7 +97,7 @@ int main(int argc, char*argv[])
     float psd[nfft];
     spgramcf_estimate_psd(nfft, x, num_samples, psd);
 
-    // 
+    //
     // export results
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/sandbox/gmskmodem_equalizer_test.c b/sandbox/gmskmodem_equalizer_test.c
index 13774931..a0ab0e39 100644
--- a/sandbox/gmskmodem_equalizer_test.c
+++ b/sandbox/gmskmodem_equalizer_test.c
@@ -1,4 +1,4 @@
-// 
+//
 // gmskmodem_equalizer_test.c
 //
 // Tests least mean-squares (LMS) equalizer (EQ) on a received GMSK
@@ -85,11 +85,11 @@ int main(int argc, char*argv[])
     unsigned int num_samples = k*num_symbols;
 
     // bookkeeping variables
-    float complex x[num_samples];       // interpolated time series
-    float complex y[num_samples];       // equalized output
+    _Fcomplex x[num_samples];       // interpolated time series
+    _Fcomplex y[num_samples];       // equalized output
 
     float hm[hm_len];                   // matched filter response
-    float complex hp[hp_len];           // equalizer filter coefficients
+    _Fcomplex hp[hp_len];           // equalizer filter coefficients
 
     unsigned int i;
 
@@ -102,7 +102,7 @@ int main(int argc, char*argv[])
     gmskmod gmod = gmskmod_create(k,m,beta);
     for (i=0; i<num_symbols; i++)
         gmskmod_modulate(gmod, rand()%2, &x[i*k]);
-    
+
     // push through equalizer
     // create equalizer, intialized with square-root Nyquist filter
     eqlms_cccf eq = eqlms_cccf_create_rnyquist(LIQUID_FIRFILT_RRC, k, p, beta, 0.0f);
@@ -114,7 +114,7 @@ int main(int argc, char*argv[])
     // filtered error vector magnitude (emperical RMS error)
     float evm_hat = 0.03f;
 
-    float complex d_hat = 0.0f;
+    _Fcomplex d_hat = 0.0f;
     for (i=0; i<num_samples; i++) {
         // print filtered evm (emperical rms error)
         if ( ((i+1)%50)==0 )
@@ -131,7 +131,7 @@ int main(int argc, char*argv[])
 
         // estimate transmitted signal
         unsigned int sym_out;   // output symbol
-        float complex d_prime;  // estimated input sample
+        _Fcomplex d_prime;  // estimated input sample
         modem_demodulate(demod, d_hat, &sym_out);
         modem_get_demodulator_sample(demod, &d_prime);
 
@@ -154,8 +154,8 @@ int main(int argc, char*argv[])
 
     firfilt_cccf mf = firfilt_cccf_create(hp, hp_len);
 
-    float complex buf_tx[k];
-    float complex buf_rx[k];
+    _Fcomplex buf_tx[k];
+    _Fcomplex buf_rx[k];
     for (i=0; i<500e3; i++) {
         // generate random symbol
         gmskmod_modulate(gmod, rand()%2, buf_tx);
@@ -185,7 +185,7 @@ int main(int argc, char*argv[])
     modem_destroy(demod);
     gmskmod_destroy(gmod);
 
-    // 
+    //
     // export output
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -260,7 +260,7 @@ int main(int argc, char*argv[])
     //fprintf(fid,"axis([-0.5 0.5 -12 8]);\n");
     fprintf(fid,"axis([-0.5 0.5 -50 10]);\n");
     fprintf(fid,"grid on;\n");
-    
+
     fclose(fid);
     printf("results written to '%s'\n", OUTPUT_FILENAME);
 
diff --git a/sandbox/gmskmodem_test.c b/sandbox/gmskmodem_test.c
index 8b269020..65fbb07b 100644
--- a/sandbox/gmskmodem_test.c
+++ b/sandbox/gmskmodem_test.c
@@ -1,4 +1,4 @@
-// 
+//
 // gmskmodem_test.c
 //
 
@@ -63,8 +63,8 @@ int main(int argc, char*argv[]) {
     // arrays
     unsigned char sym_in[num_symbols];      // input symbols
     float phi[num_samples];                 // transmitted phase
-    float complex x[num_samples];           // transmitted signal
-    float complex y[num_samples];           // received signal
+    _Fcomplex x[num_samples];           // transmitted signal
+    _Fcomplex y[num_samples];           // received signal
     float phi_hat[num_samples];             // received phase
     float phi_prime[num_samples];           // matched-filter output
     unsigned char sym_out[num_symbols];     // output symbols
@@ -100,9 +100,9 @@ int main(int argc, char*argv[]) {
     // push through channel
     for (i=0; i<num_samples; i++)
         y[i] = x[i] + nstd*(randnf() + _Complex_I*randnf())*M_SQRT1_2;
-    
+
     // run receiver
-    float complex x_prime = 0.0f;
+    _Fcomplex x_prime = 0.0f;
     unsigned int n=0;
     for (i=0; i<num_samples; i++) {
         phi_hat[i] = cargf( conjf(x_prime)*y[i] );
@@ -133,7 +133,7 @@ int main(int argc, char*argv[]) {
     firinterp_rrrf_destroy(interp_tx);
     firfilt_rrrf_destroy(decim_rx);
 
-    // 
+    //
     // export results
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/sandbox/iirdes_example.c b/sandbox/iirdes_example.c
index 0880ae5a..ca2b3f3e 100644
--- a/sandbox/iirdes_example.c
+++ b/sandbox/iirdes_example.c
@@ -134,10 +134,10 @@ int main(int argc, char*argv[]) {
     unsigned int nza;
 
     // analog poles/zeros/gain
-    float complex pa[n];
-    float complex za[n];
-    float complex ka;
-    float complex k0;
+    _Fcomplex pa[n];
+    _Fcomplex za[n];
+    _Fcomplex ka;
+    _Fcomplex k0;
 
     unsigned int r = n%2;
     unsigned int L = (n-r)/2;
@@ -204,9 +204,9 @@ int main(int argc, char*argv[]) {
 
     // complex digital poles/zeros/gain
     // NOTE: allocated double the filter order to cover band-pass, band-stop cases
-    float complex zd[2*n];
-    float complex pd[2*n];
-    float complex kd;
+    _Fcomplex zd[2*n];
+    _Fcomplex pd[2*n];
+    _Fcomplex kd;
     float m = iirdes_freqprewarp(btype,fc,f0);
     printf("m : %12.8f\n", m);
     bilinear_zpkf(za,    nza,
@@ -254,8 +254,8 @@ int main(int argc, char*argv[]) {
         btype == LIQUID_IIRDES_BANDSTOP)
     {
         // allocate memory for transformed zeros, poles
-        float complex zd1[2*n];
-        float complex pd1[2*n];
+        _Fcomplex zd1[2*n];
+        _Fcomplex pd1[2*n];
 
         // run zeros, poles trasform
         iirdes_dzpk_lp2bp(zd, pd,   // low-pass prototype zeros, poles
@@ -264,8 +264,8 @@ int main(int argc, char*argv[]) {
                           zd1,pd1); // transformed zeros, poles (length: 2*n)
 
         // copy transformed zeros, poles
-        memmove(zd, zd1, 2*n*sizeof(float complex));
-        memmove(pd, pd1, 2*n*sizeof(float complex));
+        memmove(zd, zd1, 2*n*sizeof(_Fcomplex));
+        memmove(pd, pd1, 2*n*sizeof(_Fcomplex));
 
         // update paramteres : n -> 2*n
         r = 0;
@@ -407,4 +407,3 @@ int main(int argc, char*argv[]) {
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/iirfilt_intdiff_test.c b/sandbox/iirfilt_intdiff_test.c
index 40b67f13..063e29ee 100644
--- a/sandbox/iirfilt_intdiff_test.c
+++ b/sandbox/iirfilt_intdiff_test.c
@@ -25,11 +25,11 @@ int main(int argc, char*argv[]) {
     // options
     unsigned int num_samples = 801;
 
-    // 
+    //
     // integrator digital zeros/poles/gain, [Pintelon:1990] Table II
     //
     // zeros, digital, integrator
-    float complex zdi[8] = {
+    _Fcomplex zdi[8] = {
         1.175839 * -1.0f,
         3.371020 * cexpf(_Complex_I * M_PI / 180.0f * -125.1125f),
         3.371020 * cexpf(_Complex_I * M_PI / 180.0f *  125.1125f),
@@ -39,7 +39,7 @@ int main(int argc, char*argv[]) {
         5.223966 * cexpf(_Complex_I * M_PI / 180.0f *   40.09347f),
         5.443743,};
     // poles, digital, integrator
-    float complex pdi[8] = {
+    _Fcomplex pdi[8] = {
         0.5805235f * -1.0f,
         0.2332021f * cexpf(_Complex_I * M_PI / 180.0f * -114.0968f),
         0.2332021f * cexpf(_Complex_I * M_PI / 180.0f *  114.0968f),
@@ -49,7 +49,7 @@ int main(int argc, char*argv[]) {
         0.1641457f * cexpf(_Complex_I * M_PI / 180.0f *   21.89539f),
         1.0f,};
     // gain, digital, integrator
-    float complex kdi = -1.89213380759321e-05f;
+    _Fcomplex kdi = -1.89213380759321e-05f;
 
 #if 1
     // second-order sections
@@ -70,11 +70,11 @@ int main(int argc, char*argv[]) {
 #endif
 
 
-    // 
+    //
     // differentiator digital zeros/poles/gain, [Pintelon:1990] Table IV
     //
     // zeros, digital, differentiator
-    float complex zdd[8] = {
+    _Fcomplex zdd[8] = {
         1.702575f * -1.0f,
         5.877385f * cexpf(_Complex_I * M_PI / 180.0f * -221.4063f),
         5.877385f * cexpf(_Complex_I * M_PI / 180.0f *  221.4063f),
@@ -84,7 +84,7 @@ int main(int argc, char*argv[]) {
         5.350284f * cexpf(_Complex_I * M_PI / 180.0f *   66.88802f),
         1.0f,};
     // poles, digital, differentiator
-    float complex pdd[8] = {
+    _Fcomplex pdd[8] = {
         0.8476936f * -1.0f,
         0.2990781f * cexpf(_Complex_I * M_PI / 180.0f * -125.5188f),
         0.2990781f * cexpf(_Complex_I * M_PI / 180.0f *  125.5188f),
@@ -94,7 +94,7 @@ int main(int argc, char*argv[]) {
         0.1958670f * cexpf(_Complex_I * M_PI / 180.0f *   40.51510f),
         0.1886088f,};
     // gain, digital, differentiator
-    float complex kdd = 2.09049284907492e-05f;
+    _Fcomplex kdd = 2.09049284907492e-05f;
 
 #if 1
     // second-order sections
@@ -115,9 +115,9 @@ int main(int argc, char*argv[]) {
 #endif
 
     // allocate arrays
-    float complex x[num_samples];
-    float complex y[num_samples];
-    float complex z[num_samples];
+    _Fcomplex x[num_samples];
+    _Fcomplex y[num_samples];
+    _Fcomplex z[num_samples];
 
     float tmin = 0.0f;
     float tmax = 1.0f;
@@ -186,7 +186,7 @@ int main(int argc, char*argv[]) {
 
     // compute frequency response
     unsigned int nfft = 256;
-    float complex Hi[nfft], Hd[nfft];
+    _Fcomplex Hi[nfft], Hd[nfft];
     float gdi[nfft], gdd[nfft];
     for (i=0; i<nfft; i++) {
         float f = 1e-4f + 0.5f * (float)i / (float)nfft;
@@ -247,4 +247,3 @@ int main(int argc, char*argv[]) {
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/matched_filter_cfo_test.c b/sandbox/matched_filter_cfo_test.c
index 1f991f2a..261e62cd 100644
--- a/sandbox/matched_filter_cfo_test.c
+++ b/sandbox/matched_filter_cfo_test.c
@@ -114,7 +114,7 @@ int main(int argc, char*argv[]) {
     unsigned int num_samples = num_symbols*k;
 
     // generate receive filter coefficients (reverse of transmit)
-    float complex gc[h_len];
+    _Fcomplex gc[h_len];
     unsigned int i;
     for (i=0; i<h_len; i++)
         gc[i] = h[h_len-i-1];
@@ -129,9 +129,9 @@ int main(int argc, char*argv[]) {
     firdecim_cccf  decim  = firdecim_cccf_create(k,gc,h_len);
 
     // generate signal
-    float complex sym_in[num_symbols];
-    float complex y[num_samples];
-    float complex sym_out[num_symbols];
+    _Fcomplex sym_in[num_symbols];
+    _Fcomplex y[num_samples];
+    _Fcomplex sym_out[num_symbols];
 
     for (i=0; i<h_len; i++)
         printf("h(%3u) = %12.8f;\n", i+1, h[i]);
@@ -209,8 +209,7 @@ int main(int argc, char*argv[]) {
 
     fclose(fid);
     printf("results written to %s.\n", OUTPUT_FILENAME);
-    
+
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/math_cacosf_test.c b/sandbox/math_cacosf_test.c
index 3f783062..c0b94560 100644
--- a/sandbox/math_cacosf_test.c
+++ b/sandbox/math_cacosf_test.c
@@ -33,7 +33,7 @@
 
 #define sandbox_randf() ((float) rand() / (float) RAND_MAX)
 
-float complex sandbox_cacosf(float complex _z)
+_Fcomplex sandbox_cacosf(_Fcomplex _z)
 {
     // return based on quadrant
     int sign_i = crealf(_z) > 0;
@@ -54,10 +54,10 @@ int main() {
     unsigned int d=2;   // number items per line
 
     // data arrays
-    float complex z[n];
-    float complex test[n];
+    _Fcomplex z[n];
+    _Fcomplex test[n];
 
-    float complex err_max = 0.0f;
+    _Fcomplex err_max = 0.0f;
     unsigned int i;
     for (i=0; i<n; i++) {
         // generate random complex number
@@ -65,9 +65,9 @@ int main() {
                2.0f*(2.0f*sandbox_randf() - 1.0f) * _Complex_I;
 
         test[i] = cacosf(z[i]);
-        float complex acosz_hat = sandbox_cacosf(z[i]);
+        _Fcomplex acosz_hat = sandbox_cacosf(z[i]);
 
-        float complex err = test[i] - acosz_hat;
+        _Fcomplex err = test[i] - acosz_hat;
 
         printf("%3u: z=%6.2f+j%6.2f, acos(z)=%6.2f+j%6.2f (%6.2f+j%6.2f) e=%12.4e\n",
                 i,
@@ -82,12 +82,12 @@ int main() {
 
     printf("maximum error: %12.4e;\n", cabsf(err_max));
 
-    // 
+    //
     // print autotest lines
     //
 
     printf("\n");
-    printf("    float complex z[%u] = {\n      ", n);
+    printf("    _Fcomplex z[%u] = {\n      ", n);
     for (i=0; i<n; i++) {
         printf("%12.4e+_Complex_I*%12.4e", crealf(z[i]), cimagf(z[i]));
 
@@ -101,7 +101,7 @@ int main() {
     printf("};\n");
 
     printf("\n");
-    printf("    float complex test[%u] = {\n      ", n);
+    printf("    _Fcomplex test[%u] = {\n      ", n);
     for (i=0; i<n; i++) {
         printf("%12.4e+_Complex_I*%12.4e", crealf(test[i]), cimagf(test[i]));
 
@@ -117,4 +117,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/math_casinf_test.c b/sandbox/math_casinf_test.c
index 79a240fd..46d1c959 100644
--- a/sandbox/math_casinf_test.c
+++ b/sandbox/math_casinf_test.c
@@ -33,7 +33,7 @@
 
 #define sandbox_randf() ((float) rand() / (float) RAND_MAX)
 
-float complex sandbox_cacosf(float complex _z)
+_Fcomplex sandbox_cacosf(_Fcomplex _z)
 {
     // return based on quadrant
     int sign_i = crealf(_z) > 0;
@@ -49,7 +49,7 @@ float complex sandbox_cacosf(float complex _z)
     return 0.0f;
 }
 
-float complex sandbox_casinf(float complex _z)
+_Fcomplex sandbox_casinf(_Fcomplex _z)
 {
     return 0.5f*M_PI - sandbox_cacosf(_z);
 }
@@ -59,10 +59,10 @@ int main() {
     unsigned int d=2;   // number items per line
 
     // data arrays
-    float complex z[n];
-    float complex test[n];
+    _Fcomplex z[n];
+    _Fcomplex test[n];
 
-    float complex err_max = 0.0f;
+    _Fcomplex err_max = 0.0f;
     unsigned int i;
     for (i=0; i<n; i++) {
         // generate random complex number
@@ -70,9 +70,9 @@ int main() {
                2.0f*(2.0f*sandbox_randf() - 1.0f) * _Complex_I;
 
         test[i] = casinf(z[i]);
-        float complex asinz_hat = sandbox_casinf(z[i]);
+        _Fcomplex asinz_hat = sandbox_casinf(z[i]);
 
-        float complex err = test[i] - asinz_hat;
+        _Fcomplex err = test[i] - asinz_hat;
 
         printf("%3u: z=%6.2f+j%6.2f, asin(z)=%6.2f+j%6.2f (%6.2f+j%6.2f) e=%12.4e\n",
                 i,
@@ -87,12 +87,12 @@ int main() {
 
     printf("maximum error: %12.4e;\n", cabsf(err_max));
 
-    // 
+    //
     // print autotest lines
     //
 
     printf("\n");
-    printf("    float complex z[%u] = {\n      ", n);
+    printf("    _Fcomplex z[%u] = {\n      ", n);
     for (i=0; i<n; i++) {
         printf("%12.4e+_Complex_I*%12.4e", crealf(z[i]), cimagf(z[i]));
 
@@ -106,7 +106,7 @@ int main() {
     printf("};\n");
 
     printf("\n");
-    printf("    float complex test[%u] = {\n      ", n);
+    printf("    _Fcomplex test[%u] = {\n      ", n);
     for (i=0; i<n; i++) {
         printf("%12.4e+_Complex_I*%12.4e", crealf(test[i]), cimagf(test[i]));
 
@@ -122,4 +122,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/math_catanf_test.c b/sandbox/math_catanf_test.c
index 254ece19..9f3bf6d1 100644
--- a/sandbox/math_catanf_test.c
+++ b/sandbox/math_catanf_test.c
@@ -33,7 +33,7 @@
 
 #define sandbox_randf() ((float) rand() / (float) RAND_MAX)
 
-float complex sandbox_catanf(float complex _z)
+_Fcomplex sandbox_catanf(_Fcomplex _z)
 {
     return 0.5f*_Complex_I*clogf( (1.0f-_Complex_I*_z)/(1.0f+_Complex_I*_z) );
 }
@@ -43,10 +43,10 @@ int main() {
     unsigned int d=2;   // number items per line
 
     // data arrays
-    float complex z[n];
-    float complex test[n];
+    _Fcomplex z[n];
+    _Fcomplex test[n];
 
-    float complex err_max = 0.0f;
+    _Fcomplex err_max = 0.0f;
     unsigned int i;
     for (i=0; i<n; i++) {
         // generate random complex number
@@ -54,9 +54,9 @@ int main() {
                2.0f*(2.0f*sandbox_randf() - 1.0f) * _Complex_I;
 
         test[i] = catanf(z[i]);
-        float complex atanz_hat = sandbox_catanf(z[i]);
+        _Fcomplex atanz_hat = sandbox_catanf(z[i]);
 
-        float complex err = test[i] - atanz_hat;
+        _Fcomplex err = test[i] - atanz_hat;
 
         printf("%3u: z=%6.2f+j%6.2f, atan(z)=%6.2f+j%6.2f (%6.2f+j%6.2f) e=%12.4e\n",
                 i,
@@ -71,12 +71,12 @@ int main() {
 
     printf("maximum error: %12.4e;\n", cabsf(err_max));
 
-    // 
+    //
     // print autotest lines
     //
 
     printf("\n");
-    printf("    float complex z[%u] = {\n      ", n);
+    printf("    _Fcomplex z[%u] = {\n      ", n);
     for (i=0; i<n; i++) {
         printf("%12.4e+_Complex_I*%12.4e", crealf(z[i]), cimagf(z[i]));
 
@@ -90,7 +90,7 @@ int main() {
     printf("};\n");
 
     printf("\n");
-    printf("    float complex test[%u] = {\n      ", n);
+    printf("    _Fcomplex test[%u] = {\n      ", n);
     for (i=0; i<n; i++) {
         printf("%12.4e+_Complex_I*%12.4e", crealf(test[i]), cimagf(test[i]));
 
@@ -106,4 +106,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/math_cexpf_test.c b/sandbox/math_cexpf_test.c
index b1540297..c334576d 100644
--- a/sandbox/math_cexpf_test.c
+++ b/sandbox/math_cexpf_test.c
@@ -33,11 +33,11 @@
 
 #define sandbox_randf() ((float) rand() / (float) RAND_MAX)
 
-float complex sandbox_cexpf(float complex _z)
+_Fcomplex sandbox_cexpf(_Fcomplex _z)
 {
     float r = expf( crealf(_z) );
-    float complex re = cosf( cimagf(_z) );
-    float complex im = sinf( cimagf(_z) );
+    _Fcomplex re = cosf( cimagf(_z) );
+    _Fcomplex im = sinf( cimagf(_z) );
 
     return r*(re + _Complex_I*im);
 }
@@ -47,20 +47,20 @@ int main() {
     unsigned int d=2;   // number items per line
 
     // data arrays
-    float complex z[n];
-    float complex test[n];
+    _Fcomplex z[n];
+    _Fcomplex test[n];
 
     unsigned int i;
-    float complex err_max = 0.0f;
+    _Fcomplex err_max = 0.0f;
     for (i=0; i<n; i++) {
         // generate random complex number
         z[i] = 4.0f*(2.0f*sandbox_randf() - 1.0f) +
                4.0f*(2.0f*sandbox_randf() - 1.0f) * _Complex_I;
 
         test[i] = cexpf(z[i]);
-        float complex expz_hat = sandbox_cexpf(z[i]);
+        _Fcomplex expz_hat = sandbox_cexpf(z[i]);
 
-        float complex err = test[i] - expz_hat;
+        _Fcomplex err = test[i] - expz_hat;
 
         printf("%3u: z=%6.2f+j%6.2f, exp(z)=%6.2f+j%6.2f (%6.2f+j%6.2f) e=%12.4e\n",
                 i,
@@ -75,12 +75,12 @@ int main() {
 
     printf("maximum error: %12.4e;\n", cabsf(err_max));
 
-    // 
+    //
     // print autotest lines
     //
 
     printf("\n");
-    printf("    float complex z[%u] = {\n      ", n);
+    printf("    _Fcomplex z[%u] = {\n      ", n);
     for (i=0; i<n; i++) {
         printf("%14.6e+_Complex_I*%14.6e", crealf(z[i]), cimagf(z[i]));
 
@@ -94,7 +94,7 @@ int main() {
     printf("};\n");
 
     printf("\n");
-    printf("    float complex test[%u] = {\n      ", n);
+    printf("    _Fcomplex test[%u] = {\n      ", n);
     for (i=0; i<n; i++) {
         printf("%14.6e+_Complex_I*%14.6e", crealf(test[i]), cimagf(test[i]));
 
@@ -110,4 +110,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/math_clogf_test.c b/sandbox/math_clogf_test.c
index 0c00daad..39c4e0cd 100644
--- a/sandbox/math_clogf_test.c
+++ b/sandbox/math_clogf_test.c
@@ -33,7 +33,7 @@
 
 #define sandbox_randf() ((float) rand() / (float) RAND_MAX)
 
-float complex sandbox_clogf(float complex _z)
+_Fcomplex sandbox_clogf(_Fcomplex _z)
 {
     return logf(cabsf(_z)) + _Complex_I*cargf(_z);
 }
@@ -43,20 +43,20 @@ int main() {
     unsigned int d=2;   // number items per line
 
     // data arrays
-    float complex z[n];
-    float complex test[n];
+    _Fcomplex z[n];
+    _Fcomplex test[n];
 
     unsigned int i;
-    float complex err_max = 0.0f;
+    _Fcomplex err_max = 0.0f;
     for (i=0; i<n; i++) {
         // generate random complex number
         z[i] = 4.0f*(2.0f*sandbox_randf() - 1.0f) +
                4.0f*(2.0f*sandbox_randf() - 1.0f) * _Complex_I;
 
         test[i] = clogf(z[i]);
-        float complex logz_hat = sandbox_clogf(z[i]);
+        _Fcomplex logz_hat = sandbox_clogf(z[i]);
 
-        float complex err = test[i] - logz_hat;
+        _Fcomplex err = test[i] - logz_hat;
 
         printf("%3u: z=%6.2f+j%6.2f, log(z)=%6.2f+j%6.2f (%6.2f+j%6.2f) e=%12.4e\n",
                 i,
@@ -71,12 +71,12 @@ int main() {
 
     printf("maximum error: %12.4e;\n", cabsf(err_max));
 
-    // 
+    //
     // print autotest lines
     //
 
     printf("\n");
-    printf("    float complex z[%u] = {\n      ", n);
+    printf("    _Fcomplex z[%u] = {\n      ", n);
     for (i=0; i<n; i++) {
         printf("%12.4e+_Complex_I*%12.4e", crealf(z[i]), cimagf(z[i]));
 
@@ -90,7 +90,7 @@ int main() {
     printf("};\n");
 
     printf("\n");
-    printf("    float complex test[%u] = {\n      ", n);
+    printf("    _Fcomplex test[%u] = {\n      ", n);
     for (i=0; i<n; i++) {
         printf("%12.4e+_Complex_I*%12.4e", crealf(test[i]), cimagf(test[i]));
 
@@ -106,4 +106,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/math_csqrtf_test.c b/sandbox/math_csqrtf_test.c
index 1be818fe..90fa1d2f 100644
--- a/sandbox/math_csqrtf_test.c
+++ b/sandbox/math_csqrtf_test.c
@@ -33,7 +33,7 @@
 
 #define sandbox_randf() ((float) rand() / (float) RAND_MAX)
 
-float complex sandbox_csqrtf(float complex _z)
+_Fcomplex sandbox_csqrtf(_Fcomplex _z)
 {
     float r = cabsf(_z);            // magnitude of _z
     float a = crealf(_z);           // real component of _z
@@ -51,10 +51,10 @@ int main() {
     unsigned int d=2;   // number of items per line
 
     // data arrays
-    float complex z[n];
-    float complex test[n];
+    _Fcomplex z[n];
+    _Fcomplex test[n];
 
-    float complex err_max = 0.0f;
+    _Fcomplex err_max = 0.0f;
     unsigned int i;
     for (i=0; i<n; i++) {
         // generate random complex number
@@ -62,9 +62,9 @@ int main() {
                2.0f*(2.0f*sandbox_randf() - 1.0f) * _Complex_I;
 
         test[i] = csqrtf(z[i]);
-        float complex sqrtz_hat = sandbox_csqrtf(z[i]);
+        _Fcomplex sqrtz_hat = sandbox_csqrtf(z[i]);
 
-        float complex err = test[i] - sqrtz_hat;
+        _Fcomplex err = test[i] - sqrtz_hat;
 
         printf("%3u: z=%6.2f+j%6.2f, sqrt(z)=%6.2f+j%6.2f (%6.2f+j%6.2f) e=%12.4e\n",
                 i,
@@ -80,12 +80,12 @@ int main() {
     printf("maximum error: %12.4e;\n", cabsf(err_max));
 
 
-    // 
+    //
     // print autotest lines
     //
 
     printf("\n");
-    printf("    float complex z[%u] = {\n      ", n);
+    printf("    _Fcomplex z[%u] = {\n      ", n);
     for (i=0; i<n; i++) {
         printf("%12.4e+_Complex_I*%12.4e", crealf(z[i]), cimagf(z[i]));
 
@@ -99,7 +99,7 @@ int main() {
     printf("};\n");
 
     printf("\n");
-    printf("    float complex test[%u] = {\n      ", n);
+    printf("    _Fcomplex test[%u] = {\n      ", n);
     for (i=0; i<n; i++) {
         printf("%12.4e+_Complex_I*%12.4e", crealf(test[i]), cimagf(test[i]));
 
@@ -114,4 +114,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/matrix_test.c b/sandbox/matrix_test.c
index 5612c2fe..edf626c3 100644
--- a/sandbox/matrix_test.c
+++ b/sandbox/matrix_test.c
@@ -1,4 +1,4 @@
-// 
+//
 // matrix_test.c
 //
 // This example tests basic matrix operations.
@@ -221,19 +221,19 @@ int main() {
     matrixf_print(Ugs_test,4,3);
 
 
-    // 
+    //
     // test Cholesky decomposition
     //
 
     printf("\n");
     printf("testing Cholesky decomposition\n");
     // generate  input matrix
-    float complex Lp[9] = { 1.0,                   0.0,                   0.0,
+    _Fcomplex Lp[9] = { 1.0,                   0.0,                   0.0,
                            -3.1 + 0.2*_Complex_I,  0.3,                   0.0,
                             1.7 + 0.5*_Complex_I, -0.6 - 0.3*_Complex_I,  2.9};
-    float complex Ap[9];
+    _Fcomplex Ap[9];
     matrixcf_mul_transpose(Lp, 3, 3, Ap);
-    float complex Lc[9];
+    _Fcomplex Lc[9];
     matrixcf_chol(Ap, 3, Lc);
 
     printf("Lp:\n"); matrixcf_print(Lp, 3, 3);
@@ -243,4 +243,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/modem_demodulate_arb_gentab.c b/sandbox/modem_demodulate_arb_gentab.c
index 03ea8d07..10bf95bf 100644
--- a/sandbox/modem_demodulate_arb_gentab.c
+++ b/sandbox/modem_demodulate_arb_gentab.c
@@ -1,4 +1,4 @@
-// 
+//
 // modem_demodulate_arb_gentab.c
 //
 // Generate fast demodulation tables for arbitrary modems; use existing
@@ -33,17 +33,17 @@ void usage()
 }
 
 // search for nearest constellation points to reference points
-void modem_arbref_search(float complex * _c,
+void modem_arbref_search(_Fcomplex * _c,
                          unsigned int _M,
-                         float complex * _cref,
+                         _Fcomplex * _cref,
                          unsigned int _p,
                          unsigned char * _index,
                          unsigned int _s);
 
 // search for nearest constellation points to single reference point
-void modem_arbref_search_point(float complex * _c,
+void modem_arbref_search_point(_Fcomplex * _c,
                                unsigned int _M,
-                               float complex _cref,
+                               _Fcomplex _cref,
                                unsigned char * _index,
                                unsigned int _s);
 
@@ -95,7 +95,7 @@ int main(int argc, char*argv[])
     modem qref = modem_create(mref);
     unsigned int kref = modem_get_bps(qref);
     unsigned int p = 1 << kref;
-    float complex cref[p];
+    _Fcomplex cref[p];
     for (i=0; i<p; i++) {
         modem_modulate(qref, i, &cref[i]);
         cref[i] *= alpha;
@@ -106,7 +106,7 @@ int main(int argc, char*argv[])
     modem q = modem_create(ms);
     unsigned int bps = modem_get_bps(q);
     unsigned int M = 1 << bps;
-    float complex constellation[M];
+    _Fcomplex constellation[M];
     for (i=0; i<M; i++)
         modem_modulate(q, i, &constellation[i]);
     modem_destroy(q);
@@ -144,7 +144,7 @@ int main(int argc, char*argv[])
         printf("}%s", i==(p-1) ? "};\n" : ",\n");
     }
 
-    // 
+    //
     // export output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -213,9 +213,9 @@ int main(int argc, char*argv[])
 //  _p      :   reference points size
 //  _index  :   indices of nearest constellation points [size: _p x _s]
 //  _s      :   number of nearest constellation points
-void modem_arbref_search(float complex * _c,
+void modem_arbref_search(_Fcomplex * _c,
                          unsigned int _M,
-                         float complex * _cref,
+                         _Fcomplex * _cref,
                          unsigned int _p,
                          unsigned char * _index,
                          unsigned int _s)
@@ -236,9 +236,9 @@ void modem_arbref_search(float complex * _c,
 }
 
 // search for nearest constellation points to single reference point
-void modem_arbref_search_point(float complex * _c,
+void modem_arbref_search_point(_Fcomplex * _c,
                                unsigned int _M,
-                               float complex _cref,
+                               _Fcomplex _cref,
                                unsigned char * _index,
                                unsigned int _s)
 {
@@ -251,7 +251,7 @@ void modem_arbref_search_point(float complex * _c,
 
     unsigned int i;
     unsigned int n;
-    
+
     for (n=0; n<_s; n++) {
         int min_found = 0;
         float d;
@@ -317,4 +317,3 @@ unsigned int modem_arbref_search_unassigned(unsigned char * _index,
 
     return num_unassigned;
 }
-
diff --git a/sandbox/modem_demodulate_soft_gentab.c b/sandbox/modem_demodulate_soft_gentab.c
index 70f9b22b..bcafff3f 100644
--- a/sandbox/modem_demodulate_soft_gentab.c
+++ b/sandbox/modem_demodulate_soft_gentab.c
@@ -1,4 +1,4 @@
-// 
+//
 // modem_demodulate_soft_gentab.c
 //
 // Generates table of nearest symbols and tests soft demodulation
@@ -33,10 +33,10 @@ void print_bitstring(unsigned int _x,
 //  _s          :   hard demodulator output
 //  _soft_bits  :   soft bit ouput (approximate log-likelihood ratio)
 void modem_demodulate_soft_tab(modem _q,
-                               float complex * _c,
+                               _Fcomplex * _c,
                                unsigned int * _cp,
                                unsigned int _p,
-                               float complex _r,
+                               _Fcomplex _r,
                                unsigned int * _s,
                                float * _soft_bits);
 
@@ -47,7 +47,7 @@ int main(int argc, char*argv[])
     // options
     modulation_scheme ms = LIQUID_MODEM_QAM16;  // modulation scheme
     unsigned int p = 4;                         // number of 'nearest symbols'
-    float complex e = 0.1f + _Complex_I*0.15f;  // error
+    _Fcomplex e = 0.1f + _Complex_I*0.15f;  // error
 
     // validate input
     if (ms == LIQUID_MODEM_UNKNOWN || ms >= LIQUID_MODEM_NUM_SCHEMES) {
@@ -71,12 +71,12 @@ int main(int argc, char*argv[])
 
     // generate constellation
     modem q = modem_create(ms);
-    float complex c[M];         // constellation
+    _Fcomplex c[M];         // constellation
     for (i=0; i<M; i++)
         modem_modulate(q, i, &c[i]);
     modem_destroy(q);
 
-    // 
+    //
     // find nearest symbols
     //
     unsigned int cp[M*p];
@@ -139,7 +139,7 @@ int main(int argc, char*argv[])
         }
     }
 
-    // 
+    //
     // print results
     //
     for (i=0; i<M; i++) {
@@ -182,7 +182,7 @@ int main(int argc, char*argv[])
     unsigned int sym_in = rand() % M;
     if (ms == LIQUID_MODEM_QAM16)
         sym_in = 13;
-    float complex r = c[sym_in] + e;
+    _Fcomplex r = c[sym_in] + e;
 
     // run soft demodulation for each bit
     float soft_bits[bps];
@@ -223,7 +223,7 @@ int main(int argc, char*argv[])
 #endif
     }
 
-    // 
+    //
     // demodulate using internal method
     //
     q = modem_create(ms);
@@ -261,7 +261,7 @@ int main(int argc, char*argv[])
         printf("\n");
     }
 
-    // 
+    //
     // export results to file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -292,7 +292,7 @@ int main(int argc, char*argv[])
     // print lines to 'nearest neighbor' points
     fprintf(fid,"plot(");
     for (i=0; i<p; i++) {
-        float complex x_hat = c[ cp[sym_out_tab*p+i] ];
+        _Fcomplex x_hat = c[ cp[sym_out_tab*p+i] ];
         fprintf(fid,"[%12.8f %12.8f],[%12.8f %12.8f],'Color',[1 1 1]*0.8",
                 crealf(r), crealf(x_hat),
                 cimagf(r), cimagf(x_hat));
@@ -323,10 +323,10 @@ int main(int argc, char*argv[])
 //  _s          :   hard demodulator output
 //  _soft_bits  :   soft bit ouput (approximate log-likelihood ratio)
 void modem_demodulate_soft_tab(modem _q,
-                               float complex * _c,
+                               _Fcomplex * _c,
                                unsigned int * _cp,
                                unsigned int _p,
-                               float complex _r,
+                               _Fcomplex _r,
                                unsigned int * _s,
                                float * _soft_bits)
 {
@@ -374,7 +374,7 @@ void modem_demodulate_soft_tab(modem _q,
 #endif
 
             // compute distance
-            float complex x_hat = _c[ _cp[(*_s)*_p + i] ];
+            _Fcomplex x_hat = _c[ _cp[(*_s)*_p + i] ];
             d = crealf( (_r-x_hat)*conjf(_r-x_hat) );
 #if DEBUG
             printf("(%8.6f) ", d);
@@ -401,4 +401,3 @@ void modem_demodulate_soft_tab(modem _q,
 #endif
     }
 }
-
diff --git a/sandbox/modem_demodulate_soft_test.c b/sandbox/modem_demodulate_soft_test.c
index 178a3655..c7551390 100644
--- a/sandbox/modem_demodulate_soft_test.c
+++ b/sandbox/modem_demodulate_soft_test.c
@@ -1,4 +1,4 @@
-// 
+//
 // modem_demodulate_soft_test.c
 //
 // Tests soft demoulation using log-likelihood ratio
@@ -19,7 +19,7 @@ int main() {
 
     // options
     modulation_scheme ms = LIQUID_MODEM_QAM16;  // modulation scheme
-    float complex e = 0.1f + _Complex_I*0.2f;   // error
+    _Fcomplex e = 0.1f + _Complex_I*0.2f;   // error
 
     unsigned int i;
 
@@ -30,14 +30,14 @@ int main() {
     modem q = modem_create(ms);
     unsigned int bps = modem_get_bps(q);
     unsigned int M = 1 << bps;  // constellation size
-    float complex c[M];         // constellation
+    _Fcomplex c[M];         // constellation
     for (i=0; i<M; i++)
         modem_modulate(q, i, &c[i]);
     modem_destroy(q);
 
     // select input symbol and compute received symbol
     unsigned int sym_in = rand() % M;
-    float complex r = c[sym_in] + e;
+    _Fcomplex r = c[sym_in] + e;
 
     // run soft demodulation for each bit
     float soft_bits[bps];
@@ -93,7 +93,7 @@ int main() {
         printf("%5d > %1u\n", soft_bit, soft_bit & 0x80 ? 1 : 0);
     }
 
-    // 
+    //
     // export results to file
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/sandbox/mskmodem_test.c b/sandbox/mskmodem_test.c
index 16a3dfdc..63a9aa87 100644
--- a/sandbox/mskmodem_test.c
+++ b/sandbox/mskmodem_test.c
@@ -1,4 +1,4 @@
-// 
+//
 // mskmodem_test.c
 //
 
@@ -25,7 +25,7 @@
   0.8     1.1116        1.3691      1.2040
   0.85    1.1146        1.4171      1.2628
   0.9     1.1074        1.4333      1.3158
- 
+
  rcos-full: median(|z|) ~ 0.34146  * h^2  +   0.14371  * h  +  0.81937
  rcos-half: median(|z|) ~ 1.143219 * h^2  +  -0.064886 * h  +  0.718770
  GMSK:      median(|z|) ~ 0.967978 * h^2  +  -0.077964 * h  +  0.658288
@@ -116,9 +116,9 @@ int main(int argc, char*argv[]) {
     // arrays
     unsigned char sym_in[num_symbols];      // input symbols
     float phi[num_samples];                 // transmitted phase
-    float complex x[num_samples];           // transmitted signal
-    float complex y[num_samples];           // received signal
-    float complex z[num_samples];           // output...
+    _Fcomplex x[num_samples];           // transmitted signal
+    _Fcomplex y[num_samples];           // received signal
+    _Fcomplex z[num_samples];           // output...
     //unsigned char sym_out[num_symbols];     // output symbols
 
     unsigned int ht_len = 0;
@@ -202,7 +202,7 @@ int main(int argc, char*argv[]) {
         // add noise
         y[i] += nstd*(randnf() + _Complex_I*randnf())*M_SQRT1_2;
     }
-    
+
     // create decimator
     unsigned int m = 3;
     float bw = 0.0f;
@@ -227,7 +227,7 @@ int main(int argc, char*argv[]) {
         break;
     case TXFILT_RCOS_HALF:
         if (M==2) {
-            // rcos-half:               
+            // rcos-half:
             decim_rx = firfilt_crcf_create_rnyquist(LIQUID_FIRFILT_GMSKRX,k,m,0.3f,0);
             scale = 1.1f / (float)k;
             //scale = 1.1f / (float)k * 1.0f / ( 1.24887*h*h  -0.16103*h +  0.73256 );
@@ -255,7 +255,7 @@ int main(int argc, char*argv[]) {
     unsigned int n=0;
     unsigned int num_errors = 0;
     unsigned int num_symbols_checked = 0;
-    float complex z_prime = 0.0f;
+    _Fcomplex z_prime = 0.0f;
     for (i=0; i<num_samples; i++) {
         // push through filter
         firfilt_crcf_push(decim_rx, y[i]);
@@ -299,7 +299,7 @@ int main(int argc, char*argv[]) {
     float psd[nfft];
     spgramcf_estimate_psd(nfft, y, num_samples, psd);
 
-    // 
+    //
     // export results
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -410,7 +410,7 @@ int main(int argc, char*argv[]) {
 
     fclose(fid);
     printf("results written to '%s'\n", OUTPUT_FILENAME);
-    
+
     // free allocated filter memory
     free(ht);
 
diff --git a/sandbox/msresamp_crcf_test.c b/sandbox/msresamp_crcf_test.c
index 8eb635f8..ec024015 100644
--- a/sandbox/msresamp_crcf_test.c
+++ b/sandbox/msresamp_crcf_test.c
@@ -62,8 +62,8 @@ int main(int argc, char*argv[])
     unsigned int ny_alloc = (unsigned int) (2*(float)nx * r);  // allocation for output
 
     // allocate memory for arrays
-    float complex x[nx];
-    float complex y[ny_alloc];
+    _Fcomplex x[nx];
+    _Fcomplex y[ny_alloc];
 
     // generate input
     unsigned int window_len = (3*nx)/4;
diff --git a/sandbox/newbench_example.c b/sandbox/newbench_example.c
index 360a054e..c6210487 100644
--- a/sandbox/newbench_example.c
+++ b/sandbox/newbench_example.c
@@ -25,8 +25,8 @@
 //
 
 // compile and run:
-//   $ gcc -Wall -I. -I./include -c newbench_example.c -o newbench_example.o 
-//   $ gcc newbench_example.o libliquid.a -lm -lfec -lpthread -lc -lfftw3f -o newbench_example 
+//   $ gcc -Wall -I. -I./include -c newbench_example.c -o newbench_example.o
+//   $ gcc newbench_example.o libliquid.a -lm -lfec -lpthread -lc -lfftw3f -o newbench_example
 //   $ ./newbench_example
 
 #include <stdio.h>
@@ -66,8 +66,8 @@ void benchmark_decim_crcf(
         h[i] = 0.0f;
     decim_crcf decim = decim_crcf_create(opts->D,h,opts->n);
 
-    float complex x[opts->D];
-    float complex y;
+    _Fcomplex x[opts->D];
+    _Fcomplex y;
     for (i=0; i<opts->D; i++)
         x[i] = 1.0f;
     getrusage(RUSAGE_SELF, _start);
@@ -113,4 +113,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/ofdm_ber_test.c b/sandbox/ofdm_ber_test.c
index 1c517378..938b9d6e 100644
--- a/sandbox/ofdm_ber_test.c
+++ b/sandbox/ofdm_ber_test.c
@@ -74,13 +74,13 @@ int main(int argc, char*argv[])
     unsigned int symbol_len = M + cp_len;
     float nstd = powf(10.0f, -SNRdB/20.0f);
     float fft_gain = 1.0f / sqrtf(M);   // 'gain' due to taking FFT
-    
+
     // buffers
     unsigned int sym_in[M];             // input data symbols
     unsigned int sym_out[M];            // output data symbols
-    float complex x[M];                 // time-domain buffer
-    float complex X[M];                 // freq-domain buffer
-    float complex buffer[symbol_len];   // 
+    _Fcomplex x[M];                 // time-domain buffer
+    _Fcomplex X[M];                 // freq-domain buffer
+    _Fcomplex buffer[symbol_len];   //
 
     // create modulator/demodulator objects
     modem mod   = modem_create(ms);
@@ -88,7 +88,7 @@ int main(int argc, char*argv[])
     unsigned int bps = modem_get_bps(mod);  // modem bits/symbol
 
     // create channel filter (random taps)
-    float complex hc[hc_len];
+    _Fcomplex hc[hc_len];
     hc[0] = 1.0f;
     for (i=1; i<hc_len; i++)
         hc[i] = 0.1f * (randnf() + _Complex_I*randnf());
@@ -153,4 +153,3 @@ int main(int argc, char*argv[])
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/ofdmframe_papr_test.c b/sandbox/ofdmframe_papr_test.c
index 801d4a46..a8fd747e 100644
--- a/sandbox/ofdmframe_papr_test.c
+++ b/sandbox/ofdmframe_papr_test.c
@@ -28,7 +28,7 @@ void usage()
 // compute peak-to-average power ratio
 //  _x  :   input time series
 //  _n  :   number of samples
-float ofdmframe_PAPR(float complex * _x,
+float ofdmframe_PAPR(_Fcomplex * _x,
                      unsigned int    _n);
 
 int main(int argc, char*argv[])
@@ -71,8 +71,8 @@ int main(int argc, char*argv[])
 
     modem mod = modem_create(ms);
 
-    float complex X[M];             // channelized symbols
-    float complex buffer[frame_len];// output time series
+    _Fcomplex X[M];             // channelized symbols
+    _Fcomplex buffer[frame_len];// output time series
     float * PAPR = (float*) malloc(num_symbols*sizeof(float));
 
     // histogram display
@@ -113,7 +113,7 @@ int main(int argc, char*argv[])
         float ihat = num_bins * (PAPR[i] - xmin) / (xmax - xmin);
         if (ihat < 0.0f) index = 0;
         else             index = (unsigned int)ihat;
-        
+
         if (index >= num_bins)
             index = num_bins-1;
 
@@ -151,7 +151,7 @@ int main(int argc, char*argv[])
     printf("max  PAPR: %12.4f dB\n", PAPR_max);
     printf("mean PAPR: %12.4f dB\n", PAPR_mean);
 
-    // 
+    //
     // export output file
     //
 
@@ -200,7 +200,7 @@ int main(int argc, char*argv[])
 // compute peak-to-average power ratio
 //  _x  :   input time series
 //  _n  :   number of samples
-float ofdmframe_PAPR(float complex * _x,
+float ofdmframe_PAPR(_Fcomplex * _x,
                      unsigned int    _n)
 {
     float e;
@@ -220,4 +220,3 @@ float ofdmframe_PAPR(float complex * _x,
 
     return 10*log10f(e_max / e_mean);
 }
-
diff --git a/sandbox/ofdmframesync_cfo_test.c b/sandbox/ofdmframesync_cfo_test.c
index 58a76f65..3059858c 100644
--- a/sandbox/ofdmframesync_cfo_test.c
+++ b/sandbox/ofdmframesync_cfo_test.c
@@ -25,7 +25,7 @@ void usage()
     printf("  s     : number of steps, default: 21\n");
 }
 
-static int callback(float complex * _X,
+static int callback(_Fcomplex * _X,
                     unsigned char * _p,
                     unsigned int    _M,
                     void *          _userdata);
@@ -82,9 +82,9 @@ int main(int argc, char*argv[])
     ofdmframesync fs = ofdmframesync_create(M, cp_len, taper_len, p, callback, (int*)&frame_detected);
     ofdmframesync_print(fs);
 
-    float complex X[M];                 // channelized symbols
-    float complex frame[num_samples];   // initial frame
-    float complex y[num_samples];       // output time series
+    _Fcomplex X[M];                 // channelized symbols
+    _Fcomplex frame[num_samples];   // initial frame
+    _Fcomplex y[num_samples];       // output time series
 
     unsigned int n=0;
 
@@ -96,7 +96,7 @@ int main(int argc, char*argv[])
     for (i=0; i<M; i++)
         X[i] = rand() % 2 ? 1.0f : -1.0f;
     ofdmframegen_writesymbol(fg, X, &frame[n]);
-    
+
     // carrier frequency offset
     float nu_min = 0.0f;            // minimum
     float nu_max = 0.9f*M_PI / (float)M; // maximum
@@ -183,7 +183,7 @@ int main(int argc, char*argv[])
     ofdmframesync_destroy(fs);
 
 
-    // 
+    //
     // export output file
     //
 
@@ -194,7 +194,7 @@ int main(int argc, char*argv[])
     return 0;
 }
 
-static int callback(float complex * _X,
+static int callback(_Fcomplex * _X,
                     unsigned char * _p,
                     unsigned int    _M,
                     void *          _userdata)
@@ -209,4 +209,3 @@ static int callback(float complex * _X,
     // internal carrier frequency offset estimate)
     return 0;
 }
-
diff --git a/sandbox/ofdmoqam_firpfbch_cfo_test.c b/sandbox/ofdmoqam_firpfbch_cfo_test.c
index c90cbead..2ebafa1a 100644
--- a/sandbox/ofdmoqam_firpfbch_cfo_test.c
+++ b/sandbox/ofdmoqam_firpfbch_cfo_test.c
@@ -36,8 +36,8 @@ int main() {
     // create filter prototype
     unsigned int h_len = 2*num_channels*m + 1;
     float h[h_len];
-    float complex hc[h_len];
-    float complex gc[h_len];
+    _Fcomplex hc[h_len];
+    _Fcomplex gc[h_len];
     liquid_firdes_rkaiser(num_channels, m, beta, 0.0f, h);
     unsigned int g_len = 2*num_channels*m;
     for (i=0; i<g_len; i++) {
@@ -46,10 +46,10 @@ int main() {
     }
 
     // data arrays
-    float complex s[num_channels];                  // input symbols
-    float complex y[num_samples];                   // time-domain samples
-    float complex Y0[num_frames][num_channels];     // channelized output
-    float complex Y1[num_frames][num_channels];     // channelized output
+    _Fcomplex s[num_channels];                  // input symbols
+    _Fcomplex y[num_samples];                   // time-domain samples
+    _Fcomplex Y0[num_frames][num_channels];     // channelized output
+    _Fcomplex Y1[num_frames][num_channels];     // channelized output
 
     // create ofdm/oqam generator object and generate data
     ofdmoqam qs = ofdmoqam_create(num_channels, m, beta, 0.0f, LIQUID_SYNTHESIZER, 0);
@@ -98,7 +98,7 @@ int main() {
 
     // create objects
     unsigned int gc_sub_len = 2*m;
-    float complex gc_sub[gc_sub_len];
+    _Fcomplex gc_sub[gc_sub_len];
     for (i=0; i<num_channels; i++) {
         // sub-sample prototype filter, loading coefficients in
         // reverse order
@@ -122,15 +122,15 @@ int main() {
     }
 
     // generate DFT object
-    float complex x[num_channels];  // time-domain buffer
-    float complex X[num_channels];  // freq-domain buffer
+    _Fcomplex x[num_channels];  // time-domain buffer
+    _Fcomplex X[num_channels];  // freq-domain buffer
 #if 0
     fftplan fft = fft_create_plan(num_channels, X, x, LIQUID_FFT_BACKWARD, 0);
 #else
     fftplan fft = fft_create_plan(num_channels, X, x, LIQUID_FFT_FORWARD, 0);
 #endif
 
-    // 
+    //
     // run analysis filter bank
     //
 #if 0
@@ -138,8 +138,8 @@ int main() {
 #else
     unsigned int filter_index = num_channels-1;
 #endif
-    float complex y_hat;    // input sample
-    float complex * r;      // read pointer
+    _Fcomplex y_hat;    // input sample
+    _Fcomplex * r;      // read pointer
     for (i=0; i<num_frames; i++) {
 
         // load buffers
@@ -205,7 +205,7 @@ int main() {
     }
 #endif
 
-    // 
+    //
     // export data
     //
     FILE*fid = fopen(OUTPUT_FILENAME,"w");
@@ -219,7 +219,7 @@ int main() {
     fprintf(fid,"y = zeros(1,%u);\n",  num_samples);
     fprintf(fid,"Y0 = zeros(%u,%u);\n", num_frames, num_channels);
     fprintf(fid,"Y1 = zeros(%u,%u);\n", num_frames, num_channels);
-    
+
     for (i=0; i<num_frames; i++) {
         for (j=0; j<num_channels; j++) {
             fprintf(fid,"Y0(%4u,%4u) = %12.4e + j*%12.4e;\n", i+1, j+1, crealf(Y0[i][j]), cimagf(Y0[i][j]));
@@ -240,4 +240,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/ofdmoqam_firpfbch_test.c b/sandbox/ofdmoqam_firpfbch_test.c
index 0fbecb0e..cd648efa 100644
--- a/sandbox/ofdmoqam_firpfbch_test.c
+++ b/sandbox/ofdmoqam_firpfbch_test.c
@@ -47,24 +47,24 @@ int main() {
 
     unsigned int i, j, n=0;
     unsigned int k2 = num_channels/2;
-    float complex X[num_channels];  // channelized symbols
-    float complex y[num_channels];  // interpolated time-domain samples
-    float complex Y[num_channels];  // received symbols
+    _Fcomplex X[num_channels];  // channelized symbols
+    _Fcomplex y[num_channels];  // interpolated time-domain samples
+    _Fcomplex Y[num_channels];  // received symbols
 
     // temporary buffers
-    float complex X0[num_channels];
-    float complex X1[num_channels];
-    float complex y0[num_channels];
-    float complex y1[num_channels];
-    float complex y1_prime[num_channels];
+    _Fcomplex X0[num_channels];
+    _Fcomplex X1[num_channels];
+    _Fcomplex y0[num_channels];
+    _Fcomplex y1[num_channels];
+    _Fcomplex y1_prime[num_channels];
     for (i=0; i<num_channels; i++) y1_prime[i] = 0.0f;
 
-    float complex Z0[num_channels];
-    float complex Z1[num_channels];
-    float complex z0[num_channels];
-    float complex z1[num_channels];
-    //float complex z0_prime[num_channels];
-    //float complex z1_prime[num_channels];
+    _Fcomplex Z0[num_channels];
+    _Fcomplex Z1[num_channels];
+    _Fcomplex z0[num_channels];
+    _Fcomplex z1[num_channels];
+    //_Fcomplex z0_prime[num_channels];
+    //_Fcomplex z1_prime[num_channels];
     for (i=0; i<num_channels; i++) z0[i] = 0.0f;
     for (i=0; i<num_channels; i++) z1[i] = 0.0f;
 
@@ -99,13 +99,13 @@ int main() {
         firpfbch_crcf_synthesizer_execute(cs1, X1, y1);
         // delay lower branch by half a symbol:
         // copy first half of symbol from lower branch
-        memmove(&y1_prime[k2], &y1[0], k2*sizeof(float complex));
+        memmove(&y1_prime[k2], &y1[0], k2*sizeof(_Fcomplex));
         // add symbols
         for (j=0; j<num_channels; j++)
             y[j] = y0[j] + y1_prime[j];
         // finish delay
         // copy last half of symbol from lower branch
-        memmove(&y1_prime[0], &y1[k2], k2*sizeof(float complex));
+        memmove(&y1_prime[0], &y1[k2], k2*sizeof(_Fcomplex));
 
         // channel
 
@@ -113,15 +113,15 @@ int main() {
         //ofdmoqam_execute(ca, y, Y);
         // delay lower branch by half a symbol
         // copy first half of symbol to lower branch
-        memmove(&z1[k2], &y[0], k2*sizeof(float complex));
+        memmove(&z1[k2], &y[0], k2*sizeof(_Fcomplex));
         // run analyzer
         firpfbch_crcf_analyzer_execute(ca0, z0, Z0);
         firpfbch_crcf_analyzer_execute(ca1, z1, Z1);
         // finish delay
         // copy last half of symbol to lower branch
-        memmove(&z1[0], &y[k2], k2*sizeof(float complex));
+        memmove(&z1[0], &y[k2], k2*sizeof(_Fcomplex));
         // copy full symbol on upper branch
-        memmove(z0,y,num_channels*sizeof(float complex));
+        memmove(z0,y,num_channels*sizeof(_Fcomplex));
         for (j=0; j<num_channels; j+=2) {
             // even channels
             Y[j+0] = crealf(Z0[j+0]) + cimagf(Z1[j+0])*_Complex_I;
@@ -181,4 +181,3 @@ int main() {
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/packetizer_persistent_ber_test.c b/sandbox/packetizer_persistent_ber_test.c
index 841e2577..e7e2e4fd 100644
--- a/sandbox/packetizer_persistent_ber_test.c
+++ b/sandbox/packetizer_persistent_ber_test.c
@@ -1,4 +1,4 @@
-// 
+//
 // packetizer_persistent_ber_test.c
 //
 // Simulate persistent decoding error rate using persistent vs.
@@ -100,7 +100,7 @@ int main(int argc, char *argv[]) {
     float rate = (float)n / (float)k;
     unsigned char msg_org[n];       // original data message
     unsigned char msg_enc[k];       // encoded data message
-    float complex sym_rec[8*k];     // received BPSK symbols
+    _Fcomplex sym_rec[8*k];     // received BPSK symbols
     unsigned char msg_cor[k];       // corrupted data message
     unsigned char msg_dec_per0[n];  // decoded data message (regular decoding)
     unsigned char msg_dec_per2[n];  // decoded data message (persistent decoding)
@@ -117,10 +117,10 @@ int main(int argc, char *argv[]) {
     //
     float SNRdB_step = (SNRdB_max - SNRdB_min) / (num_snr-1);
 
-    // 
+    //
     // start trials
     //
-    
+
     printf("  %8s %8s [%6s] %8s %8s %8s %8s\n",
             "SNR [dB]", "Eb/N0", "trials", "per", "(PER)", "reg", "(PER)");
     unsigned int s;
@@ -175,7 +175,7 @@ int main(int argc, char *argv[]) {
             // decode
             packetizer_decode(            q, msg_cor, msg_dec_per0);
             packetizer_decode_persistent2(q, msg_cor, msg_dec_per2);
-            
+
             // tabulate results
             packet_errors_per0[s] += count_bit_errors_array(msg_org, msg_dec_per0, n) ? 1 : 0;
             packet_errors_per2[s] += count_bit_errors_array(msg_org, msg_dec_per2, n) ? 1 : 0;
@@ -193,7 +193,7 @@ int main(int argc, char *argv[]) {
     // clean up objects
     packetizer_destroy(q);
 
-    // 
+    //
     // export output file
     //
     FILE * fid = fopen(OUTPUT_FILENAME, "w");
@@ -288,12 +288,12 @@ int packetizer_decode_persistent(packetizer _p,
             }
         }
     }
-    
+
     // copy result to output and return
     memmove(_msg, _p->buffer_0, _p->msg_len);
     return crc_pass;
 }
-    
+
 // double bit errors in a single byte
 //  nchoosek(8,2) = 28
 unsigned char packetizer_persistent_mask2[28] = {
@@ -388,9 +388,8 @@ int packetizer_decode_persistent2(packetizer _p,
             }
         }
     }
-    
+
     // copy result to output and return
     memmove(_msg, _p->buffer_0, _p->msg_len);
     return crc_pass;
 }
-
diff --git a/sandbox/pll_3rd_order_test.c b/sandbox/pll_3rd_order_test.c
index 17bac7f1..9e34abd0 100644
--- a/sandbox/pll_3rd_order_test.c
+++ b/sandbox/pll_3rd_order_test.c
@@ -38,8 +38,8 @@ int main()
     int i;
     for (i=0; i<n; i++) {
         // compute input and output signals
-        float complex signal_in  = cexpf(_Complex_I * phase_in);
-        float complex signal_out = cexpf(_Complex_I * phase_out);
+        _Fcomplex signal_in  = cexpf(_Complex_I * phase_in);
+        _Fcomplex signal_out = cexpf(_Complex_I * phase_out);
 
         // compute phase error estimate
         float phase_error = cargf( signal_in * conjf(signal_out) );
diff --git a/sandbox/pll_design_test.c b/sandbox/pll_design_test.c
index 86c0955d..4efe1bae 100644
--- a/sandbox/pll_design_test.c
+++ b/sandbox/pll_design_test.c
@@ -1,6 +1,6 @@
 //
 // pll_design_test.c
-// 
+//
 // Demonstrates a basic phase-locked loop to track the phase of a
 // complex sinusoid.
 //
@@ -27,9 +27,9 @@ int main() {
 
     //
     float theta[n];         // input phase
-    float complex x[n];     // input sinusoid
+    _Fcomplex x[n];     // input sinusoid
     float phi[n];           // output phase
-    float complex y[n];     // output sinusoid
+    _Fcomplex y[n];     // output sinusoid
 
     // generate iir loop filter(s)
     float a[3];
diff --git a/sandbox/predemod_sync_test.c b/sandbox/predemod_sync_test.c
index 0706bd2d..2499466b 100644
--- a/sandbox/predemod_sync_test.c
+++ b/sandbox/predemod_sync_test.c
@@ -1,4 +1,4 @@
-// 
+//
 // predemod_sync_test.c
 //
 
@@ -40,7 +40,7 @@ int main(int argc, char*argv[])
     float SNRdB = 30.0f;                // signal-to-noise ratio [dB]
     float dphi = 0.0f;                  // carrier frequency offset
     float phi  = 0.0f;                  // carrier phase offset
-    
+
     unsigned int num_delay_symbols = 12;
     unsigned int num_dphi_hat = 21;     // number of frequency offset estimates
     float dphi_hat_step = 0.01f;        // frequency offset step size
@@ -80,10 +80,10 @@ int main(int argc, char*argv[])
     float nstd = powf(10.0f, -SNRdB/20.0f);
 
     // arrays
-    float complex seq[num_sync_symbols];    // data sequence (symbols)
-    float complex s0[num_sync_samples];     // data sequence (interpolated samples)
-    float complex x[num_samples];           // transmitted signal
-    float complex y[num_samples];           // received signal
+    _Fcomplex seq[num_sync_symbols];    // data sequence (symbols)
+    _Fcomplex s0[num_sync_samples];     // data sequence (interpolated samples)
+    _Fcomplex x[num_samples];           // transmitted signal
+    _Fcomplex y[num_samples];           // received signal
     float rxy[num_dphi_hat][num_samples];   // pre-demod output matrix
 
     // generate sequence
@@ -101,7 +101,7 @@ int main(int argc, char*argv[])
         else                           firinterp_crcf_execute(interp_seq,      0, &s0[k*(i-m)]);
     }
     firinterp_crcf_destroy(interp_seq);
-    
+
     // compute g = E{ |s0|^2 }
     float g = 0.0f;
     for (i=0; i<num_sync_samples; i++)
@@ -130,13 +130,13 @@ int main(int argc, char*argv[])
         y[i] = x[i]*cexp(_Complex_I*(dphi*i + phi)) + nstd*( randnf() + _Complex_I*randnf() );
     }
 
-    float complex z;    // filter output sample
+    _Fcomplex z;    // filter output sample
     for (n=0; n<num_dphi_hat; n++) {
         float dphi_hat = ((float)n - 0.5*(float)(num_dphi_hat-1)) * dphi_hat_step;
         printf("  dphi_hat : %12.8f\n", dphi_hat);
 
         // create flipped, conjugated coefficients
-        float complex s1[num_sync_samples];
+        _Fcomplex s1[num_sync_samples];
         for (i=0; i<num_sync_samples; i++)
             s1[i] = conjf( s0[num_sync_samples-i-1]*cexpf(_Complex_I*(dphi_hat*i)) );
 
@@ -151,11 +151,11 @@ int main(int argc, char*argv[])
         // destroy filter
         firfilt_cccf_destroy(fsync);
     }
-    
+
     // print results
     //printf("rxy (max) : %12.8f\n", rxy_max);
 
-    // 
+    //
     // export results
     //
     FILE * fid = fopen(OUTPUT_FILENAME,"w");
@@ -199,10 +199,10 @@ int main(int argc, char*argv[])
     fprintf(fid,"t=[0:(num_samples-1)]/k;\n");
     fprintf(fid,"figure;\n");
     fprintf(fid,"plot(1:length(s),real(s), 1:length(s),imag(s));\n");
-    
+
     fprintf(fid,"dphi_hat = ( [0:(num_dphi_hat-1)] - (num_dphi_hat-1)/2 ) * dphi_hat_step;\n");
     fprintf(fid,"mesh(dphi_hat, t, rxy');\n");
-    
+
 #if 0
     fprintf(fid,"z = abs( z );\n");
     fprintf(fid,"[zmax i] = max(z);\n");
diff --git a/sandbox/recursive_qpsk_test.c b/sandbox/recursive_qpsk_test.c
index f5505774..1077cfc5 100644
--- a/sandbox/recursive_qpsk_test.c
+++ b/sandbox/recursive_qpsk_test.c
@@ -1,4 +1,4 @@
-// 
+//
 // recursive_qpsk_test.c
 //
 // Run recursive QPSK modulation/demodulation test.
@@ -42,7 +42,7 @@ int main(int argc, char*argv[])
 
     unsigned int i;
 
-    float complex map_qpsk[4] = {
+    _Fcomplex map_qpsk[4] = {
         M_SQRT1_2 + _Complex_I*M_SQRT1_2,   // 00
        -M_SQRT1_2 + _Complex_I*M_SQRT1_2,   // 01
         M_SQRT1_2 - _Complex_I*M_SQRT1_2,   // 10
@@ -50,7 +50,7 @@ int main(int argc, char*argv[])
     };
 
     // generate composite constellation
-    float complex map[16];
+    _Fcomplex map[16];
     for (i=0; i<4; i++) {
         map[4*i+0] = map_qpsk[i] + beta*map_qpsk[0];
         map[4*i+1] = map_qpsk[i] + beta*map_qpsk[1];
@@ -70,7 +70,7 @@ int main(int argc, char*argv[])
     unsigned int    sym_tx_0;
     unsigned int    sym_tx_1;
     unsigned int    sym_tx;
-    float complex   s;
+    _Fcomplex   s;
     unsigned int    sym_rx;
     unsigned int    sym_rx_0;
     unsigned int    sym_rx_1;
@@ -85,7 +85,7 @@ int main(int argc, char*argv[])
     }
 
     unsigned int n;
-    float complex SNRdB_step = (SNRdB_max - SNRdB_min) / (num_snr - 1);
+    _Fcomplex SNRdB_step = (SNRdB_max - SNRdB_min) / (num_snr - 1);
     for (n=0; n<num_snr; n++) {
         float SNRdB = SNRdB_min + n*SNRdB_step;
         float nstd  = powf(10.0f, -SNRdB/20.0f);
@@ -103,7 +103,7 @@ int main(int argc, char*argv[])
 
             // modulate
             modem_modulate(mod, sym_tx, &s);
-            
+
             // add noise
             s += nstd*(randnf() + _Complex_I*randnf())*M_SQRT1_2;
 
@@ -147,4 +147,3 @@ int main(int argc, char*argv[])
     printf("done.\n");
     return 0;
 }
-
diff --git a/sandbox/resamp2_crcf_filterbank_test.c b/sandbox/resamp2_crcf_filterbank_test.c
index 55c28618..eb4f0ef2 100644
--- a/sandbox/resamp2_crcf_filterbank_test.c
+++ b/sandbox/resamp2_crcf_filterbank_test.c
@@ -35,9 +35,9 @@ int main() {
     unsigned int n = N/2;
 
     // arrays
-    float complex x[N];             // input time series
-    float complex y[n][2];          // output time series (channelized)
-    float complex z[N];             // output time series
+    _Fcomplex x[N];             // input time series
+    _Fcomplex y[n][2];          // output time series (channelized)
+    _Fcomplex z[N];             // output time series
 
     // generate input sequence
     unsigned int i;
@@ -68,7 +68,7 @@ int main() {
     // clean up allocated objects
     resamp2_crcf_destroy(q);
 
-    // 
+    //
     // export output file
     //
     FILE*fid = fopen(OUTPUT_FILENAME,"w");
diff --git a/sandbox/resamp2_crcf_interp_recreate_test.c b/sandbox/resamp2_crcf_interp_recreate_test.c
index 2193ac4f..c0b1c625 100644
--- a/sandbox/resamp2_crcf_interp_recreate_test.c
+++ b/sandbox/resamp2_crcf_interp_recreate_test.c
@@ -35,7 +35,7 @@ int main() {
     unsigned int i;
     float theta=0.0f, dtheta=2*M_PI*fc;
     unsigned int ix=0, iy=0;
-    float complex x, y[2];
+    _Fcomplex x, y[2];
     for (i=0; i<N/2; i++) {
         x = cexpf(_Complex_I*theta);
         theta += dtheta;
diff --git a/sandbox/symsync_crcf_test.c b/sandbox/symsync_crcf_test.c
index 34cf8f77..9290c93d 100644
--- a/sandbox/symsync_crcf_test.c
+++ b/sandbox/symsync_crcf_test.c
@@ -113,10 +113,10 @@ int main(int argc, char*argv[]) {
     unsigned int i;
 
     unsigned int num_samples = k*num_symbols;
-    float complex sym_in[num_symbols];          // data symbols
-    float complex x[num_samples];               // interpolated samples
-    float complex y[num_samples];               // noisy samples
-    float complex sym_out[num_symbols + 64];    // synchronized symbols
+    _Fcomplex sym_in[num_symbols];          // data symbols
+    _Fcomplex x[num_samples];               // interpolated samples
+    _Fcomplex y[num_samples];               // noisy samples
+    _Fcomplex sym_out[num_symbols + 64];    // synchronized symbols
 
     // generate random QPSK symbols
     for (i=0; i<num_symbols; i++) {
@@ -166,8 +166,8 @@ int main(int argc, char*argv[]) {
             pfb_timer = 2;  // k samples/symbol
 
             // compute filterbank outputs
-            float complex v  = 0.0f;
-            float complex dv = 0.0f;
+            _Fcomplex v  = 0.0f;
+            _Fcomplex dv = 0.0f;
             firpfb_crcf_execute(mf,  pfb_index, &v);
             firpfb_crcf_execute(dmf, pfb_index, &dv);
 
@@ -194,12 +194,12 @@ int main(int argc, char*argv[]) {
                 pfb_soft  -= npfb;
                 pfb_timer++;
             }
-    
+
             // save debugging outputs
             debug_pfb_error[n]  = pfb_error;
             debug_pfb_q[n]      = pfb_q;
             debug_pfb_soft[n]   = pfb_soft;
-            
+
             // increment output counter
             n++;
         }
@@ -207,7 +207,7 @@ int main(int argc, char*argv[]) {
         // decrement timer
         pfb_timer--;
     }
-    
+
     // destroy filterbanks
     firpfb_crcf_destroy(mf);
     firpfb_crcf_destroy(dmf);
@@ -237,10 +237,10 @@ int main(int argc, char*argv[]) {
 
     for (i=0; i<num_samples; i++)
         fprintf(fid,"x(%3u) = %12.8f + j*%12.8f;\n", i+1, crealf(x[i]), cimagf(x[i]));
-        
+
     for (i=0; i<num_samples; i++)
         fprintf(fid,"y(%3u) = %12.8f + j*%12.8f;\n", i+1, crealf(y[i]), cimagf(y[i]));
-        
+
     for (i=0; i<n; i++) {
         fprintf(fid,"sym_out(%5u)   = %12.8f + j*%12.8f;\n", i+1, crealf(sym_out[i]), cimagf(sym_out[i]));
         fprintf(fid,"pfb_error(%5u) = %12.4e;\n", i+1, debug_pfb_error[i]);
diff --git a/sandbox/symsync_eqlms_test.c b/sandbox/symsync_eqlms_test.c
index 691bd867..ae50537b 100644
--- a/sandbox/symsync_eqlms_test.c
+++ b/sandbox/symsync_eqlms_test.c
@@ -53,7 +53,7 @@ int main(int argc, char*argv[]) {
 
     float bt=0.05f;                 // symbol synchronizer loop filter bandwidth
     float tau=-0.1f;                // fractional symbol offset
-    
+
     int dopt;
     while ((dopt = getopt(argc,argv,"uhk:m:b:n:B:w:p:W:s:c:t:")) != EOF) {
         switch (dopt) {
@@ -123,18 +123,18 @@ int main(int argc, char*argv[]) {
     unsigned int i;
 
     unsigned int num_samples = k*num_symbols;
-    float complex s[num_symbols];               // data symbols
-    float complex x[num_samples];               // interpolated samples
-    float complex y[num_samples];               // channel output
-    float complex z[k*num_symbols + 64];        // synchronized samples
-    float complex sym_out[num_symbols + 64];    // synchronized symbols
+    _Fcomplex s[num_symbols];               // data symbols
+    _Fcomplex x[num_samples];               // interpolated samples
+    _Fcomplex y[num_samples];               // channel output
+    _Fcomplex z[k*num_symbols + 64];        // synchronized samples
+    _Fcomplex sym_out[num_symbols + 64];    // synchronized symbols
 
     for (i=0; i<num_symbols; i++) {
         s[i] = (rand() % 2 ? M_SQRT1_2 : -M_SQRT1_2) +
                (rand() % 2 ? M_SQRT1_2 : -M_SQRT1_2) * _Complex_I;
     }
 
-    // 
+    //
     // create and run interpolator
     //
 
@@ -147,12 +147,12 @@ int main(int argc, char*argv[]) {
     firinterp_crcf_destroy(q);
 
 
-    // 
+    //
     // channel
     //
 
     // generate channel impulse response, filter
-    float complex hc[hc_len];
+    _Fcomplex hc[hc_len];
     hc[0] = 1.0f;
     for (i=1; i<hc_len; i++)
         hc[i] = 0.07f*(randnf() + randnf()*_Complex_I);
@@ -168,7 +168,7 @@ int main(int argc, char*argv[]) {
     firfilt_cccf_destroy(fchannel);
 
 
-    // 
+    //
     // symbol timing recovery
     //
 
@@ -188,18 +188,18 @@ int main(int argc, char*argv[]) {
     symsync_crcf_destroy(d);
 
 
-    // 
+    //
     // equalizer/decimator
     //
 
     // create equalizer as low-pass filter
-    float complex hp[hp_len];
+    _Fcomplex hp[hp_len];
     eqlms_cccf eq = eqlms_cccf_create_lowpass(hp_len, 0.4f);
     eqlms_cccf_set_bw(eq, mu);
 
     // push through equalizer and decimate
     unsigned int num_symbols_sync = 0;
-    float complex d_hat = 0.0f;
+    _Fcomplex d_hat = 0.0f;
     for (i=0; i<num_samples_sync; i++) {
         // push sample into equalizer
         eqlms_cccf_push(eq, z[i]);
@@ -215,7 +215,7 @@ int main(int argc, char*argv[]) {
         if ( i < hp_len ) continue;
 
         // estimate transmitted signal
-        float complex d_prime = (crealf(d_hat) > 0.0f ? M_SQRT1_2 : -M_SQRT1_2) +
+        _Fcomplex d_prime = (crealf(d_hat) > 0.0f ? M_SQRT1_2 : -M_SQRT1_2) +
                                 (cimagf(d_hat) > 0.0f ? M_SQRT1_2 : -M_SQRT1_2) * _Complex_I;
 
         // update equalizer
@@ -261,16 +261,16 @@ int main(int argc, char*argv[]) {
 
     for (i=0; i<num_samples; i++)
         fprintf(fid,"x(%3u) = %12.8f + j*%12.8f;\n", i+1, crealf(x[i]), cimagf(x[i]));
-        
+
     for (i=0; i<num_samples; i++)
         fprintf(fid,"y(%3u) = %12.8f + j*%12.8f;\n", i+1, crealf(y[i]), cimagf(y[i]));
-        
+
     for (i=0; i<num_samples_sync; i++)
         fprintf(fid,"z(%3u) = %12.8f + j*%12.8f;\n", i+1, crealf(z[i]), cimagf(z[i]));
-        
+
     for (i=0; i<num_symbols_sync; i++)
         fprintf(fid,"sym_out(%3u) = %12.8f + j*%12.8f;\n", i+1, crealf(sym_out[i]), cimagf(sym_out[i]));
-        
+
 #if 0
     fprintf(fid,"\n\n");
     fprintf(fid,"%% scale QPSK in-phase by sqrt(2)\n");
diff --git a/sandbox/throttle_test.c b/sandbox/throttle_test.c
index 4ca12e03..2e2b08ac 100644
--- a/sandbox/throttle_test.c
+++ b/sandbox/throttle_test.c
@@ -22,8 +22,8 @@ int main() {
 
     // generate dummy buffers for processing
     unsigned int  buf_len = 1024;
-    float complex buf_0[buf_len];
-    float complex buf_1[buf_len];
+    _Fcomplex buf_0[buf_len];
+    _Fcomplex buf_1[buf_len];
     memset(buf_0, 0x00, buf_len*sizeof(complex float));
 
     // run with updates
@@ -63,4 +63,3 @@ int main() {
     firfilt_crcf_destroy(filter);
     return 0;
 }
-
diff --git a/sandbox/vectorcf_test.c b/sandbox/vectorcf_test.c
index 2993de1c..65f50e4a 100644
--- a/sandbox/vectorcf_test.c
+++ b/sandbox/vectorcf_test.c
@@ -1,6 +1,6 @@
-// 
+//
 // vectorcf_test.c : test complex floating-point vector operations
-// 
+//
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -14,10 +14,10 @@ int main()
 {
     // options
     unsigned int n = 64;
-    
+
     //
     unsigned int i;
-    float complex v[n];
+    _Fcomplex v[n];
     for (i=0; i<n; i++)
         v[i] = cexpf(_Complex_I*(float)i);
 
@@ -33,4 +33,3 @@ int main()
     printf("done.\n");
     return 0;
 }
-
diff --git a/src/agc/bench/agc_crcf_benchmark.c b/src/agc/bench/agc_crcf_benchmark.c
index 34a616dc..737e4829 100644
--- a/src/agc/bench/agc_crcf_benchmark.c
+++ b/src/agc/bench/agc_crcf_benchmark.c
@@ -35,8 +35,8 @@ void benchmark_agc_crcf(struct rusage *     _start,
     agc_crcf q = agc_crcf_create();
     agc_crcf_set_bandwidth(q,0.05f);
 
-    float complex x = 1e-6f;    // input sample
-    float complex y;            // output sample
+    _Fcomplex x = 1e-6f;    // input sample
+    _Fcomplex y;            // output sample
 
     getrusage(RUSAGE_SELF, _start);
     for (i=0; i<(*_num_iterations); i++) {
@@ -56,4 +56,3 @@ void benchmark_agc_crcf(struct rusage *     _start,
     // destroy object
     agc_crcf_destroy(q);
 }
-
diff --git a/src/agc/src/agc_crcf.c b/src/agc/src/agc_crcf.c
index 8bdef67d..4b2fd198 100644
--- a/src/agc/src/agc_crcf.c
+++ b/src/agc/src/agc_crcf.c
@@ -34,7 +34,7 @@
 #define AGC(name)           LIQUID_CONCAT(agc_crcf,name)
 
 #define T                   float           // general
-#define TC                  float complex   // input/output
+#define TC                  _Fcomplex   // input/output
 
 #define TC_COMPLEX          1
 
diff --git a/src/agc/tests/agc_crcf_autotest.c b/src/agc/tests/agc_crcf_autotest.c
index 6c52f929..24ebbe6f 100644
--- a/src/agc/tests/agc_crcf_autotest.c
+++ b/src/agc/tests/agc_crcf_autotest.c
@@ -23,7 +23,7 @@
 #include "autotest/autotest.h"
 #include "liquid.h"
 
-// 
+//
 // Test DC gain control
 //
 void autotest_agc_crcf_dc_gain_control()
@@ -38,11 +38,11 @@ void autotest_agc_crcf_dc_gain_control()
     agc_crcf_set_bandwidth(q, bt);
 
     unsigned int i;
-    float complex x = gamma;    // input sample
-    float complex y;            // output sample
+    _Fcomplex x = gamma;    // input sample
+    _Fcomplex y;            // output sample
     for (i=0; i<256; i++)
         agc_crcf_execute(q, x, &y);
-    
+
     // Check results
     CONTEND_DELTA( crealf(y), 1.0f, tol );
     CONTEND_DELTA( cimagf(y), 0.0f, tol );
@@ -52,7 +52,7 @@ void autotest_agc_crcf_dc_gain_control()
     agc_crcf_destroy(q);
 }
 
-// 
+//
 // Test AC gain control
 //
 void autotest_agc_crcf_ac_gain_control()
@@ -68,8 +68,8 @@ void autotest_agc_crcf_ac_gain_control()
     agc_crcf_set_bandwidth(q, bt);
 
     unsigned int i;
-    float complex x;
-    float complex y;
+    _Fcomplex x;
+    _Fcomplex y;
     for (i=0; i<256; i++) {
         x = gamma * cexpf(_Complex_I*i*dphi);
         agc_crcf_execute(q, x, &y);
@@ -87,7 +87,7 @@ void autotest_agc_crcf_ac_gain_control()
 
 
 
-// 
+//
 // Test RSSI on sinusoidal input
 //
 void autotest_agc_crcf_rssi_sinusoid()
@@ -105,7 +105,7 @@ void autotest_agc_crcf_rssi_sinusoid()
     agc_crcf_set_bandwidth(q, bt);
 
     unsigned int i;
-    float complex x, y;
+    _Fcomplex x, y;
     for (i=0; i<512; i++) {
         // generate sample (complex sinusoid)
         x = gamma * cexpf(_Complex_I*dphi*i);
@@ -128,7 +128,7 @@ void autotest_agc_crcf_rssi_sinusoid()
 }
 
 
-// 
+//
 // Test RSSI on noise input
 //
 void autotest_agc_crcf_rssi_noise()
@@ -146,7 +146,7 @@ void autotest_agc_crcf_rssi_noise()
     agc_crcf_set_bandwidth(q, bt);
 
     unsigned int i;
-    float complex x, y;
+    _Fcomplex x, y;
     for (i=0; i<8000; i++) {
         // generate sample (circular complex noise)
         x = nstd*(randnf() + _Complex_I*randnf())*M_SQRT1_2;
@@ -168,7 +168,7 @@ void autotest_agc_crcf_rssi_noise()
     agc_crcf_destroy(q);
 }
 
-// 
+//
 // Test squelch functionality
 //
 void autotest_agc_crcf_squelch()
@@ -194,10 +194,10 @@ void autotest_agc_crcf_squelch()
         else if (i < 1450) gamma = 1e-2f;
         else if (i < 1500) gamma = 1e-3f + (1e-2f - 1e-3f)*(0.5f + 0.5f*cosf(M_PI*(float)(i-1450)/50.0f));
         else               gamma = 1e-3f;
-        float complex x = gamma * cexpf(_Complex_I*2*M_PI*0.0193f*i);
+        _Fcomplex x = gamma * cexpf(_Complex_I*2*M_PI*0.0193f*i);
 
         // apply gain
-        float complex y;
+        _Fcomplex y;
         agc_crcf_execute(q, x, &y);
 
         // retrieve signal level [dB]
@@ -222,6 +222,3 @@ void autotest_agc_crcf_squelch()
     // destroy AGC object
     agc_crcf_destroy(q);
 }
-
-
-
diff --git a/src/buffer/bench/cbuffercf_benchmark.c b/src/buffer/bench/cbuffercf_benchmark.c
index b729eae8..2690e7a3 100644
--- a/src/buffer/bench/cbuffercf_benchmark.c
+++ b/src/buffer/bench/cbuffercf_benchmark.c
@@ -57,9 +57,9 @@ void cbuffercf_bench(struct rusage *     _start,
     // create object
     cbuffercf q = cbuffercf_create(_n);
 
-    // 
-    float complex   v[_write_size]; // array for writing
-    float complex * r;              // read pointer
+    //
+    _Fcomplex   v[_write_size]; // array for writing
+    _Fcomplex * r;              // read pointer
     unsigned int num_requested;     // number of elements requested
     unsigned int num_read;          // number of elements read
 
@@ -98,7 +98,7 @@ void cbuffercf_bench(struct rusage *     _start,
     cbuffercf_destroy(q);
 }
 
-// 
+//
 void benchmark_cbuffercf_n16     CBUFFERCF_BENCH_API(  16,  12,  11);
 void benchmark_cbuffercf_n32     CBUFFERCF_BENCH_API(  32,  24,  23);
 void benchmark_cbuffercf_n64     CBUFFERCF_BENCH_API(  64,  48,  47);
@@ -106,4 +106,3 @@ void benchmark_cbuffercf_n128    CBUFFERCF_BENCH_API( 128,  96,  95);
 void benchmark_cbuffercf_n256    CBUFFERCF_BENCH_API( 256, 192, 191);
 void benchmark_cbuffercf_n512    CBUFFERCF_BENCH_API( 512, 384, 383);
 void benchmark_cbuffercf_n1024   CBUFFERCF_BENCH_API(1024, 768, 767);
-
diff --git a/src/buffer/bench/window_read_benchmark.c b/src/buffer/bench/window_read_benchmark.c
index 2a943659..78ef10fc 100644
--- a/src/buffer/bench/window_read_benchmark.c
+++ b/src/buffer/bench/window_read_benchmark.c
@@ -43,7 +43,7 @@ void window_read_bench(struct rusage *_start,
 
     unsigned long int i;
 
-    float complex * r;
+    _Fcomplex * r;
 
     // start trials:
     //   write to buffer, read from buffer
@@ -60,10 +60,9 @@ void window_read_bench(struct rusage *_start,
     windowcf_destroy(w);
 }
 
-// 
+//
 void benchmark_windowcf_read_n16    WINDOW_READ_BENCH_API(16)
 void benchmark_windowcf_read_n32    WINDOW_READ_BENCH_API(32)
 void benchmark_windowcf_read_n64    WINDOW_READ_BENCH_API(64)
 void benchmark_windowcf_read_n128   WINDOW_READ_BENCH_API(128)
 void benchmark_windowcf_read_n256   WINDOW_READ_BENCH_API(256)
-
diff --git a/src/buffer/src/buffercf.c b/src/buffer/src/buffercf.c
index 65c45f0f..0e51b867 100644
--- a/src/buffer/src/buffercf.c
+++ b/src/buffer/src/buffercf.c
@@ -36,7 +36,7 @@
 #define WDELAY(name)    LIQUID_CONCAT(wdelaycf,  name)
 #define WINDOW(name)    LIQUID_CONCAT(windowcf,  name)
 
-#define T float complex
+#define T _Fcomplex
 #define BUFFER_PRINT_LINE(B,I) \
     printf("  : %12.8f + %12.8f", crealf(B->v[I]), cimagf(B->v[I]));
 #define BUFFER_PRINT_VALUE(V) \
@@ -46,4 +46,3 @@
 //#include "sbuffer.c"
 #include "window.c"
 #include "wdelay.c"
-
diff --git a/src/buffer/tests/cbuffer_autotest.c b/src/buffer/tests/cbuffer_autotest.c
index 73342c33..13c6594e 100644
--- a/src/buffer/tests/cbuffer_autotest.c
+++ b/src/buffer/tests/cbuffer_autotest.c
@@ -103,11 +103,11 @@ void autotest_cbufferf()
 }
 
 
-// complex float complexing point
+// complex _Fcomplexing point
 void autotest_cbuffercf()
 {
     // input array of values
-    float complex v[] = {1.0 - 1.0 * _Complex_I,
+    _Fcomplex v[] = {1.0 - 1.0 * _Complex_I,
                          2.0 + 2.0 * _Complex_I,
                          3.0 - 3.0 * _Complex_I,
                          4.0 + 4.0 * _Complex_I,
@@ -117,11 +117,11 @@ void autotest_cbuffercf()
                          8.0 + 8.0 * _Complex_I};
 
     // output test arrays
-    float complex test1[] = {1.0 - 1.0 * _Complex_I,
+    _Fcomplex test1[] = {1.0 - 1.0 * _Complex_I,
                              2.0 + 2.0 * _Complex_I,
                              3.0 - 3.0 * _Complex_I,
                              4.0 + 4.0 * _Complex_I};
-    float complex test2[] = {3.0 - 3.0 * _Complex_I,
+    _Fcomplex test2[] = {3.0 - 3.0 * _Complex_I,
                              4.0 + 4.0 * _Complex_I,
                              1.0 - 1.0 * _Complex_I,
                              2.0 + 2.0 * _Complex_I,
@@ -131,13 +131,13 @@ void autotest_cbuffercf()
                              6.0 + 6.0 * _Complex_I,
                              7.0 - 7.0 * _Complex_I,
                              8.0 + 8.0 * _Complex_I};
-    float complex test3[] = {3.0 - 3.0 * _Complex_I,
+    _Fcomplex test3[] = {3.0 - 3.0 * _Complex_I,
                              4.0 + 4.0 * _Complex_I,
                              5.0 - 5.0 * _Complex_I,
                              6.0 + 6.0 * _Complex_I,
                              7.0 - 7.0 * _Complex_I,
                              8.0 + 8.0 * _Complex_I};
-    float complex test4[] = {3.0 - 3.0 * _Complex_I,
+    _Fcomplex test4[] = {3.0 - 3.0 * _Complex_I,
                              4.0 + 4.0 * _Complex_I,
                              5.0 - 5.0 * _Complex_I,
                              6.0 + 6.0 * _Complex_I,
@@ -146,7 +146,7 @@ void autotest_cbuffercf()
                              1.0 - 1.0 * _Complex_I,
                              2.0 + 2.0 * _Complex_I,
                              3.0 - 3.0 * _Complex_I};
-    float complex *r;           // output read pointer
+    _Fcomplex *r;           // output read pointer
     unsigned int num_requested; // number of samples requested
     unsigned int num_read;      // number of samples read
 
@@ -162,7 +162,7 @@ void autotest_cbuffercf()
     num_requested = 4;
     cbuffercf_read(q, num_requested, &r, &num_read);
     CONTEND_EQUALITY(num_read,4);
-    CONTEND_SAME_DATA(r,test1,4*sizeof(float complex));
+    CONTEND_SAME_DATA(r,test1,4*sizeof(_Fcomplex));
 
     // part 3: release two elements, write 8 more, read 10
     cbuffercf_release(q, 2);
@@ -172,7 +172,7 @@ void autotest_cbuffercf()
     num_requested = 10;
     cbuffercf_read(q, num_requested, &r, &num_read);
     CONTEND_EQUALITY(num_read,10);
-    CONTEND_SAME_DATA(r,test2,10*sizeof(float complex));
+    CONTEND_SAME_DATA(r,test2,10*sizeof(_Fcomplex));
 
     // part 4: pop single element from buffer
     CONTEND_EQUALITY( cbuffercf_size(q), 10    );
@@ -188,7 +188,7 @@ void autotest_cbuffercf()
     num_requested = 10;
     cbuffercf_read(q, num_requested, &r, &num_read);
     CONTEND_EQUALITY(num_read,6);
-    CONTEND_SAME_DATA(r,test3,6*sizeof(float complex));
+    CONTEND_SAME_DATA(r,test3,6*sizeof(_Fcomplex));
 
     // part 6: test pushing multiple elements
     cbuffercf_push(q, 1.0 - 1.0 * _Complex_I);
@@ -198,7 +198,7 @@ void autotest_cbuffercf()
     num_requested = 10;
     cbuffercf_read(q, num_requested, &r, &num_read);
     CONTEND_EQUALITY(num_read,9);
-    CONTEND_SAME_DATA(r,test4,9*sizeof(float complex));
+    CONTEND_SAME_DATA(r,test4,9*sizeof(_Fcomplex));
 
     // part 7: add one more element; buffer should be full
     CONTEND_EXPRESSION( cbuffercf_is_full(q)==0 );
@@ -254,7 +254,7 @@ void autotest_cbufferf_flow()
 
         // read some values
         unsigned int num_available_to_read = cbufferf_size(q);
-        
+
         // read samples if available
         if (num_available_to_read > 0) {
             // number of elements to read
@@ -283,12 +283,10 @@ void autotest_cbufferf_flow()
         if (!success || read_id >= num_elements)
             break;
     }
-    
+
     // ensure test was successful
     CONTEND_EXPRESSION(success == 1);
 
     // destroy object
     cbufferf_destroy(q);
 }
-
-
diff --git a/src/buffer/tests/sbuffer_autotest.c b/src/buffer/tests/sbuffer_autotest.c
index 78f4baa8..38ea18b3 100644
--- a/src/buffer/tests/sbuffer_autotest.c
+++ b/src/buffer/tests/sbuffer_autotest.c
@@ -74,7 +74,7 @@ void autotest_fbuffer_static()
 //
 void autotest_cfbuffer_static()
 {
-    SBUFFER_AUTOTEST_DEFINE_API(BUFFER_MANGLE_CFLOAT, float complex)
+    SBUFFER_AUTOTEST_DEFINE_API(BUFFER_MANGLE_CFLOAT, _Fcomplex)
 }
 
 
@@ -87,4 +87,3 @@ void xautotest_uibuffer_static()
     SBUFFER_AUTOTEST_DEFINE_API(BUFFER_MANGLE_UINT, unsigned int)
 }
 #endif
-
diff --git a/src/channel/src/channel.c b/src/channel/src/channel.c
index fbe7f160..c1afcc16 100644
--- a/src/channel/src/channel.c
+++ b/src/channel/src/channel.c
@@ -164,13 +164,13 @@ void CHANNEL(_add_multipath)(CHANNEL()    _q,
     _q->enabled_multipath = 1;
 
     // set values appropriately
-    // TODO: test for types other than float complex
+    // TODO: test for types other than _Fcomplex
     if (_q->h_len != _h_len)
         _q->h = (TC*) realloc(_q->h, _h_len*sizeof(TC));
 
     // update length
     _q->h_len = _h_len;
-    
+
     // copy coefficients internally
     if (_h == NULL) {
         // generate random coefficients using m-sequence generator
@@ -236,7 +236,7 @@ void CHANNEL(_execute)(CHANNEL() _q,
                        TI        _x,
                        TO *      _y)
 {
-    float complex r;
+    _Fcomplex r;
     // apply filter
     if (_q->enabled_multipath) {
         FIRFILT(_push)(   _q->channel_filter, _x);
@@ -287,4 +287,3 @@ void CHANNEL(_execute_block)(CHANNEL()    _q,
     for (i=0; i<_n; i++)
         CHANNEL(_execute)(_q, _x[i], &_y[i]);
 }
-
diff --git a/src/channel/src/channel_cccf.c b/src/channel/src/channel_cccf.c
index 69888ba8..6fe161ab 100644
--- a/src/channel/src/channel_cccf.c
+++ b/src/channel/src/channel_cccf.c
@@ -20,7 +20,7 @@
  * THE SOFTWARE.
  */
 
-// 
+//
 // Complex floating-point channel
 //
 
@@ -40,13 +40,12 @@
 #define TVMPCH(name)    LIQUID_CONCAT(tvmpch_cccf,name)
 #define WINDOW(name)    LIQUID_CONCAT(windowcf,name)
 
-#define TO              float complex   // output type
-#define TC              float complex   // coefficients type
-#define TI              float complex   // input type
+#define TO              _Fcomplex   // output type
+#define TC              _Fcomplex   // coefficients type
+#define TI              _Fcomplex   // input type
 #define T               float           // primitive type
 
 #define PRINTVAL_TC(X,F) PRINTVAL_CFLOAT(X,F)
 
 #include "channel.c"
 #include "tvmpch.c"
-
diff --git a/src/channel/src/tvmpch.c b/src/channel/src/tvmpch.c
index e932e47a..ecf4d02b 100644
--- a/src/channel/src/tvmpch.c
+++ b/src/channel/src/tvmpch.c
@@ -178,10 +178,10 @@ unsigned int TVMPCH(_get_length)(TVMPCH() _q)
 //  _H      :   output frequency response
 void TVMPCH(_freqresponse)(TVMPCH()        _q,
                            float           _fc,
-                           float complex * _H)
+                           _Fcomplex * _H)
 {
     unsigned int i;
-    float complex H = 0.0f;
+    _Fcomplex H = 0.0f;
 
     // compute dot product between coefficients and exp{ 2 pi fc {0..n-1} }
     for (i=0; i<_q->h_len; i++)
diff --git a/src/dotprod/bench/dotprod_cccf_benchmark.c b/src/dotprod/bench/dotprod_cccf_benchmark.c
index 54e327ff..96cb4d01 100644
--- a/src/dotprod/bench/dotprod_cccf_benchmark.c
+++ b/src/dotprod/bench/dotprod_cccf_benchmark.c
@@ -34,9 +34,9 @@ void dotprod_cccf_bench(struct rusage *_start,
     *_num_iterations /= _n;
     if (*_num_iterations < 1) *_num_iterations = 1;
 
-    float complex x[_n];
-    float complex h[_n];
-    float complex y[8];
+    _Fcomplex x[_n];
+    _Fcomplex h[_n];
+    _Fcomplex y[8];
     unsigned int i;
     for (i=0; i<_n; i++) {
         x[i] = randnf() + _Complex_I*randnf();
@@ -75,4 +75,3 @@ void benchmark_dotprod_cccf_4      DOTPROD_CCCF_BENCHMARK_API(4)
 void benchmark_dotprod_cccf_16     DOTPROD_CCCF_BENCHMARK_API(16)
 void benchmark_dotprod_cccf_64     DOTPROD_CCCF_BENCHMARK_API(64)
 void benchmark_dotprod_cccf_256    DOTPROD_CCCF_BENCHMARK_API(256)
-
diff --git a/src/dotprod/bench/dotprod_crcf_benchmark.c b/src/dotprod/bench/dotprod_crcf_benchmark.c
index 2734246d..c4189a7e 100644
--- a/src/dotprod/bench/dotprod_crcf_benchmark.c
+++ b/src/dotprod/bench/dotprod_crcf_benchmark.c
@@ -34,9 +34,9 @@ void dotprod_crcf_bench(struct rusage *_start,
     *_num_iterations /= _n;
     if (*_num_iterations < 1) *_num_iterations = 1;
 
-    float complex x[_n];
+    _Fcomplex x[_n];
     float h[_n];
-    float complex y[8];
+    _Fcomplex y[8];
     unsigned int i;
     for (i=0; i<_n; i++) {
         x[i] = randnf() + _Complex_I*randnf();
@@ -75,4 +75,3 @@ void benchmark_dotprod_crcf_4      DOTPROD_CRCF_BENCHMARK_API(4)
 void benchmark_dotprod_crcf_16     DOTPROD_CRCF_BENCHMARK_API(16)
 void benchmark_dotprod_crcf_64     DOTPROD_CRCF_BENCHMARK_API(64)
 void benchmark_dotprod_crcf_256    DOTPROD_CRCF_BENCHMARK_API(256)
-
diff --git a/src/dotprod/bench/sumsqcf_benchmark.c b/src/dotprod/bench/sumsqcf_benchmark.c
index e2cb98db..f0418acd 100644
--- a/src/dotprod/bench/sumsqcf_benchmark.c
+++ b/src/dotprod/bench/sumsqcf_benchmark.c
@@ -34,8 +34,8 @@ void sumsqcf_bench(struct rusage *     _start,
     *_num_iterations /= _n;
     if (*_num_iterations < 1) *_num_iterations = 1;
 
-    float complex x[_n];
-    float complex y = 0.0f;
+    _Fcomplex x[_n];
+    _Fcomplex y = 0.0f;
     unsigned int long i;
     for (i=0; i<_n; i++)
         x[i] = 0.2f + 0.2f*_Complex_I;
@@ -65,4 +65,3 @@ void benchmark_sumsqcf_4        SUMSQCF_BENCHMARK_API(4)
 void benchmark_sumsqcf_16       SUMSQCF_BENCHMARK_API(16)
 void benchmark_sumsqcf_64       SUMSQCF_BENCHMARK_API(64)
 void benchmark_sumsqcf_256      SUMSQCF_BENCHMARK_API(256)
-
diff --git a/src/dotprod/src/dotprod_cccf.c b/src/dotprod/src/dotprod_cccf.c
index e9814606..6d83906f 100644
--- a/src/dotprod/src/dotprod_cccf.c
+++ b/src/dotprod/src/dotprod_cccf.c
@@ -20,7 +20,7 @@
  * THE SOFTWARE.
  */
 
-// 
+//
 // Complex floating-point dot product
 //
 
@@ -28,8 +28,8 @@
 #include "liquid.internal.h"
 
 #define DOTPROD(name)   LIQUID_CONCAT(dotprod_cccf,name)
-#define TO              float complex
-#define TC              float complex
-#define TI              float complex
+#define TO              _Fcomplex
+#define TC              _Fcomplex
+#define TI              _Fcomplex
 
 #include "dotprod.c"
diff --git a/src/dotprod/src/dotprod_cccf.mmx.c b/src/dotprod/src/dotprod_cccf.mmx.c
index fa50b820..668bcdb0 100644
--- a/src/dotprod/src/dotprod_cccf.mmx.c
+++ b/src/dotprod/src/dotprod_cccf.mmx.c
@@ -20,7 +20,7 @@
  * THE SOFTWARE.
  */
 
-// 
+//
 // Floating-point dot product (MMX)
 //
 
@@ -53,20 +53,20 @@
 
 // forward declaration of internal methods
 void dotprod_cccf_execute_mmx(dotprod_cccf    _q,
-                              float complex * _x,
-                              float complex * _y);
+                              _Fcomplex * _x,
+                              _Fcomplex * _y);
 
 void dotprod_cccf_execute_mmx4(dotprod_cccf    _q,
-                               float complex * _x,
-                               float complex * _y);
+                               _Fcomplex * _x,
+                               _Fcomplex * _y);
 
 // basic dot product (ordinal calculation)
-void dotprod_cccf_run(float complex * _h,
-                      float complex * _x,
+void dotprod_cccf_run(_Fcomplex * _h,
+                      _Fcomplex * _x,
                       unsigned int    _n,
-                      float complex * _y)
+                      _Fcomplex * _y)
 {
-    float complex r = 0;
+    _Fcomplex r = 0;
     unsigned int i;
     for (i=0; i<_n; i++)
         r += _h[i] * _x[i];
@@ -74,15 +74,15 @@ void dotprod_cccf_run(float complex * _h,
 }
 
 // basic dot product (ordinal calculation) with loop unrolled
-void dotprod_cccf_run4(float complex * _h,
-                       float complex * _x,
+void dotprod_cccf_run4(_Fcomplex * _h,
+                       _Fcomplex * _x,
                        unsigned int    _n,
-                       float complex * _y)
+                       _Fcomplex * _y)
 {
-    float complex r = 0;
+    _Fcomplex r = 0;
 
     // t = 4*(floor(_n/4))
-    unsigned int t=(_n>>2)<<2; 
+    unsigned int t=(_n>>2)<<2;
 
     // compute dotprod in groups of 4
     unsigned int i;
@@ -111,7 +111,7 @@ struct dotprod_cccf_s {
     float * hq;         // quadrature
 };
 
-dotprod_cccf dotprod_cccf_create(float complex * _h,
+dotprod_cccf dotprod_cccf_create(_Fcomplex * _h,
                                  unsigned int    _n)
 {
     dotprod_cccf q = (dotprod_cccf)malloc(sizeof(struct dotprod_cccf_s));
@@ -139,7 +139,7 @@ dotprod_cccf dotprod_cccf_create(float complex * _h,
 
 // re-create the structured dotprod object
 dotprod_cccf dotprod_cccf_recreate(dotprod_cccf    _q,
-                                   float complex * _h,
+                                   _Fcomplex * _h,
                                    unsigned int    _n)
 {
     // completely destroy and re-create dotprod object
@@ -168,8 +168,8 @@ void dotprod_cccf_print(dotprod_cccf _q)
 //  _x      :   input array
 //  _y      :   output sample
 void dotprod_cccf_execute(dotprod_cccf    _q,
-                          float complex * _x,
-                          float complex * _y)
+                          _Fcomplex * _x,
+                          _Fcomplex * _y)
 {
     // switch based on size
     if (_q->n < 32) {
@@ -200,8 +200,8 @@ void dotprod_cccf_execute(dotprod_cccf    _q,
 //           x[1].imag * h[1].imag };
 //
 void dotprod_cccf_execute_mmx(dotprod_cccf    _q,
-                              float complex * _x,
-                              float complex * _y)
+                              _Fcomplex * _x,
+                              _Fcomplex * _y)
 {
     // type cast input as floating point array
     float * x = (float*) _x;
@@ -249,7 +249,7 @@ void dotprod_cccf_execute_mmx(dotprod_cccf    _q,
 
         // shuffle values
         cq = _mm_shuffle_ps( cq, cq, _MM_SHUFFLE(2,3,0,1) );
-        
+
 #if HAVE_SSE3 && HAVE_PMMINTRIN_H
         // SSE3: combine using addsub_ps()
         s = _mm_addsub_ps( ci, cq );
@@ -280,8 +280,8 @@ void dotprod_cccf_execute_mmx(dotprod_cccf    _q,
     w[0] += w[2];   // I
     w[1] += w[3];   // Q
 
-    //float complex total = *((float complex*)w);
-    float complex total = w[0] + w[1] * _Complex_I;
+    //_Fcomplex total = *((_Fcomplex*)w);
+    _Fcomplex total = w[0] + w[1] * _Complex_I;
 
     // cleanup
     for (i=t/2; i<_q->n; i++)
@@ -293,8 +293,8 @@ void dotprod_cccf_execute_mmx(dotprod_cccf    _q,
 
 // use MMX/SSE extensions
 void dotprod_cccf_execute_mmx4(dotprod_cccf    _q,
-                               float complex * _x,
-                               float complex * _y)
+                               _Fcomplex * _x,
+                               _Fcomplex * _y)
 {
     // type cast input as floating point array
     float * x = (float*) _x;
@@ -336,7 +336,7 @@ void dotprod_cccf_execute_mmx4(dotprod_cccf    _q,
         hq1 = _mm_load_ps(&_q->hq[4*i+4]);
         hq2 = _mm_load_ps(&_q->hq[4*i+8]);
         hq3 = _mm_load_ps(&_q->hq[4*i+12]);
-        
+
         // compute parallel multiplications (real)
         ci0 = _mm_mul_ps(v0, hi0);
         ci1 = _mm_mul_ps(v1, hi1);
@@ -366,7 +366,7 @@ void dotprod_cccf_execute_mmx4(dotprod_cccf    _q,
     _mm_store_ps(wq, sumq);
 
     // fold down (add/sub)
-    float complex total = 
+    _Fcomplex total =
         ((wi[0] - wq[0]) + (wi[2] - wq[2])) +
         ((wi[1] + wq[1]) + (wi[3] + wq[3])) * _Complex_I;
 
@@ -379,4 +379,3 @@ void dotprod_cccf_execute_mmx4(dotprod_cccf    _q,
     // set return value
     *_y = total;
 }
-
diff --git a/src/dotprod/src/dotprod_cccf.neon.c b/src/dotprod/src/dotprod_cccf.neon.c
index c12df321..3cd9d273 100644
--- a/src/dotprod/src/dotprod_cccf.neon.c
+++ b/src/dotprod/src/dotprod_cccf.neon.c
@@ -20,7 +20,7 @@
  * THE SOFTWARE.
  */
 
-// 
+//
 // Floating-point dot product (ARM Neon)
 //
 
@@ -37,20 +37,20 @@
 
 // forward declaration of internal methods
 void dotprod_cccf_execute_neon(dotprod_cccf    _q,
-                               float complex * _x,
-                               float complex * _y);
+                               _Fcomplex * _x,
+                               _Fcomplex * _y);
 
 void dotprod_cccf_execute_neon4(dotprod_cccf    _q,
-                                float complex * _x,
-                                float complex * _y);
+                                _Fcomplex * _x,
+                                _Fcomplex * _y);
 
 // basic dot product (ordinal calculation)
-void dotprod_cccf_run(float complex * _h,
-                      float complex * _x,
+void dotprod_cccf_run(_Fcomplex * _h,
+                      _Fcomplex * _x,
                       unsigned int    _n,
-                      float complex * _y)
+                      _Fcomplex * _y)
 {
-    float complex r = 0;
+    _Fcomplex r = 0;
     unsigned int i;
     for (i=0; i<_n; i++)
         r += _h[i] * _x[i];
@@ -58,15 +58,15 @@ void dotprod_cccf_run(float complex * _h,
 }
 
 // basic dot product (ordinal calculation) with loop unrolled
-void dotprod_cccf_run4(float complex * _h,
-                       float complex * _x,
+void dotprod_cccf_run4(_Fcomplex * _h,
+                       _Fcomplex * _x,
                        unsigned int    _n,
-                       float complex * _y)
+                       _Fcomplex * _y)
 {
-    float complex r = 0;
+    _Fcomplex r = 0;
 
     // t = 4*(floor(_n/4))
-    unsigned int t=(_n>>2)<<2; 
+    unsigned int t=(_n>>2)<<2;
 
     // compute dotprod in groups of 4
     unsigned int i;
@@ -95,7 +95,7 @@ struct dotprod_cccf_s {
     float * hq;         // quadrature
 };
 
-dotprod_cccf dotprod_cccf_create(float complex * _h,
+dotprod_cccf dotprod_cccf_create(_Fcomplex * _h,
                                  unsigned int    _n)
 {
     dotprod_cccf q = (dotprod_cccf)malloc(sizeof(struct dotprod_cccf_s));
@@ -123,7 +123,7 @@ dotprod_cccf dotprod_cccf_create(float complex * _h,
 
 // re-create the structured dotprod object
 dotprod_cccf dotprod_cccf_recreate(dotprod_cccf    _q,
-                                   float complex * _h,
+                                   _Fcomplex * _h,
                                    unsigned int    _n)
 {
     // completely destroy and re-create dotprod object
@@ -155,8 +155,8 @@ void dotprod_cccf_print(dotprod_cccf _q)
 //  _x      :   input array
 //  _y      :   output sample
 void dotprod_cccf_execute(dotprod_cccf    _q,
-                          float complex * _x,
-                          float complex * _y)
+                          _Fcomplex * _x,
+                          _Fcomplex * _y)
 {
     // switch based on size
     if (_q->n < 32) {
@@ -187,8 +187,8 @@ void dotprod_cccf_execute(dotprod_cccf    _q,
 //           x[1].imag * h[1].imag };
 //
 void dotprod_cccf_execute_neon(dotprod_cccf    _q,
-                               float complex * _x,
-                               float complex * _y)
+                               _Fcomplex * _x,
+                               _Fcomplex * _y)
 {
     // type cast input as floating point array
     float * x = (float*) _x;
@@ -240,7 +240,7 @@ void dotprod_cccf_execute_neon(dotprod_cccf    _q,
     vst1q_f32(wq, sumq);
 
     // fold down (add/sub)
-    float complex total = 
+    _Fcomplex total =
         ((wi[0] - wq[1]) + (wi[2] - wq[3])) +
         ((wi[1] + wq[0]) + (wi[3] + wq[2])) * _Complex_I;
 
@@ -255,8 +255,8 @@ void dotprod_cccf_execute_neon(dotprod_cccf    _q,
 // use ARM Neon extensions (unrolled loop)
 // NOTE: unrolling doesn't show any appreciable performance difference
 void dotprod_cccf_execute_neon4(dotprod_cccf    _q,
-                                float complex * _x,
-                                float complex * _y)
+                                _Fcomplex * _x,
+                                _Fcomplex * _y)
 {
     // type cast input as floating point array
     float * x = (float*) _x;
@@ -299,7 +299,7 @@ void dotprod_cccf_execute_neon4(dotprod_cccf    _q,
         hq1 = vld1q_f32(&_q->hq[4*i+4]);
         hq2 = vld1q_f32(&_q->hq[4*i+8]);
         hq3 = vld1q_f32(&_q->hq[4*i+12]);
-        
+
         // compute parallel multiplications (real)
         ci0 = vmulq_f32(v0, hi0);
         ci1 = vmulq_f32(v1, hi1);
@@ -326,7 +326,7 @@ void dotprod_cccf_execute_neon4(dotprod_cccf    _q,
     vst1q_f32(wq, sumq);
 
     // fold down (add/sub)
-    float complex total = 
+    _Fcomplex total =
         ((wi[0] - wq[1]) + (wi[2] - wq[3])) +
         ((wi[1] + wq[0]) + (wi[3] + wq[2])) * _Complex_I;
 
@@ -339,4 +339,3 @@ void dotprod_cccf_execute_neon4(dotprod_cccf    _q,
     // set return value
     *_y = total;
 }
-
diff --git a/src/dotprod/src/dotprod_crcf.av.c b/src/dotprod/src/dotprod_crcf.av.c
index ba40595b..78ddada0 100644
--- a/src/dotprod/src/dotprod_crcf.av.c
+++ b/src/dotprod/src/dotprod_crcf.av.c
@@ -20,7 +20,7 @@
  * THE SOFTWARE.
  */
 
-// 
+//
 // Complex floating-point dot product (altivec velocity engine)
 //
 
@@ -39,11 +39,11 @@
 //  _n      :   input lengths
 //  _y      :   output dot product
 void dotprod_crcf_run(float *         _h,
-                      float complex * _x,
+                      _Fcomplex * _x,
                       unsigned int    _n,
-                      float complex * _y)
+                      _Fcomplex * _y)
 {
-    float complex r=0;
+    _Fcomplex r=0;
     unsigned int i;
     for (i=0; i<_n; i++)
         r += _h[i] * _x[i];
@@ -56,14 +56,14 @@ void dotprod_crcf_run(float *         _h,
 //  _n      :   input lengths
 //  _y      :   output dot product
 void dotprod_crcf_run4(float *         _h,
-                       float complex * _x,
+                       _Fcomplex * _x,
                        unsigned int    _n,
-                       float complex * _y)
+                       _Fcomplex * _y)
 {
-    float complex r=0;
+    _Fcomplex r=0;
 
     // t = 4*(floor(_n/4))
-    unsigned int t=(_n>>2)<<2; 
+    unsigned int t=(_n>>2)<<2;
 
     // compute dotprod in groups of 4
     unsigned int i;
@@ -158,8 +158,8 @@ void dotprod_crcf_print(dotprod_crcf _q)
 
 // exectue vectorized structured inner dot product
 void dotprod_crcf_execute(dotprod_crcf    _q,
-                          float complex * _x,
-                          float complex * _r)
+                          _Fcomplex * _x,
+                          _Fcomplex * _r)
 {
     int al; // input data alignment
 
@@ -206,4 +206,3 @@ void dotprod_crcf_execute(dotprod_crcf    _q,
     //*_r = s.w[0] + s.w[1] + s.w[2] + s.w[3];
     *_r = (s.w[0] + s.w[2]) + (s.w[1] + s.w[3]) * _Complex_I;
 }
-
diff --git a/src/dotprod/src/dotprod_crcf.c b/src/dotprod/src/dotprod_crcf.c
index 6e58e9d1..af4a5aab 100644
--- a/src/dotprod/src/dotprod_crcf.c
+++ b/src/dotprod/src/dotprod_crcf.c
@@ -20,7 +20,7 @@
  * THE SOFTWARE.
  */
 
-// 
+//
 // Complex floating-point dot product
 //
 
@@ -28,8 +28,8 @@
 #include "liquid.internal.h"
 
 #define DOTPROD(name)   LIQUID_CONCAT(dotprod_crcf,name)
-#define TO              float complex
+#define TO              _Fcomplex
 #define TC              float
-#define TI              float complex
+#define TI              _Fcomplex
 
 #include "dotprod.c"
diff --git a/src/dotprod/src/dotprod_crcf.mmx.c b/src/dotprod/src/dotprod_crcf.mmx.c
index deabd0cc..494fddac 100644
--- a/src/dotprod/src/dotprod_crcf.mmx.c
+++ b/src/dotprod/src/dotprod_crcf.mmx.c
@@ -20,7 +20,7 @@
  * THE SOFTWARE.
  */
 
-// 
+//
 // Floating-point dot product (MMX)
 //
 
@@ -36,19 +36,19 @@
 
 // forward declaration of internal methods
 void dotprod_crcf_execute_mmx(dotprod_crcf    _q,
-                              float complex * _x,
-                              float complex * _y);
+                              _Fcomplex * _x,
+                              _Fcomplex * _y);
 void dotprod_crcf_execute_mmx4(dotprod_crcf    _q,
-                               float complex * _x,
-                               float complex * _y);
+                               _Fcomplex * _x,
+                               _Fcomplex * _y);
 
 // basic dot product (ordinal calculation)
 void dotprod_crcf_run(float *         _h,
-                      float complex * _x,
+                      _Fcomplex * _x,
                       unsigned int    _n,
-                      float complex * _y)
+                      _Fcomplex * _y)
 {
-    float complex r = 0;
+    _Fcomplex r = 0;
     unsigned int i;
     for (i=0; i<_n; i++)
         r += _h[i] * _x[i];
@@ -57,14 +57,14 @@ void dotprod_crcf_run(float *         _h,
 
 // basic dot product (ordinal calculation) with loop unrolled
 void dotprod_crcf_run4(float *         _h,
-                       float complex * _x,
+                       _Fcomplex * _x,
                        unsigned int    _n,
-                       float complex * _y)
+                       _Fcomplex * _y)
 {
-    float complex r = 0;
+    _Fcomplex r = 0;
 
     // t = 4*(floor(_n/4))
-    unsigned int t=(_n>>2)<<2; 
+    unsigned int t=(_n>>2)<<2;
 
     // compute dotprod in groups of 4
     unsigned int i;
@@ -140,10 +140,10 @@ void dotprod_crcf_print(dotprod_crcf _q)
         printf("  %3u : %12.9f\n", i, _q->h[2*i]);
 }
 
-// 
+//
 void dotprod_crcf_execute(dotprod_crcf    _q,
-                          float complex * _x,
-                          float complex * _y)
+                          _Fcomplex * _x,
+                          _Fcomplex * _y)
 {
     // switch based on size
     if (_q->n < 32) {
@@ -155,8 +155,8 @@ void dotprod_crcf_execute(dotprod_crcf    _q,
 
 // use MMX/SSE extensions
 void dotprod_crcf_execute_mmx(dotprod_crcf    _q,
-                              float complex * _x,
-                              float complex * _y)
+                              _Fcomplex * _x,
+                              _Fcomplex * _y)
 {
     // type cast input as floating point array
     float * x = (float*) _x;
@@ -211,8 +211,8 @@ void dotprod_crcf_execute_mmx(dotprod_crcf    _q,
 
 // use MMX/SSE extensions
 void dotprod_crcf_execute_mmx4(dotprod_crcf    _q,
-                               float complex * _x,
-                               float complex * _y)
+                               _Fcomplex * _x,
+                               _Fcomplex * _y)
 {
     // type cast input as floating point array
     float * x = (float*) _x;
@@ -254,7 +254,7 @@ void dotprod_crcf_execute_mmx4(dotprod_crcf    _q,
         s1 = _mm_mul_ps(v1, h1);
         s2 = _mm_mul_ps(v2, h2);
         s3 = _mm_mul_ps(v3, h3);
-        
+
         // parallel addition
         sum0 = _mm_add_ps( sum0, s0 );
         sum1 = _mm_add_ps( sum1, s1 );
@@ -284,4 +284,3 @@ void dotprod_crcf_execute_mmx4(dotprod_crcf    _q,
     // set return value
     *_y = w[0] + w[1]*_Complex_I;
 }
-
diff --git a/src/dotprod/src/dotprod_crcf.neon.c b/src/dotprod/src/dotprod_crcf.neon.c
index a89c0d56..3b57863f 100644
--- a/src/dotprod/src/dotprod_crcf.neon.c
+++ b/src/dotprod/src/dotprod_crcf.neon.c
@@ -20,7 +20,7 @@
  * THE SOFTWARE.
  */
 
-// 
+//
 // Floating-point dot product (ARM Neon)
 //
 
@@ -38,20 +38,20 @@
 
 // forward declaration of internal methods
 void dotprod_crcf_execute_neon(dotprod_crcf    _q,
-                               float complex * _x,
-                               float complex * _y);
+                               _Fcomplex * _x,
+                               _Fcomplex * _y);
 void dotprod_crcf_execute_neon4(dotprod_crcf    _q,
-                                float complex * _x,
-                                float complex * _y);
+                                _Fcomplex * _x,
+                                _Fcomplex * _y);
 
 // basic dot product (ordinal calculation) using neon extensions
 void dotprod_crcf_run(float *         _h,
-                      float complex * _x,
+                      _Fcomplex * _x,
                       unsigned int    _n,
-                      float complex * _y)
+                      _Fcomplex * _y)
 {
     // initialize accumulator
-    float complex r=0;
+    _Fcomplex r=0;
 
     unsigned int i;
     for (i=0; i<_n; i++)
@@ -64,14 +64,14 @@ void dotprod_crcf_run(float *         _h,
 
 // basic dot product (ordinal calculation) with loop unrolled
 void dotprod_crcf_run4(float *         _h,
-                       float complex * _x,
+                       _Fcomplex * _x,
                        unsigned int    _n,
-                       float complex * _y)
+                       _Fcomplex * _y)
 {
-    float complex r = 0;
+    _Fcomplex r = 0;
 
     // t = 4*(floor(_n/4))
-    unsigned int t=(_n>>2)<<2; 
+    unsigned int t=(_n>>2)<<2;
 
     // compute dotprod in groups of 4
     unsigned int i;
@@ -150,10 +150,10 @@ void dotprod_crcf_print(dotprod_crcf _q)
         printf("  %3u : %12.9f\n", i, _q->h[2*i]);
 }
 
-// 
+//
 void dotprod_crcf_execute(dotprod_crcf    _q,
-                          float complex * _x,
-                          float complex * _y)
+                          _Fcomplex * _x,
+                          _Fcomplex * _y)
 {
     // switch based on size
     if (_q->n < 32) {
@@ -165,8 +165,8 @@ void dotprod_crcf_execute(dotprod_crcf    _q,
 
 // use ARM Neon extensions
 void dotprod_crcf_execute_neon(dotprod_crcf    _q,
-                               float complex * _x,
-                               float complex * _y)
+                               _Fcomplex * _x,
+                               _Fcomplex * _y)
 {
     // type cast input as floating point array
     float * x = (float*) _x;
@@ -178,7 +178,7 @@ void dotprod_crcf_execute_neon(dotprod_crcf    _q,
     float32x4_t v;   // input vector
     float32x4_t h;   // coefficients vector
     float32x4_t s;   // dot product
-    
+
     // load zeros into sum register
     float zeros[4] = {0,0,0,0};
     float32x4_t sum = vld1q_f32(zeros);
@@ -222,8 +222,8 @@ void dotprod_crcf_execute_neon(dotprod_crcf    _q,
 
 // use ARM Neon extensions
 void dotprod_crcf_execute_neon4(dotprod_crcf    _q,
-                                float complex * _x,
-                                float complex * _y)
+                                _Fcomplex * _x,
+                                _Fcomplex * _y)
 {
 #if 1
     // type cast input as floating point array
@@ -267,7 +267,7 @@ void dotprod_crcf_execute_neon4(dotprod_crcf    _q,
         s1 = vmulq_f32(v1, h1);
         s2 = vmulq_f32(v2, h2);
         s3 = vmulq_f32(v3, h3);
-        
+
         // parallel addition
         sum0 = vaddq_f32( sum0, s0 );
         sum1 = vaddq_f32( sum1, s1 );
@@ -300,4 +300,3 @@ void dotprod_crcf_execute_neon4(dotprod_crcf    _q,
     dotprod_crcf_execute_neon(_q, _x, _y);
 #endif
 }
-
diff --git a/src/dotprod/src/sumsq.c b/src/dotprod/src/sumsq.c
index e89bb3e2..30747ebd 100644
--- a/src/dotprod/src/sumsq.c
+++ b/src/dotprod/src/sumsq.c
@@ -40,7 +40,7 @@ float liquid_sumsqf(float *      _v,
     float r=0;
 
     // t = 4*(floor(_n/4))
-    unsigned int t=(_n>>2)<<2; 
+    unsigned int t=(_n>>2)<<2;
 
     // run computation in groups of 4
     unsigned int i;
@@ -62,7 +62,7 @@ float liquid_sumsqf(float *      _v,
 // sum squares, basic loop
 //  _v      :   input array [size: 1 x _n]
 //  _n      :   input length
-float liquid_sumsqcf(float complex * _v,
+float liquid_sumsqcf(_Fcomplex * _v,
                      unsigned int    _n)
 {
     // simple method: type cast input as real pointer, run double
@@ -70,4 +70,3 @@ float liquid_sumsqcf(float complex * _v,
     float * v = (float*) _v;
     return liquid_sumsqf(v, 2*_n);
 }
-
diff --git a/src/dotprod/src/sumsq.mmx.c b/src/dotprod/src/sumsq.mmx.c
index 056ba75b..6ec3f2fd 100644
--- a/src/dotprod/src/sumsq.mmx.c
+++ b/src/dotprod/src/sumsq.mmx.c
@@ -71,7 +71,7 @@ float liquid_sumsqf(float *      _v,
 
         // compute multiplication
         s = _mm_mul_ps(v, v);
-       
+
         // parallel addition
         sum = _mm_add_ps( sum, s );
     }
@@ -84,7 +84,7 @@ float liquid_sumsqf(float *      _v,
     __m128 z = _mm_setzero_ps();
     sum = _mm_hadd_ps(sum, z);
     sum = _mm_hadd_ps(sum, z);
-   
+
     // unload single (lower value)
     _mm_store_ss(w, sum);
     float total = w[0];
@@ -105,7 +105,7 @@ float liquid_sumsqf(float *      _v,
 // sum squares, basic loop
 //  _v      :   input array [size: 1 x _n]
 //  _n      :   input length
-float liquid_sumsqcf(float complex * _v,
+float liquid_sumsqcf(_Fcomplex * _v,
                      unsigned int    _n)
 {
     // simple method: type cast input as real pointer, run double
diff --git a/src/dotprod/tests/dotprod_cccf_autotest.c b/src/dotprod/tests/dotprod_cccf_autotest.c
index 87ad065c..ae96434d 100644
--- a/src/dotprod/tests/dotprod_cccf_autotest.c
+++ b/src/dotprod/tests/dotprod_cccf_autotest.c
@@ -23,16 +23,16 @@
 #include "autotest/autotest.h"
 #include "liquid.internal.h"
 
-// 
+//
 // AUTOTEST: compare structured result to oridinal computation
 //
 
-// 
+//
 // AUTOTEST: dot product with floating-point data
 //
 void autotest_dotprod_cccf_rand16()
 {
-    float complex h[16] = {
+    _Fcomplex h[16] = {
       0.17702709 +   1.38978455*_Complex_I,  0.91294148 +   0.39217381*_Complex_I,
      -0.80607338 +   0.76477512*_Complex_I,  0.05099755 +  -0.87350051*_Complex_I,
       0.44513826 +  -0.49490569*_Complex_I,  0.14754967 +   2.04349962*_Complex_I,
@@ -43,7 +43,7 @@ void autotest_dotprod_cccf_rand16()
       0.55524695 +  -1.94931519*_Complex_I, -0.87191170 +   0.91693119*_Complex_I,
     };
 
-    float complex x[16] = {
+    _Fcomplex x[16] = {
      -2.19591953 +  -0.93229692*_Complex_I,  0.17150376 +   0.56165114*_Complex_I,
       1.58354529 +  -0.50696037*_Complex_I,  1.40929619 +   0.87868803*_Complex_I,
      -0.75505072 +  -0.30867372*_Complex_I, -0.09821367 +  -0.73949106*_Complex_I,
@@ -54,8 +54,8 @@ void autotest_dotprod_cccf_rand16()
       0.24852918 +  -0.62409860*_Complex_I, -0.87039907 +   0.90921212*_Complex_I,
     };
 
-    float complex y;
-    float complex test = -0.604285042605890 - 12.390925785344704 * _Complex_I;
+    _Fcomplex y;
+    _Fcomplex test = -0.604285042605890 - 12.390925785344704 * _Complex_I;
 
     float tol = 1e-3f;
 
@@ -75,15 +75,15 @@ void autotest_dotprod_cccf_rand16()
     dotprod_cccf_destroy(q);
 }
 
-// 
+//
 // AUTOTEST: structured dot product, odd lengths
 //
 void autotest_dotprod_cccf_struct_lengths()
 {
     float tol = 4e-6;
-    float complex y;
+    _Fcomplex y;
 
-    float complex h[35] = {
+    _Fcomplex h[35] = {
       1.11555653 +   2.30658043*_Complex_I, -0.36133676 +  -0.10917327*_Complex_I,
       0.17714505 +  -2.14631440*_Complex_I,  2.20424609 +   0.59063608*_Complex_I,
      -0.44699194 +   0.23369318*_Complex_I,  0.60613931 +   0.21868288*_Complex_I,
@@ -103,7 +103,7 @@ void autotest_dotprod_cccf_struct_lengths()
       1.19573306 +   0.98449546*_Complex_I,  1.42491943 +  -0.55426305*_Complex_I,
       1.08243614 +   0.35774368*_Complex_I, };
 
-    float complex x[35] = {
+    _Fcomplex x[35] = {
      -0.82466736 +  -1.39329228*_Complex_I, -1.46176052 +  -1.96218827*_Complex_I,
      -1.28388174 +  -0.07152934*_Complex_I, -0.51910014 +  -0.37915971*_Complex_I,
      -0.65964708 +  -0.98417534*_Complex_I, -1.40213479 +  -0.82198463*_Complex_I,
@@ -123,12 +123,12 @@ void autotest_dotprod_cccf_struct_lengths()
       0.56040910 +  -0.12713027*_Complex_I, -0.46653022 +  -0.65450499*_Complex_I,
       0.15515755 +   1.58944030*_Complex_I, };
 
-    float complex v32 = -11.5100903519506 - 15.3575526884014*_Complex_I;
-    float complex v33 = -10.7148314918614 - 14.9578463360225*_Complex_I;
-    float complex v34 = -11.7423673921916 - 15.6318827515320*_Complex_I;
-    float complex v35 = -12.1430314741466 - 13.8559085000689*_Complex_I;
+    _Fcomplex v32 = -11.5100903519506 - 15.3575526884014*_Complex_I;
+    _Fcomplex v33 = -10.7148314918614 - 14.9578463360225*_Complex_I;
+    _Fcomplex v34 = -11.7423673921916 - 15.6318827515320*_Complex_I;
+    _Fcomplex v35 = -12.1430314741466 - 13.8559085000689*_Complex_I;
 
-    // 
+    //
     dotprod_cccf dp;
 
     // n = 32
@@ -178,8 +178,8 @@ void autotest_dotprod_cccf_struct_lengths()
 void runtest_dotprod_cccf(unsigned int _n)
 {
     float tol = 1e-3;
-    float complex h[_n];
-    float complex x[_n];
+    _Fcomplex h[_n];
+    _Fcomplex x[_n];
 
     // generate random coefficients
     unsigned int i;
@@ -187,14 +187,14 @@ void runtest_dotprod_cccf(unsigned int _n)
         h[i] = randnf() + randnf() * _Complex_I;
         x[i] = randnf() + randnf() * _Complex_I;
     }
-    
+
     // compute expected value (ordinal computation)
-    float complex y_test=0;
+    _Fcomplex y_test=0;
     for (i=0; i<_n; i++)
         y_test += h[i] * x[i];
 
     // create and run dot product object
-    float complex y;
+    _Fcomplex y;
     dotprod_cccf dp;
     dp = dotprod_cccf_create(h,_n);
     dotprod_cccf_execute(dp, x, &y);
@@ -219,4 +219,3 @@ void autotest_dotprod_cccf_struct_vs_ordinal()
     for (i=1; i<=512; i++)
         runtest_dotprod_cccf(i);
 }
-
diff --git a/src/dotprod/tests/dotprod_crcf_autotest.c b/src/dotprod/tests/dotprod_crcf_autotest.c
index 2da0527f..69f6c1f2 100644
--- a/src/dotprod/tests/dotprod_crcf_autotest.c
+++ b/src/dotprod/tests/dotprod_crcf_autotest.c
@@ -23,31 +23,31 @@
 #include "autotest/autotest.h"
 #include "liquid.internal.h"
 
-// 
+//
 // AUTOTEST: dot product with floating-point data
 //
 void autotest_dotprod_crcf_rand01()
 {
     float h[16] = {
-      5.5375e-02,  -6.5857e-01,  -1.7657e+00,   7.7444e-01, 
-      8.0730e-01,  -5.1340e-01,  -9.3437e-02,  -5.6301e-01, 
-     -6.6480e-01,  -2.1673e+00,   9.0269e-01,   3.5284e+00, 
+      5.5375e-02,  -6.5857e-01,  -1.7657e+00,   7.7444e-01,
+      8.0730e-01,  -5.1340e-01,  -9.3437e-02,  -5.6301e-01,
+     -6.6480e-01,  -2.1673e+00,   9.0269e-01,   3.5284e+00,
      -9.7835e-01,  -6.9512e-01,  -1.2958e+00,   1.1628e+00
     };
 
-    float complex x[16] = {
-      1.3164e+00+  5.4161e-01*_Complex_I,   1.8295e-01+ -9.0284e-02*_Complex_I, 
-      1.3487e+00+ -1.8148e+00*_Complex_I,  -7.4696e-01+ -4.1792e-01*_Complex_I, 
-     -9.0551e-01+ -4.4294e-01*_Complex_I,   6.0591e-01+ -1.5383e+00*_Complex_I, 
-     -7.5393e-01+ -3.5691e-01*_Complex_I,  -4.5733e-01+  1.1926e-01*_Complex_I, 
-     -1.4744e-01+ -4.7676e-02*_Complex_I,  -1.2422e+00+ -2.0213e+00*_Complex_I, 
-      3.3208e-02+ -1.3756e+00*_Complex_I,  -4.8573e-01+  1.0977e+00*_Complex_I, 
-      1.5053e+00+  2.1141e-01*_Complex_I,  -8.4062e-01+ -1.0211e+00*_Complex_I, 
+    _Fcomplex x[16] = {
+      1.3164e+00+  5.4161e-01*_Complex_I,   1.8295e-01+ -9.0284e-02*_Complex_I,
+      1.3487e+00+ -1.8148e+00*_Complex_I,  -7.4696e-01+ -4.1792e-01*_Complex_I,
+     -9.0551e-01+ -4.4294e-01*_Complex_I,   6.0591e-01+ -1.5383e+00*_Complex_I,
+     -7.5393e-01+ -3.5691e-01*_Complex_I,  -4.5733e-01+  1.1926e-01*_Complex_I,
+     -1.4744e-01+ -4.7676e-02*_Complex_I,  -1.2422e+00+ -2.0213e+00*_Complex_I,
+      3.3208e-02+ -1.3756e+00*_Complex_I,  -4.8573e-01+  1.0977e+00*_Complex_I,
+      1.5053e+00+  2.1141e-01*_Complex_I,  -8.4062e-01+ -1.0211e+00*_Complex_I,
      -1.3932e+00+ -4.8491e-01*_Complex_I,  -1.4234e+00+  2.0333e-01*_Complex_I
     };
 
-    float complex y;
-    float complex test = -3.35346556487224 + 11.78023318618137*_Complex_I;
+    _Fcomplex y;
+    _Fcomplex test = -3.35346556487224 + 11.78023318618137*_Complex_I;
     float tol = 1e-3f;
 
     dotprod_crcf_run(h,x,16,&y);
@@ -68,31 +68,31 @@ void autotest_dotprod_crcf_rand01()
 
 
 
-// 
+//
 // AUTOTEST: dot product with floating-point data
 //
 void autotest_dotprod_crcf_rand02()
 {
     float h[16] = {
-      4.7622e-01,   7.1453e-01,  -7.1370e-01,  -1.6457e-01, 
-     -1.1573e-01,   6.4114e-01,  -1.0688e+00,  -1.6761e+00, 
-     -1.0376e+00,  -1.0991e+00,  -2.4161e-01,   4.6065e-01, 
+      4.7622e-01,   7.1453e-01,  -7.1370e-01,  -1.6457e-01,
+     -1.1573e-01,   6.4114e-01,  -1.0688e+00,  -1.6761e+00,
+     -1.0376e+00,  -1.0991e+00,  -2.4161e-01,   4.6065e-01,
      -1.0403e+00,  -1.1424e-01,  -1.2371e+00,  -7.9723e-01
     };
 
-    float complex x[16] = {
-     -8.3558e-01+  3.0504e-01*_Complex_I,  -6.3004e-01+  2.4680e-01*_Complex_I, 
-      9.6908e-01+  1.2978e+00*_Complex_I,  -2.0587e+00+  9.5385e-01*_Complex_I, 
-      2.5692e-01+ -1.7314e+00*_Complex_I,  -1.2237e+00+ -6.2139e-02*_Complex_I, 
-      5.0300e-02+ -9.2092e-01*_Complex_I,  -1.8816e-01+  7.0746e-02*_Complex_I, 
-     -2.4177e+00+  8.3177e-01*_Complex_I,   1.6871e-01+ -8.5129e-02*_Complex_I, 
-      6.5203e-01+  2.0739e-02*_Complex_I,  -1.2331e-01+ -9.7920e-01*_Complex_I, 
-      8.2352e-01+  9.1093e-01*_Complex_I,   1.5161e+00+ -9.1865e-01*_Complex_I, 
+    _Fcomplex x[16] = {
+     -8.3558e-01+  3.0504e-01*_Complex_I,  -6.3004e-01+  2.4680e-01*_Complex_I,
+      9.6908e-01+  1.2978e+00*_Complex_I,  -2.0587e+00+  9.5385e-01*_Complex_I,
+      2.5692e-01+ -1.7314e+00*_Complex_I,  -1.2237e+00+ -6.2139e-02*_Complex_I,
+      5.0300e-02+ -9.2092e-01*_Complex_I,  -1.8816e-01+  7.0746e-02*_Complex_I,
+     -2.4177e+00+  8.3177e-01*_Complex_I,   1.6871e-01+ -8.5129e-02*_Complex_I,
+      6.5203e-01+  2.0739e-02*_Complex_I,  -1.2331e-01+ -9.7920e-01*_Complex_I,
+      8.2352e-01+  9.1093e-01*_Complex_I,   1.5161e+00+ -9.1865e-01*_Complex_I,
      -2.0892e+00+  2.7759e-02*_Complex_I,  -2.5188e-01+  2.5568e-01*_Complex_I
     };
 
-    float complex y;
-    float complex test = 2.11053363855085 - 2.04167493441477*_Complex_I;
+    _Fcomplex y;
+    _Fcomplex test = 2.11053363855085 - 2.04167493441477*_Complex_I;
     float tol = 1e-3f;
 
     dotprod_crcf_run(h,x,16,&y);
@@ -115,7 +115,7 @@ void autotest_dotprod_crcf_rand02()
     dotprod_crcf_destroy(q);
 }
 
-// 
+//
 // AUTOTEST: compare structured result to oridinal computation
 //
 
@@ -124,7 +124,7 @@ void runtest_dotprod_crcf(unsigned int _n)
 {
     float tol = 1e-4;
     float h[_n];
-    float complex x[_n];
+    _Fcomplex x[_n];
 
     // generate random coefficients
     unsigned int i;
@@ -132,14 +132,14 @@ void runtest_dotprod_crcf(unsigned int _n)
         h[i] = randnf();
         x[i] = randnf() + randnf() * _Complex_I;
     }
-    
+
     // compute expected value (ordinal computation)
-    float complex y_test=0;
+    _Fcomplex y_test=0;
     for (i=0; i<_n; i++)
         y_test += h[i] * x[i];
 
     // create and run dot product object
-    float complex y;
+    _Fcomplex y;
     dotprod_crcf dp;
     dp = dotprod_crcf_create(h,_n);
     dotprod_crcf_execute(dp, x, &y);
@@ -164,4 +164,3 @@ void autotest_dotprod_crcf_struct_vs_ordinal()
     for (i=1; i<=512; i++)
         runtest_dotprod_crcf(i);
 }
-
diff --git a/src/dotprod/tests/sumsqcf_autotest.c b/src/dotprod/tests/sumsqcf_autotest.c
index b2c5589e..2d77bd03 100644
--- a/src/dotprod/tests/sumsqcf_autotest.c
+++ b/src/dotprod/tests/sumsqcf_autotest.c
@@ -24,15 +24,15 @@
 #include "liquid.internal.h"
 
 // test data
-float complex sumsqcf_test_x3[3];   float sumsqcf_test_y3;
-float complex sumsqcf_test_x4[4];   float sumsqcf_test_y4;
-float complex sumsqcf_test_x7[7];   float sumsqcf_test_y7;
-float complex sumsqcf_test_x8[8];   float sumsqcf_test_y8;
-float complex sumsqcf_test_x15[15]; float sumsqcf_test_y15;
-float complex sumsqcf_test_x16[16]; float sumsqcf_test_y16;
+_Fcomplex sumsqcf_test_x3[3];   float sumsqcf_test_y3;
+_Fcomplex sumsqcf_test_x4[4];   float sumsqcf_test_y4;
+_Fcomplex sumsqcf_test_x7[7];   float sumsqcf_test_y7;
+_Fcomplex sumsqcf_test_x8[8];   float sumsqcf_test_y8;
+_Fcomplex sumsqcf_test_x15[15]; float sumsqcf_test_y15;
+_Fcomplex sumsqcf_test_x16[16]; float sumsqcf_test_y16;
 
 // helper function
-void sumsqcf_runtest(float complex * _x,
+void sumsqcf_runtest(_Fcomplex * _x,
                      unsigned int    _n,
                      float           _y)
 {
@@ -44,7 +44,7 @@ void sumsqcf_runtest(float complex * _x,
     CONTEND_DELTA( y, _y, tol );
 }
 
-// 
+//
 // AUTOTESTS : run test with pre-determined data sets
 //
 void autotest_sumsqcf_3()   {   sumsqcf_runtest( sumsqcf_test_x3,  3,  sumsqcf_test_y3  );  }
@@ -54,20 +54,20 @@ void autotest_sumsqcf_8()   {   sumsqcf_runtest( sumsqcf_test_x8,  8,  sumsqcf_t
 void autotest_sumsqcf_15()  {   sumsqcf_runtest( sumsqcf_test_x15, 15, sumsqcf_test_y15 );  }
 void autotest_sumsqcf_16()  {   sumsqcf_runtest( sumsqcf_test_x16, 16, sumsqcf_test_y16 );  }
 
-float complex sumsqcf_test_x3[3] = {
+_Fcomplex sumsqcf_test_x3[3] = {
   -0.143606511525 +  -0.137405158308*_Complex_I,
   -0.155077565599 +  -0.128712786230*_Complex_I,
    0.259257309730 +  -0.354313982924*_Complex_I};
 float sumsqcf_test_y3 = 0.272871791516851;
 
-float complex sumsqcf_test_x4[4] = {
+_Fcomplex sumsqcf_test_x4[4] = {
   -0.027688113439 +   0.014257850202*_Complex_I,
    0.135913101830 +  -0.193497844930*_Complex_I,
   -0.184688262513 +  -0.018367564232*_Complex_I,
    0.033677897260 +  -0.365996497668*_Complex_I};
 float sumsqcf_test_y4 = 0.226418463954813;
 
-float complex sumsqcf_test_x7[7] = {
+_Fcomplex sumsqcf_test_x7[7] = {
   -0.052790293375 +   0.173778162166*_Complex_I,
    0.026113336498 +  -0.228399854303*_Complex_I,
    0.060259677552 +  -0.064704230326*_Complex_I,
@@ -77,7 +77,7 @@ float complex sumsqcf_test_x7[7] = {
   -0.140068020211 +  -0.028552894932*_Complex_I};
 float sumsqcf_test_y7 = 0.179790025178960;
 
-float complex sumsqcf_test_x8[8] = {
+_Fcomplex sumsqcf_test_x8[8] = {
   -0.114842287937 +  -0.044108491804*_Complex_I,
   -0.027032488500 +  -0.098073597323*_Complex_I,
   -0.248865158871 +  -0.058431293594*_Complex_I,
@@ -88,7 +88,7 @@ float complex sumsqcf_test_x8[8] = {
   -0.048463564653 +  -0.123659611524*_Complex_I};
 float sumsqcf_test_y8 = 0.290592731534459;
 
-float complex sumsqcf_test_x15[15] = {
+_Fcomplex sumsqcf_test_x15[15] = {
   -0.233166865552 +  -0.325575589001*_Complex_I,
   -0.062157314569 +  -0.052675113778*_Complex_I,
   -0.184924733094 +  -0.037448582846*_Complex_I,
@@ -106,7 +106,7 @@ float complex sumsqcf_test_x15[15] = {
   -0.123711595377 +   0.212526707755*_Complex_I};
 float sumsqcf_test_y15 = 1.44880523546855;
 
-float complex sumsqcf_test_x16[16] = {
+_Fcomplex sumsqcf_test_x16[16] = {
   -0.065168142317 +   0.069453199546*_Complex_I,
    0.175268433034 +  -0.227486860237*_Complex_I,
   -0.190532229460 +   0.079975095234*_Complex_I,
diff --git a/src/equalization/bench/eqlms_cccf_benchmark.c b/src/equalization/bench/eqlms_cccf_benchmark.c
index 22b79799..626da614 100644
--- a/src/equalization/bench/eqlms_cccf_benchmark.c
+++ b/src/equalization/bench/eqlms_cccf_benchmark.c
@@ -44,22 +44,22 @@ void eqlms_cccf_train_bench(struct rusage *_start,
     *_num_iterations = (*_num_iterations < 4) ? 4 : *_num_iterations;
 
     eqlms_cccf eq = eqlms_cccf_create(NULL,_h_len);
-    
+
     unsigned long int i;
 
     // set up initial arrays to 'randomize' inputs/outputs
-    float complex y[11];
+    _Fcomplex y[11];
     for (i=0; i<11; i++)
         y[i] = randnf() + _Complex_I*randnf();
 
-    float complex d[13];
+    _Fcomplex d[13];
     for (i=0; i<13; i++)
         d[i] = randnf() + _Complex_I*randnf();
 
     unsigned int iy=0;
     unsigned int id=0;
 
-    float complex z;
+    _Fcomplex z;
 
     // start trials
     getrusage(RUSAGE_SELF, _start);
@@ -77,10 +77,9 @@ void eqlms_cccf_train_bench(struct rusage *_start,
     eqlms_cccf_destroy(eq);
 }
 
-// 
+//
 void benchmark_eqlms_cccf_n4    EQLMS_CCCF_TRAIN_BENCH_API(4)
 void benchmark_eqlms_cccf_n8    EQLMS_CCCF_TRAIN_BENCH_API(8)
 void benchmark_eqlms_cccf_n16   EQLMS_CCCF_TRAIN_BENCH_API(16)
 void benchmark_eqlms_cccf_n32   EQLMS_CCCF_TRAIN_BENCH_API(32)
 void benchmark_eqlms_cccf_n64   EQLMS_CCCF_TRAIN_BENCH_API(64)
-
diff --git a/src/equalization/bench/eqrls_cccf_benchmark.c b/src/equalization/bench/eqrls_cccf_benchmark.c
index f41b2be9..d72f9182 100644
--- a/src/equalization/bench/eqrls_cccf_benchmark.c
+++ b/src/equalization/bench/eqrls_cccf_benchmark.c
@@ -44,22 +44,22 @@ void eqrls_cccf_train_bench(struct rusage *_start,
     *_num_iterations = (*_num_iterations < 4) ? 4 : *_num_iterations;
 
     eqrls_cccf eq = eqrls_cccf_create(NULL,_h_len);
-    
+
     unsigned long int i;
 
     // set up initial arrays to 'randomize' inputs/outputs
-    float complex y[11];
+    _Fcomplex y[11];
     for (i=0; i<11; i++)
         y[i] = randnf() + _Complex_I*randnf();
 
-    float complex d[13];
+    _Fcomplex d[13];
     for (i=0; i<13; i++)
         d[i] = randnf() + _Complex_I*randnf();
 
     unsigned int iy=0;
     unsigned int id=0;
 
-    float complex z;
+    _Fcomplex z;
 
     // start trials
     getrusage(RUSAGE_SELF, _start);
@@ -77,10 +77,9 @@ void eqrls_cccf_train_bench(struct rusage *_start,
     eqrls_cccf_destroy(eq);
 }
 
-// 
+//
 void benchmark_eqrls_cccf_n4    EQRLS_CCCF_TRAIN_BENCH_API(4)
 void benchmark_eqrls_cccf_n8    EQRLS_CCCF_TRAIN_BENCH_API(8)
 void benchmark_eqrls_cccf_n16   EQRLS_CCCF_TRAIN_BENCH_API(16)
 void benchmark_eqrls_cccf_n32   EQRLS_CCCF_TRAIN_BENCH_API(32)
 void benchmark_eqrls_cccf_n64   EQRLS_CCCF_TRAIN_BENCH_API(64)
-
diff --git a/src/equalization/src/eqlms.c b/src/equalization/src/eqlms.c
index f9242537..fb7c9222 100644
--- a/src/equalization/src/eqlms.c
+++ b/src/equalization/src/eqlms.c
@@ -118,7 +118,7 @@ EQLMS() EQLMS(_create_rnyquist)(int          _type,
     float h[h_len];
     liquid_firdes_prototype(_type,_k,_m,_beta,_dt,h);
 
-    // copy coefficients to type-specific array (e.g. float complex)
+    // copy coefficients to type-specific array (e.g. _Fcomplex)
     // and scale by samples/symbol
     unsigned int i;
     T hc[h_len];
@@ -148,7 +148,7 @@ EQLMS() EQLMS(_create_lowpass)(unsigned int _h_len,
     float h[_h_len];
     liquid_firdes_kaiser(_h_len, _fc, 40.0f, 0.0f, h);
 
-    // copy coefficients to type-specific array (e.g. float complex)
+    // copy coefficients to type-specific array (e.g. _Fcomplex)
     unsigned int i;
     T hc[_h_len];
     for (i=0; i<_h_len; i++)
@@ -446,7 +446,7 @@ void EQLMS(_train)(EQLMS()      _q,
     EQLMS(_get_weights)(_q, _w);
 }
 
-// 
+//
 // internal methods
 //
 
@@ -469,4 +469,3 @@ void EQLMS(_update_sumsq)(EQLMS() _q, T _x)
     // update sum( |x|^2 ) of last 'n' input samples
     _q->x2_sum = _q->x2_sum + x2_n - x2_0;
 }
-
diff --git a/src/equalization/src/equalizer_cccf.c b/src/equalization/src/equalizer_cccf.c
index f94e9d0a..11e7a984 100644
--- a/src/equalization/src/equalizer_cccf.c
+++ b/src/equalization/src/equalizer_cccf.c
@@ -20,7 +20,7 @@
  * THE SOFTWARE.
  */
 
-// 
+//
 // Floating-point equalizers
 //
 
@@ -38,7 +38,7 @@
 #define MATRIX(name)    LIQUID_CONCAT(matrixcf,name)
 
 #define T_COMPLEX       1
-#define T               float complex
+#define T               _Fcomplex
 
 #define PRINTVAL(V)     printf("%5.2f+j%5.2f ", crealf(V), cimagf(V));
 
diff --git a/src/equalization/tests/eqlms_cccf_autotest.c b/src/equalization/tests/eqlms_cccf_autotest.c
index ceda5e27..a9ac189b 100644
--- a/src/equalization/tests/eqlms_cccf_autotest.c
+++ b/src/equalization/tests/eqlms_cccf_autotest.c
@@ -23,7 +23,7 @@
 #include "autotest/autotest.h"
 #include "liquid.h"
 
-// 
+//
 // AUTOTEST: static channel filter, blind equalization on QPSK symbols
 //
 void autotest_eqlms_cccf_blind()
@@ -48,7 +48,7 @@ void autotest_eqlms_cccf_blind()
     eqlms_cccf_set_bw(eq, mu);
 
     // create channel filter
-    float complex h[5] = {
+    _Fcomplex h[5] = {
          1.00f +  0.00f*_Complex_I,
          0.00f + -0.01f*_Complex_I,
         -0.11f +  0.02f*_Complex_I,
@@ -57,9 +57,9 @@ void autotest_eqlms_cccf_blind()
     firfilt_cccf fchannel = firfilt_cccf_create(h,5);
 
     // arrays
-    float complex buf[k];               // filter buffer
-    float complex sym_in [num_symbols]; // input symbols
-    float complex sym_out[num_symbols]; // equalized symbols
+    _Fcomplex buf[k];               // filter buffer
+    _Fcomplex sym_in [num_symbols]; // input symbols
+    _Fcomplex sym_out[num_symbols]; // equalized symbols
 
     // run equalization
     unsigned int i;
@@ -119,7 +119,7 @@ void autotest_eqlms_cccf_blind()
     msequence_destroy(ms);
 }
 
-// 
+//
 // AUTOTEST: static channel filter, decision-directed on QPSK symbols
 //
 void autotest_eqlms_cccf_decisiondirected()
@@ -144,13 +144,13 @@ void autotest_eqlms_cccf_decisiondirected()
 
     // create channel filter
     unsigned int h_len = 5; // channel filter length
-    float complex h[5] = {1.0f, 0.0f, -0.1f, 0.02f, -0.1f};
+    _Fcomplex h[5] = {1.0f, 0.0f, -0.1f, 0.02f, -0.1f};
     firfilt_cccf fchannel = firfilt_cccf_create(h,h_len);
 
     // arrays
-    float complex buf[k];               // filter buffer
-    float complex sym_in [num_symbols]; // input symbols
-    float complex sym_out[num_symbols]; // equalized symbols
+    _Fcomplex buf[k];               // filter buffer
+    _Fcomplex sym_in [num_symbols]; // input symbols
+    _Fcomplex sym_out[num_symbols]; // equalized symbols
 
     // run equalization
     unsigned int i;
@@ -209,4 +209,3 @@ void autotest_eqlms_cccf_decisiondirected()
     eqlms_cccf_destroy(eq);
     msequence_destroy(ms);
 }
-
diff --git a/src/fft/bench/fft_runbench.c b/src/fft/bench/fft_runbench.c
index bb4f9f77..d7341df1 100644
--- a/src/fft/bench/fft_runbench.c
+++ b/src/fft/bench/fft_runbench.c
@@ -37,11 +37,11 @@ void fft_runbench(struct rusage *     _start,
                   int                 _direction)
 {
     // initialize arrays, plan
-    float complex * x = (float complex *) malloc(_nfft*sizeof(float complex));
-    float complex * y = (float complex *) malloc(_nfft*sizeof(float complex));
+    _Fcomplex * x = (_Fcomplex *) malloc(_nfft*sizeof(_Fcomplex));
+    _Fcomplex * y = (_Fcomplex *) malloc(_nfft*sizeof(_Fcomplex));
     int _method = 0;
     fftplan q = fft_create_plan(_nfft, x, y, _direction, _method);
-    
+
     unsigned long int i;
 
     // initialize input with random values
@@ -67,4 +67,3 @@ void fft_runbench(struct rusage *     _start,
     free(x);
     free(y);
 }
-
diff --git a/src/fft/src/fftf.c b/src/fft/src/fftf.c
index eb5b02e8..10ce2ae5 100644
--- a/src/fft/src/fftf.c
+++ b/src/fft/src/fftf.c
@@ -31,7 +31,7 @@
 #define DOTPROD(name)       LIQUID_CONCAT(dotprod_cccf,name)
 
 #define T                   float           /* primitive type */
-#define TC                  float complex   /* primitive type (complex) */
+#define TC                  _Fcomplex   /* primitive type (complex) */
 
 #define PRINTVAL_T(X,F)     PRINTVAL_FLOAT(X,F)
 #define PRINTVAL_TC(X,F)    PRINTVAL_CFLOAT(X,F)
@@ -44,4 +44,3 @@
 #include "fft_rader.c"          // FFT definitions for transforms of prime length (Rader's algorithm)
 #include "fft_rader2.c"         // FFT definitions for transforms of prime length (Rader's alternate algorithm)
 #include "fft_r2r_1d.c"         // real-to-real definitions (DCT/DST)
-
diff --git a/src/fft/src/spgramcf.c b/src/fft/src/spgramcf.c
index a5851076..f8f8475e 100644
--- a/src/fft/src/spgramcf.c
+++ b/src/fft/src/spgramcf.c
@@ -37,8 +37,8 @@
 #define FFT(name)           LIQUID_CONCAT(fft,name)
 
 #define T                   float           // primitive type (real)
-#define TC                  float complex   // primitive type (complex)
-#define TI                  float complex   // input type
+#define TC                  _Fcomplex   // primitive type (complex)
+#define TI                  _Fcomplex   // input type
 
 #define TI_COMPLEX          1
 
@@ -50,4 +50,3 @@
 #include "asgram.c"
 #include "spgram.c"
 #include "spwaterfall.c"
-
diff --git a/src/fft/src/spgramf.c b/src/fft/src/spgramf.c
index 17b0ad50..e3b5ac21 100644
--- a/src/fft/src/spgramf.c
+++ b/src/fft/src/spgramf.c
@@ -37,7 +37,7 @@
 #define FFT(name)           LIQUID_CONCAT(fft,name)
 
 #define T                   float           // primitive type (real)
-#define TC                  float complex   // primitive type (complex)
+#define TC                  _Fcomplex   // primitive type (complex)
 #define TI                  float           // input type
 
 #define TI_COMPLEX          0
@@ -50,4 +50,3 @@
 #include "asgram.c"
 #include "spgram.c"
 #include "spwaterfall.c"
-
diff --git a/src/fft/tests/data/fft_data_10.c b/src/fft/tests/data/fft_data_10.c
index 26e0afc6..b9e76006 100644
--- a/src/fft/tests/data/fft_data_10.c
+++ b/src/fft/tests/data/fft_data_10.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x10[] = {
+_Fcomplex fft_test_x10[] = {
    -0.380648737020 +   1.003981780953*_Complex_I,
     1.031511152163 +  -2.625896014009*_Complex_I,
    -1.083239396623 +   1.646877001105*_Complex_I,
@@ -38,7 +38,7 @@ float complex fft_test_x10[] = {
     1.097501043733 +   1.373947311009*_Complex_I,
     0.848713422957 +  -0.738252787172*_Complex_I};
 
-float complex fft_test_y10[] = {
+_Fcomplex fft_test_y10[] = {
     1.892631207117 +   3.522635624182*_Complex_I,
    -1.167216826866 +  -3.158947047615*_Complex_I,
    -0.019614668329 +   1.291770408491*_Complex_I,
@@ -49,4 +49,3 @@ float complex fft_test_y10[] = {
     1.025423884758 +   1.907666229150*_Complex_I,
     0.644231811894 +  -5.278801296330*_Complex_I,
     2.968027431661 +  -2.555759399357*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_120.c b/src/fft/tests/data/fft_data_120.c
index c8f39a35..e4015188 100644
--- a/src/fft/tests/data/fft_data_120.c
+++ b/src/fft/tests/data/fft_data_120.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x120[] = {
+_Fcomplex fft_test_x120[] = {
    -2.933561116248 +   0.585802030432*_Complex_I,
     0.996149474765 +  -0.621353657548*_Complex_I,
    -0.262138535383 +   0.974643272654*_Complex_I,
@@ -148,7 +148,7 @@ float complex fft_test_x120[] = {
    -1.641857455950 +  -0.680302798653*_Complex_I,
    -0.235668947578 +  -0.276093078030*_Complex_I};
 
-float complex fft_test_y120[] = {
+_Fcomplex fft_test_y120[] = {
   -26.130540532441 +   2.500301372380*_Complex_I,
    -8.384737785882 + -11.493299680300*_Complex_I,
   -10.815843993705 +   1.373214442809*_Complex_I,
@@ -269,4 +269,3 @@ float complex fft_test_y120[] = {
    -7.821333192327 + -15.606994193249*_Complex_I,
     4.093578304649 +  15.462757600992*_Complex_I,
     4.765467299654 +   7.963215307045*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_130.c b/src/fft/tests/data/fft_data_130.c
index c017fa1b..cc10de7e 100644
--- a/src/fft/tests/data/fft_data_130.c
+++ b/src/fft/tests/data/fft_data_130.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x130[] = {
+_Fcomplex fft_test_x130[] = {
     2.295593731681 +   0.411874155977*_Complex_I,
     0.867233010936 +   2.391238924231*_Complex_I,
    -0.979511815183 +   0.113140414722*_Complex_I,
@@ -158,7 +158,7 @@ float complex fft_test_x130[] = {
    -0.281958991560 +  -0.356378430727*_Complex_I,
     1.134108928078 +  -2.092860871008*_Complex_I};
 
-float complex fft_test_y130[] = {
+_Fcomplex fft_test_y130[] = {
    14.378246546427 +  16.821529859589*_Complex_I,
    27.857066272618 +  13.571899136472*_Complex_I,
   -15.456704775735 +  12.690273582209*_Complex_I,
@@ -289,4 +289,3 @@ float complex fft_test_y130[] = {
    -0.069804711953 +   1.802309211709*_Complex_I,
     1.176122484348 + -14.149959691947*_Complex_I,
     5.353573748142 +   0.564676076929*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_157.c b/src/fft/tests/data/fft_data_157.c
index 45068194..553ff9ec 100644
--- a/src/fft/tests/data/fft_data_157.c
+++ b/src/fft/tests/data/fft_data_157.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x157[] = {
+_Fcomplex fft_test_x157[] = {
     0.257182749425 +   0.221924222343*_Complex_I,
     1.678933476985 +   1.690438801569*_Complex_I,
    -0.370453539748 +  -0.279443271284*_Complex_I,
@@ -185,7 +185,7 @@ float complex fft_test_x157[] = {
     1.388787822068 +  -2.267147899079*_Complex_I,
     0.939124099904 +  -0.563609820499*_Complex_I};
 
-float complex fft_test_y157[] = {
+_Fcomplex fft_test_y157[] = {
   -13.721520175468 +  -9.568907767571*_Complex_I,
     8.721468524756 + -10.198063416643*_Complex_I,
    15.060716782723 + -14.846901712846*_Complex_I,
@@ -343,4 +343,3 @@ float complex fft_test_y157[] = {
   -10.919624558299 +  16.105413828801*_Complex_I,
    15.081167155045 +  -6.737986374676*_Complex_I,
     5.602666437487 + -19.846630500695*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_16.c b/src/fft/tests/data/fft_data_16.c
index 5cafff59..828cf9ec 100644
--- a/src/fft/tests/data/fft_data_16.c
+++ b/src/fft/tests/data/fft_data_16.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x16[] = {
+_Fcomplex fft_test_x16[] = {
    -1.772146047027 +   0.295934658602*_Complex_I,
    -1.433777343858 +  -0.874041962217*_Complex_I,
    -0.388629405392 +   0.611030474954*_Complex_I,
@@ -44,7 +44,7 @@ float complex fft_test_x16[] = {
     1.263302572543 +   1.444493924498*_Complex_I,
     1.911070541506 +  -1.906912076526*_Complex_I};
 
-float complex fft_test_y16[] = {
+_Fcomplex fft_test_y16[] = {
     2.369381184706 +  -2.621483536381*_Complex_I,
    -2.618054253504 +   4.676728363894*_Complex_I,
    -2.946376269367 +   0.522273546089*_Complex_I,
@@ -61,4 +61,3 @@ float complex fft_test_y16[] = {
    -8.091926054909 +  -8.469369525668*_Complex_I,
     2.733814414891 +  -7.076455598181*_Complex_I,
    -3.292118248586 +  -0.910613204873*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_17.c b/src/fft/tests/data/fft_data_17.c
index 6f5373a9..5b9448f4 100644
--- a/src/fft/tests/data/fft_data_17.c
+++ b/src/fft/tests/data/fft_data_17.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x17[] = {
+_Fcomplex fft_test_x17[] = {
    -0.655587921776 +  -0.863886550358*_Complex_I,
    -1.070139919529 +  -2.370656605854*_Complex_I,
     1.167384281127 +   0.116747569575*_Complex_I,
@@ -45,7 +45,7 @@ float complex fft_test_x17[] = {
    -0.236452649938 +  -0.998080495482*_Complex_I,
    -0.197908967423 +  -0.229518503722*_Complex_I};
 
-float complex fft_test_y17[] = {
+_Fcomplex fft_test_y17[] = {
    -0.719066520735 +  -6.089659996026*_Complex_I,
     1.821427336790 +  -5.621144218242*_Complex_I,
    -6.173678834923 +  -4.525807530343*_Complex_I,
@@ -63,4 +63,3 @@ float complex fft_test_y17[] = {
     0.253410312032 +   6.386316111258*_Complex_I,
    -4.676752932337 +  -4.421634395132*_Complex_I,
     0.671908500186 +  -2.755072636947*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_192.c b/src/fft/tests/data/fft_data_192.c
index 402d803f..b4e790b0 100644
--- a/src/fft/tests/data/fft_data_192.c
+++ b/src/fft/tests/data/fft_data_192.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x192[] = {
+_Fcomplex fft_test_x192[] = {
    -0.570749076040 +   1.623496753738*_Complex_I,
    -0.801441214588 +  -0.237768079755*_Complex_I,
    -1.136144657269 +   0.367681411439*_Complex_I,
@@ -220,7 +220,7 @@ float complex fft_test_x192[] = {
    -2.719012193329 +  -0.412270955448*_Complex_I,
     1.447794971270 +   0.160429136252*_Complex_I};
 
-float complex fft_test_y192[] = {
+_Fcomplex fft_test_y192[] = {
    11.637079481157 +  -8.771861743960*_Complex_I,
   -26.395324212554 + -12.523034709229*_Complex_I,
   -13.199274560613 +   4.197128353434*_Complex_I,
@@ -413,4 +413,3 @@ float complex fft_test_y192[] = {
   -18.157842430552 +  -5.316780213393*_Complex_I,
    -5.293208686973 +  -3.663831551237*_Complex_I,
    10.661425533836 +  11.243445036012*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_2.c b/src/fft/tests/data/fft_data_2.c
index 0881fa82..194bb891 100644
--- a/src/fft/tests/data/fft_data_2.c
+++ b/src/fft/tests/data/fft_data_2.c
@@ -26,11 +26,10 @@
 
 #include <complex.h>
 
-float complex fft_test_x2[] = {
+_Fcomplex fft_test_x2[] = {
    -0.442695266914 +  -1.176601139920*_Complex_I,
     0.164300702210 +   0.941269951205*_Complex_I};
 
-float complex fft_test_y2[] = {
+_Fcomplex fft_test_y2[] = {
    -0.278394564704 +  -0.235331188715*_Complex_I,
    -0.606995969123 +  -2.117871091124*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_20.c b/src/fft/tests/data/fft_data_20.c
index 41cc574c..e2760e17 100644
--- a/src/fft/tests/data/fft_data_20.c
+++ b/src/fft/tests/data/fft_data_20.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x20[] = {
+_Fcomplex fft_test_x20[] = {
    -0.138174469322 +  -0.274748504122*_Complex_I,
    -1.227476709426 +   0.905279873773*_Complex_I,
    -0.940584818722 +  -0.463678927507*_Complex_I,
@@ -48,7 +48,7 @@ float complex fft_test_x20[] = {
     1.623836928491 +  -1.265873017618*_Complex_I,
     1.568843067308 +  -0.364404259258*_Complex_I};
 
-float complex fft_test_y20[] = {
+_Fcomplex fft_test_y20[] = {
     3.993406537683 +   1.703197921701*_Complex_I,
     3.008874212687 +   7.663142996950*_Complex_I,
    -1.159042365700 +   3.282695683450*_Complex_I,
@@ -69,4 +69,3 @@ float complex fft_test_y20[] = {
    -1.972088145081 +  -6.957222482710*_Complex_I,
    -3.101333982661 +  -2.675851028288*_Complex_I,
     0.394807719219 +  -9.452730429599*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_21.c b/src/fft/tests/data/fft_data_21.c
index 13db4a9e..bb414906 100644
--- a/src/fft/tests/data/fft_data_21.c
+++ b/src/fft/tests/data/fft_data_21.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x21[] = {
+_Fcomplex fft_test_x21[] = {
    -0.292459060095 +  -0.918931582987*_Complex_I,
    -1.517033866291 +  -0.323416256164*_Complex_I,
    -1.482752904272 +   0.244611310478*_Complex_I,
@@ -49,7 +49,7 @@ float complex fft_test_x21[] = {
    -0.060107647935 +  -1.182219308121*_Complex_I,
    -1.630393758159 +  -1.763218511036*_Complex_I};
 
-float complex fft_test_y21[] = {
+_Fcomplex fft_test_y21[] = {
    -5.974374656733 +  -4.525302735571*_Complex_I,
    -3.602445825195 +  -3.324518378407*_Complex_I,
     1.072414517043 +  -2.680697729601*_Complex_I,
@@ -71,4 +71,3 @@ float complex fft_test_y21[] = {
   -10.003872665072 +  -7.143199142087*_Complex_I,
    -2.863331203221 +  -6.794540372208*_Complex_I,
    -6.854994833120 +   1.039966706231*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_22.c b/src/fft/tests/data/fft_data_22.c
index 85728ed9..fbab3445 100644
--- a/src/fft/tests/data/fft_data_22.c
+++ b/src/fft/tests/data/fft_data_22.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x22[] = {
+_Fcomplex fft_test_x22[] = {
     1.005393906711 +   1.012308570546*_Complex_I,
     1.688071880070 +   1.150240841419*_Complex_I,
     0.683345289428 +  -0.062623351865*_Complex_I,
@@ -50,7 +50,7 @@ float complex fft_test_x22[] = {
     0.405414441208 +   0.272172965895*_Complex_I,
     0.522244149054 +   0.024648904750*_Complex_I};
 
-float complex fft_test_y22[] = {
+_Fcomplex fft_test_y22[] = {
     3.812584769431 +   6.167167051279*_Complex_I,
    -2.048551145080 +   1.920025824226*_Complex_I,
     6.865239600362 +  -6.254294174522*_Complex_I,
@@ -73,4 +73,3 @@ float complex fft_test_y22[] = {
     2.420796442681 +  -1.572310054104*_Complex_I,
    11.406980883199 +  10.003031983787*_Complex_I,
    -0.999573899550 +  -0.554680582506*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_24.c b/src/fft/tests/data/fft_data_24.c
index 87362356..93873327 100644
--- a/src/fft/tests/data/fft_data_24.c
+++ b/src/fft/tests/data/fft_data_24.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x24[] = {
+_Fcomplex fft_test_x24[] = {
    -1.420307293620 +   0.936847943063*_Complex_I,
    -0.496969771953 +   0.590714565032*_Complex_I,
    -1.354677361467 +  -2.010032405560*_Complex_I,
@@ -52,7 +52,7 @@ float complex fft_test_x24[] = {
     0.506952261982 +  -1.310440154883*_Complex_I,
    -0.131823537621 +   1.440176198054*_Complex_I};
 
-float complex fft_test_y24[] = {
+_Fcomplex fft_test_y24[] = {
    -4.984028609200 +  -4.220215070640*_Complex_I,
    -4.250507506099 +   6.724208699822*_Complex_I,
     0.057360770043 +   0.512716211712*_Complex_I,
@@ -77,4 +77,3 @@ float complex fft_test_y24[] = {
    -5.710969715584 +   4.204863120029*_Complex_I,
     2.683867262111 +  -0.108391775481*_Complex_I,
    -1.068500953539 +  -4.689297523031*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_26.c b/src/fft/tests/data/fft_data_26.c
index 4b9866aa..bb29cca9 100644
--- a/src/fft/tests/data/fft_data_26.c
+++ b/src/fft/tests/data/fft_data_26.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x26[] = {
+_Fcomplex fft_test_x26[] = {
    -1.513790990128 +   0.450104660529*_Complex_I,
    -0.609587704775 +   0.200963343771*_Complex_I,
     1.150854971928 +  -0.979670346844*_Complex_I,
@@ -54,7 +54,7 @@ float complex fft_test_x26[] = {
     1.002599293378 +   0.297630901673*_Complex_I,
    -1.821267785996 +   1.027493831629*_Complex_I};
 
-float complex fft_test_y26[] = {
+_Fcomplex fft_test_y26[] = {
     2.337267962069 +  -6.968672891765*_Complex_I,
    -1.374144569280 +   2.440460452235*_Complex_I,
     0.293963382503 +  -1.014603415840*_Complex_I,
@@ -81,4 +81,3 @@ float complex fft_test_y26[] = {
    -0.768605942699 +   3.726121287503*_Complex_I,
    -1.461710271209 +  -1.198541330006*_Complex_I,
    -6.415081077369 +   5.044238707360*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_3.c b/src/fft/tests/data/fft_data_3.c
index aed8a249..577fcfe2 100644
--- a/src/fft/tests/data/fft_data_3.c
+++ b/src/fft/tests/data/fft_data_3.c
@@ -26,13 +26,12 @@
 
 #include <complex.h>
 
-float complex fft_test_x3[] = {
+_Fcomplex fft_test_x3[] = {
    -0.757661328095 +   0.655250200055*_Complex_I,
    -1.262964116539 +   0.804288531547*_Complex_I,
     0.075727215016 +  -0.825503865060*_Complex_I};
 
-float complex fft_test_y3[] = {
+_Fcomplex fft_test_y3[] = {
    -1.944898229617 +   0.634034866542*_Complex_I,
     1.247398741022 +   1.825198567765*_Complex_I,
    -1.575484495691 +  -0.493482834141*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_30.c b/src/fft/tests/data/fft_data_30.c
index 497b4db1..8a87cdae 100644
--- a/src/fft/tests/data/fft_data_30.c
+++ b/src/fft/tests/data/fft_data_30.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x30[] = {
+_Fcomplex fft_test_x30[] = {
     1.383958311928 +   1.009063372834*_Complex_I,
     0.656943839727 +  -0.201492142788*_Complex_I,
    -1.263185461543 +  -0.762235271683*_Complex_I,
@@ -58,7 +58,7 @@ float complex fft_test_x30[] = {
     0.526429110861 +  -1.368405705104*_Complex_I,
    -0.688995272873 +   0.833548127008*_Complex_I};
 
-float complex fft_test_y30[] = {
+_Fcomplex fft_test_y30[] = {
     0.294027040082 +  -0.664790204608*_Complex_I,
    -7.251086654153 +   1.930700457878*_Complex_I,
     4.192769230897 +   1.789725983362*_Complex_I,
@@ -89,4 +89,3 @@ float complex fft_test_y30[] = {
    -8.507611683876 +   0.041180219148*_Complex_I,
     3.499272220645 +   8.240657702592*_Complex_I,
     1.080399112219 +  -7.557152066173*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_317.c b/src/fft/tests/data/fft_data_317.c
index b1c23ea1..ef5b6b10 100644
--- a/src/fft/tests/data/fft_data_317.c
+++ b/src/fft/tests/data/fft_data_317.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x317[] = {
+_Fcomplex fft_test_x317[] = {
     0.554097588235 +   0.674837317416*_Complex_I,
     0.530737753317 +  -0.079409691311*_Complex_I,
     0.132225792019 +  -2.683942671459*_Complex_I,
@@ -345,7 +345,7 @@ float complex fft_test_x317[] = {
    -1.535360519901 +  -0.437319427483*_Complex_I,
     1.026878345705 +  -0.182042614613*_Complex_I};
 
-float complex fft_test_y317[] = {
+_Fcomplex fft_test_y317[] = {
    19.891894947904 +   5.655090929781*_Complex_I,
    18.838569316919 + -27.216365987549*_Complex_I,
   -11.140787864820 +  -1.700693291107*_Complex_I,
@@ -663,4 +663,3 @@ float complex fft_test_y317[] = {
    14.009362482345 + -20.358022264859*_Complex_I,
     7.316431660011 +  26.887415857021*_Complex_I,
     8.199534997352 +  -2.435205163079*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_32.c b/src/fft/tests/data/fft_data_32.c
index c0971111..05c386c0 100644
--- a/src/fft/tests/data/fft_data_32.c
+++ b/src/fft/tests/data/fft_data_32.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x32[] = {
+_Fcomplex fft_test_x32[] = {
     0.010014623512 +   0.557635892111*_Complex_I,
    -0.206536736342 +  -0.166543150147*_Complex_I,
     0.538145349965 +  -1.725439447290*_Complex_I,
@@ -60,7 +60,7 @@ float complex fft_test_x32[] = {
     0.773269391236 +  -0.854101525457*_Complex_I,
    -0.320046719055 +  -0.112754382318*_Complex_I};
 
-float complex fft_test_y32[] = {
+_Fcomplex fft_test_y32[] = {
    -1.249387330241 +  -4.946207393990*_Complex_I,
     6.246388763884 +  -6.773507691880*_Complex_I,
    -8.084921469264 + -10.845914953315*_Complex_I,
@@ -93,4 +93,3 @@ float complex fft_test_y32[] = {
     4.394902822920 +  12.095339998118*_Complex_I,
    -3.828535537115 +   2.263473712749*_Complex_I,
    -6.081522756885 +  -0.365006140312*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_35.c b/src/fft/tests/data/fft_data_35.c
index 347eea7e..a78b1a3e 100644
--- a/src/fft/tests/data/fft_data_35.c
+++ b/src/fft/tests/data/fft_data_35.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x35[] = {
+_Fcomplex fft_test_x35[] = {
     0.621203985274 +  -1.170486588571*_Complex_I,
     0.001346936460 +   0.911992162865*_Complex_I,
     0.852266167932 +  -0.485602417107*_Complex_I,
@@ -63,7 +63,7 @@ float complex fft_test_x35[] = {
    -0.690987494413 +   0.744128091375*_Complex_I,
     0.074647158829 +  -1.048901976585*_Complex_I};
 
-float complex fft_test_y35[] = {
+_Fcomplex fft_test_y35[] = {
     2.309567594431 +  -5.331826820366*_Complex_I,
    -7.442846930878 +  -4.725553620071*_Complex_I,
    -2.183297818919 +   6.404493143269*_Complex_I,
@@ -99,4 +99,3 @@ float complex fft_test_y35[] = {
     1.294145378923 +  -2.702480168973*_Complex_I,
     1.886124883788 +  -3.741139781213*_Complex_I,
     7.958277715545 +  -3.144460685955*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_36.c b/src/fft/tests/data/fft_data_36.c
index 7e624d00..7c4746f0 100644
--- a/src/fft/tests/data/fft_data_36.c
+++ b/src/fft/tests/data/fft_data_36.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x36[] = {
+_Fcomplex fft_test_x36[] = {
    -0.515260084522 +   1.287529717076*_Complex_I,
     0.587117158481 +  -0.148572876243*_Complex_I,
    -0.782947562463 +   1.641852621518*_Complex_I,
@@ -64,7 +64,7 @@ float complex fft_test_x36[] = {
    -1.720946712489 +  -0.251050064927*_Complex_I,
    -0.304668621370 +  -0.437688673914*_Complex_I};
 
-float complex fft_test_y36[] = {
+_Fcomplex fft_test_y36[] = {
    -6.978283472983 +   7.583625277009*_Complex_I,
    -6.674217696450 +  -3.304059977181*_Complex_I,
    -9.133615960691 +   4.553754806959*_Complex_I,
@@ -101,4 +101,3 @@ float complex fft_test_y36[] = {
    -1.014341113192 +   7.641158118573*_Complex_I,
    -4.249655466965 +   2.206889911886*_Complex_I,
     0.602106144731 +  -0.611713697716*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_4.c b/src/fft/tests/data/fft_data_4.c
index fffbc2c5..61ef564c 100644
--- a/src/fft/tests/data/fft_data_4.c
+++ b/src/fft/tests/data/fft_data_4.c
@@ -26,15 +26,14 @@
 
 #include <complex.h>
 
-float complex fft_test_x4[] = {
+_Fcomplex fft_test_x4[] = {
    -2.218920151449 +  -1.079004048069*_Complex_I,
     0.045264423484 +   0.426155393025*_Complex_I,
     0.218614474268 +  -0.334711618319*_Complex_I,
     2.182538230032 +   1.706944462070*_Complex_I};
 
-float complex fft_test_y4[] = {
+_Fcomplex fft_test_y4[] = {
     0.227496976335 +   0.719384188708*_Complex_I,
    -3.718323694762 +   1.392981376798*_Complex_I,
    -4.228108330697 +  -3.546815521483*_Complex_I,
    -1.156745556672 +  -2.881566236299*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_43.c b/src/fft/tests/data/fft_data_43.c
index 057b9784..4f2e2b81 100644
--- a/src/fft/tests/data/fft_data_43.c
+++ b/src/fft/tests/data/fft_data_43.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x43[] = {
+_Fcomplex fft_test_x43[] = {
     0.086214736594 +  -0.374055466225*_Complex_I,
    -0.398326405553 +   0.064437628903*_Complex_I,
    -0.086828498048 +  -1.377541893939*_Complex_I,
@@ -71,7 +71,7 @@ float complex fft_test_x43[] = {
    -1.225108444904 +  -0.762684444639*_Complex_I,
     0.510768457794 +   0.200474501150*_Complex_I};
 
-float complex fft_test_y43[] = {
+_Fcomplex fft_test_y43[] = {
     5.970664941924 +   2.123419383178*_Complex_I,
    -4.826258373494 + -10.530035821412*_Complex_I,
    -6.840438649504 +   2.195697396144*_Complex_I,
@@ -115,4 +115,3 @@ float complex fft_test_y43[] = {
    -1.686631417770 +  -4.776809881210*_Complex_I,
    -2.550902604765 +  -2.082230855079*_Complex_I,
     9.773642843061 +  -9.294902010297*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_48.c b/src/fft/tests/data/fft_data_48.c
index 15b0bdc6..ba4b196f 100644
--- a/src/fft/tests/data/fft_data_48.c
+++ b/src/fft/tests/data/fft_data_48.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x48[] = {
+_Fcomplex fft_test_x48[] = {
    -1.408383409504 +   0.661990153106*_Complex_I,
    -0.257850483647 +  -2.392863066952*_Complex_I,
    -0.321563284081 +   1.408168751420*_Complex_I,
@@ -76,7 +76,7 @@ float complex fft_test_x48[] = {
     0.315403114502 +   0.409584212993*_Complex_I,
     0.777007938735 +   0.033642728423*_Complex_I};
 
-float complex fft_test_y48[] = {
+_Fcomplex fft_test_y48[] = {
     5.666636855245 +  -5.718253686246*_Complex_I,
    -9.318440723038 + -11.045628239935*_Complex_I,
   -10.484391800934 +  10.258547835119*_Complex_I,
@@ -125,4 +125,3 @@ float complex fft_test_y48[] = {
    -6.905056488040 +  -1.077414483536*_Complex_I,
    -6.906638779165 +  -3.861138554296*_Complex_I,
    -0.790121808651 +  -0.288436445313*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_5.c b/src/fft/tests/data/fft_data_5.c
index 0a8b87dc..9d62d035 100644
--- a/src/fft/tests/data/fft_data_5.c
+++ b/src/fft/tests/data/fft_data_5.c
@@ -26,17 +26,16 @@
 
 #include <complex.h>
 
-float complex fft_test_x5[] = {
+_Fcomplex fft_test_x5[] = {
     1.043452789296 +  -0.216675780077*_Complex_I,
    -0.039259154719 +  -0.756503590362*_Complex_I,
    -1.378329383804 +  -1.629692578129*_Complex_I,
     0.695728357044 +  -2.639675956000*_Complex_I,
    -0.019932891052 +   0.123958045411*_Complex_I};
 
-float complex fft_test_y5[] = {
+_Fcomplex fft_test_y5[] = {
     0.301659716765 +  -5.118589859158*_Complex_I,
     1.333681830770 +   4.279329517647*_Complex_I,
    -0.597668794979 +  -2.985429553632*_Complex_I,
     2.358478480201 +   0.936943320049*_Complex_I,
     1.821112713724 +   1.804367674708*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_509.c b/src/fft/tests/data/fft_data_509.c
index 15e52c4f..12d17848 100644
--- a/src/fft/tests/data/fft_data_509.c
+++ b/src/fft/tests/data/fft_data_509.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x509[] = {
+_Fcomplex fft_test_x509[] = {
     0.359331995889 +  -1.085301108776*_Complex_I,
    -1.932383412518 +   0.116856180907*_Complex_I,
     0.496271262268 +   0.731796541816*_Complex_I,
@@ -537,7 +537,7 @@ float complex fft_test_x509[] = {
    -0.186548224004 +   0.410695725270*_Complex_I,
    -0.138866088362 +  -0.530179759052*_Complex_I};
 
-float complex fft_test_y509[] = {
+_Fcomplex fft_test_y509[] = {
    15.695701816574 +  18.430646076972*_Complex_I,
    17.496535538521 +   6.323908273548*_Complex_I,
   -15.330535795607 + -16.826373817993*_Complex_I,
@@ -1047,4 +1047,3 @@ float complex fft_test_y509[] = {
    -3.293543380713 +  15.964518188392*_Complex_I,
   -15.175792848341 +  -2.924538577813*_Complex_I,
    17.561582795484 +  -3.560828531875*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_6.c b/src/fft/tests/data/fft_data_6.c
index f6b976e0..11eb6319 100644
--- a/src/fft/tests/data/fft_data_6.c
+++ b/src/fft/tests/data/fft_data_6.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x6[] = {
+_Fcomplex fft_test_x6[] = {
    -0.946868805918 +   0.048419613876*_Complex_I,
    -1.426556442325 +   1.356194807524*_Complex_I,
     0.262357323076 +   1.594616904796*_Complex_I,
@@ -34,11 +34,10 @@ float complex fft_test_x6[] = {
    -0.271359734201 +  -2.390517158747*_Complex_I,
    -0.288151144041 +   0.071324517238*_Complex_I};
 
-float complex fft_test_y6[] = {
+_Fcomplex fft_test_y6[] = {
    -3.703491324072 +   0.726430280150*_Complex_I,
     3.797148775593 +   1.637413185851*_Complex_I,
    -3.456423352393 +   1.227102112087*_Complex_I,
     1.791748889984 +  -2.221391560299*_Complex_I,
     1.220570696725 +  -1.669098764217*_Complex_I,
    -5.330766521347 +   0.590062429687*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_63.c b/src/fft/tests/data/fft_data_63.c
index b0a66c97..73cb0776 100644
--- a/src/fft/tests/data/fft_data_63.c
+++ b/src/fft/tests/data/fft_data_63.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x63[] = {
+_Fcomplex fft_test_x63[] = {
    -0.165065089334 +   1.102101871091*_Complex_I,
    -0.981973148546 +   0.541468656777*_Complex_I,
    -0.253554650102 +  -0.121332795252*_Complex_I,
@@ -91,7 +91,7 @@ float complex fft_test_x63[] = {
     0.135839855058 +  -0.627341937358*_Complex_I,
    -0.335848209970 +  -2.547865701465*_Complex_I};
 
-float complex fft_test_y63[] = {
+_Fcomplex fft_test_y63[] = {
    -7.089662066859 +   9.296545614813*_Complex_I,
    -8.501752827269 +   5.888942352564*_Complex_I,
     3.278359396134 +   3.509899786067*_Complex_I,
@@ -155,4 +155,3 @@ float complex fft_test_y63[] = {
    -2.621123339590 +  -4.576508645033*_Complex_I,
     3.116382580437 + -13.991211520556*_Complex_I,
   -15.293666222030 +   1.998407515632*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_64.c b/src/fft/tests/data/fft_data_64.c
index cc300bc6..838b9583 100644
--- a/src/fft/tests/data/fft_data_64.c
+++ b/src/fft/tests/data/fft_data_64.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x64[] = {
+_Fcomplex fft_test_x64[] = {
    -0.021754290353 +  -0.612017802190*_Complex_I,
     0.484276408753 +   0.753944723650*_Complex_I,
    -1.051031916820 +   0.166448506301*_Complex_I,
@@ -92,7 +92,7 @@ float complex fft_test_x64[] = {
     0.804170356884 +   0.191021429001*_Complex_I,
    -0.141790367715 +   0.873289762818*_Complex_I};
 
-float complex fft_test_y64[] = {
+_Fcomplex fft_test_y64[] = {
     1.725198076750 +  -4.343291505303*_Complex_I,
    -1.306135600819 +  -7.829723137959*_Complex_I,
    -5.438260077023 +   4.634490918041*_Complex_I,
@@ -157,4 +157,3 @@ float complex fft_test_y64[] = {
     4.186354051025 +  -2.044041800204*_Complex_I,
    14.017389932813 +   2.146139910120*_Complex_I,
     4.242720273094 +  -3.627670543295*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_7.c b/src/fft/tests/data/fft_data_7.c
index b38fcfe7..8042d002 100644
--- a/src/fft/tests/data/fft_data_7.c
+++ b/src/fft/tests/data/fft_data_7.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x7[] = {
+_Fcomplex fft_test_x7[] = {
     0.325737557343 +   0.347762560645*_Complex_I,
    -0.464568614672 +   1.344201995758*_Complex_I,
    -1.458140194879 +   0.983317270098*_Complex_I,
@@ -35,7 +35,7 @@ float complex fft_test_x7[] = {
     0.986194459374 +  -1.709315563086*_Complex_I,
     0.387998802736 +  -1.150726066104*_Complex_I};
 
-float complex fft_test_y7[] = {
+_Fcomplex fft_test_y7[] = {
     1.277780500734 +   0.128729329387*_Complex_I,
     4.360250363806 +   2.591163135631*_Complex_I,
     1.609972293897 +   2.377175130550*_Complex_I,
@@ -43,4 +43,3 @@ float complex fft_test_y7[] = {
    -0.903757801309 +   3.003131513942*_Complex_I,
     1.797162255231 +  -0.068636624441*_Complex_I,
    -6.298133600593 +  -1.896165736688*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_79.c b/src/fft/tests/data/fft_data_79.c
index c39c8af0..96b97313 100644
--- a/src/fft/tests/data/fft_data_79.c
+++ b/src/fft/tests/data/fft_data_79.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x79[] = {
+_Fcomplex fft_test_x79[] = {
    -0.831644933479 +  -1.369566252119*_Complex_I,
     1.382261515245 +   0.344632239578*_Complex_I,
     1.522173067917 +  -0.879128649493*_Complex_I,
@@ -107,7 +107,7 @@ float complex fft_test_x79[] = {
    -2.389508044422 +  -0.601457844861*_Complex_I,
     0.080578131708 +   0.388813172800*_Complex_I};
 
-float complex fft_test_y79[] = {
+_Fcomplex fft_test_y79[] = {
    -2.198332092440 +  12.650658598176*_Complex_I,
    -6.456670989242 +  -7.479301674890*_Complex_I,
    -2.895336385229 +   1.221846928494*_Complex_I,
@@ -187,4 +187,3 @@ float complex fft_test_y79[] = {
     6.265639354108 +  13.611595323686*_Complex_I,
   -11.081101178789 + -14.511845349920*_Complex_I,
     4.451917671114 + -12.130333484146*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_8.c b/src/fft/tests/data/fft_data_8.c
index a86eebfd..bd72f95e 100644
--- a/src/fft/tests/data/fft_data_8.c
+++ b/src/fft/tests/data/fft_data_8.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x8[] = {
+_Fcomplex fft_test_x8[] = {
     1.143832659273 +   0.058730029889*_Complex_I,
    -0.094390429919 +   0.229144161540*_Complex_I,
    -0.231936945111 +   0.250418514706*_Complex_I,
@@ -36,7 +36,7 @@ float complex fft_test_x8[] = {
     0.928035714223 +   0.647778401795*_Complex_I,
     0.441211141066 +  -1.176622015089*_Complex_I};
 
-float complex fft_test_y8[] = {
+_Fcomplex fft_test_y8[] = {
     2.566466439667 +  -0.294719550271*_Complex_I,
     1.635071437815 +   1.055386414782*_Complex_I,
     1.767442826430 +   0.508277941207*_Complex_I,
@@ -45,4 +45,3 @@ float complex fft_test_y8[] = {
     0.548438211721 +  -0.969987712376*_Complex_I,
    -1.562539151277 +   0.164794961607*_Complex_I,
     0.808336864628 +  -2.536589771219*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_9.c b/src/fft/tests/data/fft_data_9.c
index 08639b28..92a845fa 100644
--- a/src/fft/tests/data/fft_data_9.c
+++ b/src/fft/tests/data/fft_data_9.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x9[] = {
+_Fcomplex fft_test_x9[] = {
     0.318149471742 +  -0.872622265472*_Complex_I,
     0.380460329361 +   0.204662364547*_Complex_I,
    -0.569767779072 +  -0.271995206036*_Complex_I,
@@ -37,7 +37,7 @@ float complex fft_test_x9[] = {
    -0.138901921376 +  -0.646377338691*_Complex_I,
    -0.257444231274 +   0.857372365765*_Complex_I};
 
-float complex fft_test_y9[] = {
+_Fcomplex fft_test_y9[] = {
     1.715730541604 +  -2.026530635857*_Complex_I,
     1.685963762512 +   0.399226582084*_Complex_I,
    -4.115380429157 +   1.255898079784*_Complex_I,
@@ -47,4 +47,3 @@ float complex fft_test_y9[] = {
     4.501171713926 +  -3.110763575667*_Complex_I,
     1.269999384456 +   3.193455688437*_Complex_I,
    -2.092752848444 +  -0.511914105207*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_92.c b/src/fft/tests/data/fft_data_92.c
index df7c3f96..1bb18528 100644
--- a/src/fft/tests/data/fft_data_92.c
+++ b/src/fft/tests/data/fft_data_92.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x92[] = {
+_Fcomplex fft_test_x92[] = {
    -1.533248238739 +  -0.465630703218*_Complex_I,
    -0.249958865116 +   0.582751340535*_Complex_I,
    -0.052014206281 +   0.945510877668*_Complex_I,
@@ -120,7 +120,7 @@ float complex fft_test_x92[] = {
    -1.343771938200 +  -0.320382155842*_Complex_I,
    -0.432681592095 +   0.159701208438*_Complex_I};
 
-float complex fft_test_y92[] = {
+_Fcomplex fft_test_y92[] = {
    -2.518102271573 +  10.044654216417*_Complex_I,
     6.643542265073 +   4.256887583025*_Complex_I,
   -11.918532524663 +   7.755442009935*_Complex_I,
@@ -213,4 +213,3 @@ float complex fft_test_y92[] = {
    -6.362077161917 +  -2.563077169544*_Complex_I,
     5.636818008460 + -11.718358270750*_Complex_I,
   -12.128080581717 +   5.291433812970*_Complex_I};
-
diff --git a/src/fft/tests/data/fft_data_96.c b/src/fft/tests/data/fft_data_96.c
index a7fecd92..caf83957 100644
--- a/src/fft/tests/data/fft_data_96.c
+++ b/src/fft/tests/data/fft_data_96.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fft_test_x96[] = {
+_Fcomplex fft_test_x96[] = {
     0.231855789328 +   0.392790591230*_Complex_I,
     0.454049797380 +   0.679061446432*_Complex_I,
     0.528744029877 +  -0.002005026486*_Complex_I,
@@ -124,7 +124,7 @@ float complex fft_test_x96[] = {
     1.174746235178 +  -1.612669537430*_Complex_I,
     0.896264508571 +   0.843449048976*_Complex_I};
 
-float complex fft_test_y96[] = {
+_Fcomplex fft_test_y96[] = {
     4.609981707790 +  14.165957863955*_Complex_I,
    -2.663372690989 +   3.381865489792*_Complex_I,
    -6.250889898983 +   0.856018997500*_Complex_I,
@@ -221,4 +221,3 @@ float complex fft_test_y96[] = {
    -5.241064162059 +  -8.249917715987*_Complex_I,
    -0.085493630186 +  -3.829269584478*_Complex_I,
     3.782595963629 +  -0.412071285666*_Complex_I};
-
diff --git a/src/fft/tests/fft_runtest.c b/src/fft/tests/fft_runtest.c
index 9be4739f..fadce5ec 100644
--- a/src/fft/tests/fft_runtest.c
+++ b/src/fft/tests/fft_runtest.c
@@ -27,8 +27,8 @@
 //  _x      :   fft input array
 //  _test   :   expected fft output
 //  _n      :   fft size
-void fft_test(float complex * _x,
-              float complex * _test,
+void fft_test(_Fcomplex * _x,
+              _Fcomplex * _test,
               unsigned int    _n)
 {
     int _method = 0;
@@ -36,7 +36,7 @@ void fft_test(float complex * _x,
 
     unsigned int i;
 
-    float complex y[_n], z[_n];
+    _Fcomplex y[_n], z[_n];
 
     // compute FFT
     fftplan pf = fft_create_plan(_n, _x, y, LIQUID_FFT_FORWARD, _method);
@@ -63,4 +63,3 @@ void fft_test(float complex * _x,
     fft_destroy_plan(pf);
     fft_destroy_plan(pr);
 }
-
diff --git a/src/fft/tests/fft_runtest.h b/src/fft/tests/fft_runtest.h
index 92a0e83a..9eadb732 100644
--- a/src/fft/tests/fft_runtest.h
+++ b/src/fft/tests/fft_runtest.h
@@ -31,115 +31,115 @@
 //  _x      :   fft input array
 //  _test   :   expected fft output
 //  _n      :   fft size
-void fft_test(float complex * _x,
-              float complex * _test,
+void fft_test(_Fcomplex * _x,
+              _Fcomplex * _test,
               unsigned int    _n);
 
-// 
+//
 // autotest datasets
 //
 
 //
-extern float complex fft_test_x2[];
-extern float complex fft_test_y2[];
+extern _Fcomplex fft_test_x2[];
+extern _Fcomplex fft_test_y2[];
 
-extern float complex fft_test_x3[];
-extern float complex fft_test_y3[];
+extern _Fcomplex fft_test_x3[];
+extern _Fcomplex fft_test_y3[];
 
-extern float complex fft_test_x4[];
-extern float complex fft_test_y4[];
+extern _Fcomplex fft_test_x4[];
+extern _Fcomplex fft_test_y4[];
 
-extern float complex fft_test_x5[];
-extern float complex fft_test_y5[];
+extern _Fcomplex fft_test_x5[];
+extern _Fcomplex fft_test_y5[];
 
-extern float complex fft_test_x6[];
-extern float complex fft_test_y6[];
+extern _Fcomplex fft_test_x6[];
+extern _Fcomplex fft_test_y6[];
 
-extern float complex fft_test_x7[];
-extern float complex fft_test_y7[];
+extern _Fcomplex fft_test_x7[];
+extern _Fcomplex fft_test_y7[];
 
-extern float complex fft_test_x8[];
-extern float complex fft_test_y8[];
+extern _Fcomplex fft_test_x8[];
+extern _Fcomplex fft_test_y8[];
 
-extern float complex fft_test_x9[];
-extern float complex fft_test_y9[];
+extern _Fcomplex fft_test_x9[];
+extern _Fcomplex fft_test_y9[];
 
 //
-extern float complex fft_test_x10[];
-extern float complex fft_test_y10[];
+extern _Fcomplex fft_test_x10[];
+extern _Fcomplex fft_test_y10[];
 
-extern float complex fft_test_x16[];
-extern float complex fft_test_y16[];
+extern _Fcomplex fft_test_x16[];
+extern _Fcomplex fft_test_y16[];
 
-extern float complex fft_test_x17[];
-extern float complex fft_test_y17[];
+extern _Fcomplex fft_test_x17[];
+extern _Fcomplex fft_test_y17[];
 
-extern float complex fft_test_x20[];
-extern float complex fft_test_y20[];
+extern _Fcomplex fft_test_x20[];
+extern _Fcomplex fft_test_y20[];
 
-extern float complex fft_test_x21[];
-extern float complex fft_test_y21[];
+extern _Fcomplex fft_test_x21[];
+extern _Fcomplex fft_test_y21[];
 
-extern float complex fft_test_x22[];
-extern float complex fft_test_y22[];
+extern _Fcomplex fft_test_x22[];
+extern _Fcomplex fft_test_y22[];
 
-extern float complex fft_test_x24[];
-extern float complex fft_test_y24[];
+extern _Fcomplex fft_test_x24[];
+extern _Fcomplex fft_test_y24[];
 
-extern float complex fft_test_x26[];
-extern float complex fft_test_y26[];
+extern _Fcomplex fft_test_x26[];
+extern _Fcomplex fft_test_y26[];
 
-extern float complex fft_test_x30[];
-extern float complex fft_test_y30[];
+extern _Fcomplex fft_test_x30[];
+extern _Fcomplex fft_test_y30[];
 
-extern float complex fft_test_x32[];
-extern float complex fft_test_y32[];
+extern _Fcomplex fft_test_x32[];
+extern _Fcomplex fft_test_y32[];
 
-extern float complex fft_test_x35[];
-extern float complex fft_test_y35[];
+extern _Fcomplex fft_test_x35[];
+extern _Fcomplex fft_test_y35[];
 
-extern float complex fft_test_x36[];
-extern float complex fft_test_y36[];
+extern _Fcomplex fft_test_x36[];
+extern _Fcomplex fft_test_y36[];
 
-extern float complex fft_test_x43[];
-extern float complex fft_test_y43[];
+extern _Fcomplex fft_test_x43[];
+extern _Fcomplex fft_test_y43[];
 
-extern float complex fft_test_x48[];
-extern float complex fft_test_y48[];
+extern _Fcomplex fft_test_x48[];
+extern _Fcomplex fft_test_y48[];
 
-extern float complex fft_test_x63[];
-extern float complex fft_test_y63[];
+extern _Fcomplex fft_test_x63[];
+extern _Fcomplex fft_test_y63[];
 
-extern float complex fft_test_x64[];
-extern float complex fft_test_y64[];
+extern _Fcomplex fft_test_x64[];
+extern _Fcomplex fft_test_y64[];
 
-extern float complex fft_test_x79[];
-extern float complex fft_test_y79[];
+extern _Fcomplex fft_test_x79[];
+extern _Fcomplex fft_test_y79[];
 
-extern float complex fft_test_x92[];
-extern float complex fft_test_y92[];
+extern _Fcomplex fft_test_x92[];
+extern _Fcomplex fft_test_y92[];
 
-extern float complex fft_test_x96[];
-extern float complex fft_test_y96[];
+extern _Fcomplex fft_test_x96[];
+extern _Fcomplex fft_test_y96[];
 
 //
-extern float complex fft_test_x120[];
-extern float complex fft_test_y120[];
+extern _Fcomplex fft_test_x120[];
+extern _Fcomplex fft_test_y120[];
 
-extern float complex fft_test_x130[];
-extern float complex fft_test_y130[];
+extern _Fcomplex fft_test_x130[];
+extern _Fcomplex fft_test_y130[];
 
-extern float complex fft_test_x157[];
-extern float complex fft_test_y157[];
+extern _Fcomplex fft_test_x157[];
+extern _Fcomplex fft_test_y157[];
 
-extern float complex fft_test_x192[];
-extern float complex fft_test_y192[];
+extern _Fcomplex fft_test_x192[];
+extern _Fcomplex fft_test_y192[];
 
-extern float complex fft_test_x317[];
-extern float complex fft_test_y317[];
+extern _Fcomplex fft_test_x317[];
+extern _Fcomplex fft_test_y317[];
 
-extern float complex fft_test_x509[];
-extern float complex fft_test_y509[];
+extern _Fcomplex fft_test_x509[];
+extern _Fcomplex fft_test_y509[];
 
 // 8-point real even/odd dft data
 extern float fftdata_r2r_x8[];
diff --git a/src/fft/tests/fft_shift_autotest.c b/src/fft/tests/fft_shift_autotest.c
index 5c5f1472..24446a77 100644
--- a/src/fft/tests/fft_shift_autotest.c
+++ b/src/fft/tests/fft_shift_autotest.c
@@ -25,14 +25,14 @@
 
 void autotest_fft_shift_4()
 {
-    float complex x[] = {
+    _Fcomplex x[] = {
         0 + 0*_Complex_I,
         1 + 1*_Complex_I,
         2 + 2*_Complex_I,
         3 + 3*_Complex_I
     };
 
-    float complex test[] = {
+    _Fcomplex test[] = {
         2 + 2*_Complex_I,
         3 + 3*_Complex_I,
         0 + 0*_Complex_I,
@@ -41,12 +41,12 @@ void autotest_fft_shift_4()
 
     fft_shift(x,4);
 
-    CONTEND_SAME_DATA(x,test,4*sizeof(float complex));
+    CONTEND_SAME_DATA(x,test,4*sizeof(_Fcomplex));
 }
 
 void autotest_fft_shift_8()
 {
-    float complex x[] = {
+    _Fcomplex x[] = {
         0 + 0*_Complex_I,
         1 + 1*_Complex_I,
         2 + 2*_Complex_I,
@@ -57,7 +57,7 @@ void autotest_fft_shift_8()
         7 + 7*_Complex_I
     };
 
-    float complex test[] = {
+    _Fcomplex test[] = {
         4 + 4*_Complex_I,
         5 + 5*_Complex_I,
         6 + 6*_Complex_I,
@@ -70,6 +70,5 @@ void autotest_fft_shift_8()
 
     fft_shift(x,8);
 
-    CONTEND_SAME_DATA(x,test,8*sizeof(float complex));
+    CONTEND_SAME_DATA(x,test,8*sizeof(_Fcomplex));
 }
-
diff --git a/src/filter/bench/fftfilt_crcf_benchmark.c b/src/filter/bench/fftfilt_crcf_benchmark.c
index 06c6fad2..2c429d87 100644
--- a/src/filter/bench/fftfilt_crcf_benchmark.c
+++ b/src/filter/bench/fftfilt_crcf_benchmark.c
@@ -47,12 +47,12 @@ void fftfilt_crcf_bench(struct rusage *     _start,
     fftfilt_crcf q = fftfilt_crcf_create(h,h_len,_n);
 
     // generate input vector
-    float complex x[_n + 4];
+    _Fcomplex x[_n + 4];
     for (i=0; i<_n+4; i++)
         x[i] = randnf() + _Complex_I*randnf();
 
     // output vector
-    float complex y[_n];
+    _Fcomplex y[_n];
 
     // start trials
     getrusage(RUSAGE_SELF, _start);
@@ -82,4 +82,3 @@ void benchmark_fftfilt_crcf_8    FFTFILT_CRCF_BENCHMARK_API(8)
 void benchmark_fftfilt_crcf_16   FFTFILT_CRCF_BENCHMARK_API(16)
 void benchmark_fftfilt_crcf_32   FFTFILT_CRCF_BENCHMARK_API(32)
 void benchmark_fftfilt_crcf_64   FFTFILT_CRCF_BENCHMARK_API(64)
-
diff --git a/src/filter/bench/firdecim_crcf_benchmark.c b/src/filter/bench/firdecim_crcf_benchmark.c
index 7df1927d..2d1a645a 100644
--- a/src/filter/bench/firdecim_crcf_benchmark.c
+++ b/src/filter/bench/firdecim_crcf_benchmark.c
@@ -42,11 +42,11 @@ void firdecim_crcf_bench(struct rusage *     _start,
     firdecim_crcf q = firdecim_crcf_create(_M,h,_h_len);
 
     // initialize input
-    float complex x[_M];
+    _Fcomplex x[_M];
     for (i=0; i<_M; i++)
         x[i] = (i%2) ? 1.0f : -1.0f;
 
-    float complex y;
+    _Fcomplex y;
 
     // start trials
     getrusage(RUSAGE_SELF, _start);
@@ -73,4 +73,3 @@ void benchmark_firdecim_crcf_m4_h16    FIRDECIM_CRCF_BENCHMARK_API(4, 16)
 void benchmark_firdecim_crcf_m8_h32    FIRDECIM_CRCF_BENCHMARK_API(8, 32)
 void benchmark_firdecim_crcf_m16_h64   FIRDECIM_CRCF_BENCHMARK_API(16,64)
 void benchmark_firdecim_cccf_m32_h128  FIRDECIM_CRCF_BENCHMARK_API(32,128)
-
diff --git a/src/filter/bench/firfilt_crcf_benchmark.c b/src/filter/bench/firfilt_crcf_benchmark.c
index f4d1a869..d0ff15b1 100644
--- a/src/filter/bench/firfilt_crcf_benchmark.c
+++ b/src/filter/bench/firfilt_crcf_benchmark.c
@@ -44,12 +44,12 @@ void firfilt_crcf_bench(struct rusage *_start,
     firfilt_crcf f = firfilt_crcf_create(h,_n);
 
     // generate input vector
-    float complex x[4];
+    _Fcomplex x[4];
     for (i=0; i<4; i++)
         x[i] = randnf() + _Complex_I*randnf();
 
     // output vector
-    float complex y[4];
+    _Fcomplex y[4];
 
     // start trials
     getrusage(RUSAGE_SELF, _start);
@@ -76,4 +76,3 @@ void benchmark_firfilt_crcf_8    FIRFILT_CRCF_BENCHMARK_API(8)
 void benchmark_firfilt_crcf_16   FIRFILT_CRCF_BENCHMARK_API(16)
 void benchmark_firfilt_crcf_32   FIRFILT_CRCF_BENCHMARK_API(32)
 void benchmark_firfilt_crcf_64   FIRFILT_CRCF_BENCHMARK_API(64)
-
diff --git a/src/filter/bench/firhilb_benchmark.c b/src/filter/bench/firhilb_benchmark.c
index b427a698..57d14033 100644
--- a/src/filter/bench/firhilb_benchmark.c
+++ b/src/filter/bench/firhilb_benchmark.c
@@ -38,7 +38,7 @@ void firhilbf_decim_bench(
     firhilbf q = firhilbf_create(_m,60.0f);
 
     float x[] = {1.0f, -1.0f};
-    float complex y;
+    _Fcomplex y;
     unsigned long int i;
 
     // start trials
@@ -65,4 +65,3 @@ void benchmark_firhilbf_decim_m3    FIRHILB_DECIM_BENCHMARK_API(3)  // m=3
 void benchmark_firhilbf_decim_m5    FIRHILB_DECIM_BENCHMARK_API(5)  // m=5
 void benchmark_firhilbf_decim_m9    FIRHILB_DECIM_BENCHMARK_API(9)  // m=9
 void benchmark_firhilbf_decim_m13   FIRHILB_DECIM_BENCHMARK_API(13) // m=13
-
diff --git a/src/filter/bench/firinterp_crcf_benchmark.c b/src/filter/bench/firinterp_crcf_benchmark.c
index 049ecec0..8b805281 100644
--- a/src/filter/bench/firinterp_crcf_benchmark.c
+++ b/src/filter/bench/firinterp_crcf_benchmark.c
@@ -42,7 +42,7 @@ void firinterp_crcf_bench(struct rusage *_start,
 
     firinterp_crcf q = firinterp_crcf_create(_M,h,_h_len);
 
-    float complex y[_M];
+    _Fcomplex y[_M];
     // start trials
     getrusage(RUSAGE_SELF, _start);
     for (i=0; i<(*_num_iterations); i++) {
@@ -68,4 +68,3 @@ void benchmark_firinterp_crcf_m4_h16   FIRINTERP_CRCF_BENCHMARK_API(4, 16)
 void benchmark_firinterp_crcf_m8_h32   FIRINTERP_CRCF_BENCHMARK_API(8, 32)
 void benchmark_firinterp_crcf_m16_h64  FIRINTERP_CRCF_BENCHMARK_API(16,64)
 void benchmark_firinterp_crcf_m32_h128 FIRINTERP_CRCF_BENCHMARK_API(32,128)
-
diff --git a/src/filter/bench/iirdecim_crcf_benchmark.c b/src/filter/bench/iirdecim_crcf_benchmark.c
index e8cfbdf6..c9551ef9 100644
--- a/src/filter/bench/iirdecim_crcf_benchmark.c
+++ b/src/filter/bench/iirdecim_crcf_benchmark.c
@@ -45,12 +45,12 @@ void iirdecim_crcf_bench(struct rusage *     _start,
     iirdecim_crcf q = iirdecim_crcf_create_prototype(_M,ftype,btype,format,_order,fc,f0,Ap,As);
 
     // initialize input
-    float complex x[_M];
+    _Fcomplex x[_M];
     unsigned int i;
     for (i=0; i<_M; i++)
         x[i] = (i%2) ? 1.0f : -1.0f;
 
-    float complex y;
+    _Fcomplex y;
 
     // start trials
     getrusage(RUSAGE_SELF, _start);
@@ -77,4 +77,3 @@ void benchmark_iirdecim_crcf_M4     IIRDECIM_CRCF_BENCHMARK_API(4, 5)
 void benchmark_iirdecim_crcf_M8     IIRDECIM_CRCF_BENCHMARK_API(8, 5)
 void benchmark_iirdecim_crcf_M16    IIRDECIM_CRCF_BENCHMARK_API(16,5)
 void benchmark_iirdecim_cccf_M32    IIRDECIM_CRCF_BENCHMARK_API(32,5)
-
diff --git a/src/filter/bench/iirfilt_crcf_benchmark.c b/src/filter/bench/iirfilt_crcf_benchmark.c
index 80b54f3b..b9857288 100644
--- a/src/filter/bench/iirfilt_crcf_benchmark.c
+++ b/src/filter/bench/iirfilt_crcf_benchmark.c
@@ -55,8 +55,8 @@ void iirfilt_crcf_bench(struct rusage *     _start,
                                                    fc, f0, Ap, As);
 
     // initialize input/output
-    float complex x[4];
-    float complex y[4];
+    _Fcomplex x[4];
+    _Fcomplex y[4];
     for (i=0; i<4; i++)
         x[i] = randnf() + _Complex_I*randnf();
 
@@ -106,7 +106,7 @@ void benchmark_irfilt_crcf_dcblock(struct rusage *     _start,
     iirfilt_crcf q = iirfilt_crcf_create_dc_blocker(0.1f);
 
     // initialize input/output
-    float complex x[4];
+    _Fcomplex x[4];
     for (i=0; i<4; i++)
         x[i] = randnf() + _Complex_I*randnf();
 
@@ -124,4 +124,3 @@ void benchmark_irfilt_crcf_dcblock(struct rusage *     _start,
     // destroy filter object
     iirfilt_crcf_destroy(q);
 }
-
diff --git a/src/filter/bench/iirinterp_crcf_benchmark.c b/src/filter/bench/iirinterp_crcf_benchmark.c
index c9016da4..1de98041 100644
--- a/src/filter/bench/iirinterp_crcf_benchmark.c
+++ b/src/filter/bench/iirinterp_crcf_benchmark.c
@@ -45,7 +45,7 @@ void iirinterp_crcf_bench(struct rusage *_start,
     float As = 60.0f;
     iirinterp_crcf q = iirinterp_crcf_create_prototype(_M,ftype,btype,format,_order,fc,f0,Ap,As);
 
-    float complex y[_M];
+    _Fcomplex y[_M];
     // start trials
     getrusage(RUSAGE_SELF, _start);
     unsigned int i;
@@ -72,4 +72,3 @@ void benchmark_iirinterp_crcf_M4    IIRINTERP_CRCF_BENCHMARK_API(4, 5)
 void benchmark_iirinterp_crcf_M8    IIRINTERP_CRCF_BENCHMARK_API(8, 5)
 void benchmark_iirinterp_crcf_M16   IIRINTERP_CRCF_BENCHMARK_API(16,5)
 void benchmark_iirinterp_crcf_M32   IIRINTERP_CRCF_BENCHMARK_API(32,5)
-
diff --git a/src/filter/bench/resamp2_crcf_benchmark.c b/src/filter/bench/resamp2_crcf_benchmark.c
index c4bf4d3f..45203614 100644
--- a/src/filter/bench/resamp2_crcf_benchmark.c
+++ b/src/filter/bench/resamp2_crcf_benchmark.c
@@ -45,8 +45,8 @@ void resamp2_crcf_bench(struct rusage *_start,
 
     resamp2_crcf q = resamp2_crcf_create(_m,0.0f,60.0f);
 
-    float complex x[] = {1.0f, -1.0f};
-    float complex y[] = {1.0f, -1.0f};
+    _Fcomplex x[] = {1.0f, -1.0f};
+    _Fcomplex y[] = {1.0f, -1.0f};
 
     // start trials
     getrusage(RUSAGE_SELF, _start);
@@ -93,7 +93,7 @@ void benchmark_resamp2_crcf_decim_m64   RESAMP2_CRCF_BENCHMARK_API( 64,RESAMP2_D
 void benchmark_resamp2_crcf_decim_m128  RESAMP2_CRCF_BENCHMARK_API(128,RESAMP2_DECIM)
 void benchmark_resamp2_crcf_decim_m256  RESAMP2_CRCF_BENCHMARK_API(256,RESAMP2_DECIM)
 
-// 
+//
 // Interpolators
 //
 void benchmark_resamp2_crcf_interp_m2   RESAMP2_CRCF_BENCHMARK_API(  2,RESAMP2_INTERP)
@@ -104,4 +104,3 @@ void benchmark_resamp2_crcf_interp_m32  RESAMP2_CRCF_BENCHMARK_API( 32,RESAMP2_I
 void benchmark_resamp2_crcf_interp_m64  RESAMP2_CRCF_BENCHMARK_API( 64,RESAMP2_INTERP)
 void benchmark_resamp2_crcf_interp_m128 RESAMP2_CRCF_BENCHMARK_API(128,RESAMP2_INTERP)
 void benchmark_resamp2_crcf_interp_m256 RESAMP2_CRCF_BENCHMARK_API(256,RESAMP2_INTERP)
-
diff --git a/src/filter/bench/resamp_crcf_benchmark.c b/src/filter/bench/resamp_crcf_benchmark.c
index 88aeccdd..e9287bc3 100644
--- a/src/filter/bench/resamp_crcf_benchmark.c
+++ b/src/filter/bench/resamp_crcf_benchmark.c
@@ -43,10 +43,10 @@ void resamp_crcf_bench(struct rusage *     _start,
     resamp_crcf q = resamp_crcf_create(rate,m,bw,As,npfb);
 
     // buffering
-    float complex buf_0[_P];
-    float complex buf_1[_Q*4];
+    _Fcomplex buf_0[_P];
+    _Fcomplex buf_1[_Q*4];
     unsigned int num_written;
-    
+
     unsigned long int i;
     for (i=0; i<_P; i++)
         buf_0[i] = i % 7 ? 1 : -1;
@@ -84,4 +84,3 @@ void benchmark_resamp_crcf_P17_Q32  RESAMP_CRCF_BENCHMARK_API(17,  32)
 void benchmark_resamp_crcf_P17_Q64  RESAMP_CRCF_BENCHMARK_API(17,  64)
 void benchmark_resamp_crcf_P17_Q128 RESAMP_CRCF_BENCHMARK_API(17, 128)
 void benchmark_resamp_crcf_P17_Q256 RESAMP_CRCF_BENCHMARK_API(17, 256)
-
diff --git a/src/filter/bench/rresamp_crcf_benchmark.c b/src/filter/bench/rresamp_crcf_benchmark.c
index ed15f284..308d1063 100644
--- a/src/filter/bench/rresamp_crcf_benchmark.c
+++ b/src/filter/bench/rresamp_crcf_benchmark.c
@@ -42,7 +42,7 @@ void rresamp_crcf_bench(struct rusage *     _start,
 
     // input/output buffers
     unsigned int buf_len = _P > _Q ? _P : _Q; // max(_P,_Q)
-    float complex * buf = (float complex*) malloc(buf_len*sizeof(float complex));
+    _Fcomplex * buf = (_Fcomplex*) malloc(buf_len*sizeof(_Fcomplex));
 
     // initialize buffer
     unsigned long int i;
@@ -83,4 +83,3 @@ void benchmark_rresamp_crcf_P17_Q32  RRESAMP_CRCF_BENCHMARK_API(17,  32)
 void benchmark_rresamp_crcf_P17_Q64  RRESAMP_CRCF_BENCHMARK_API(17,  64)
 void benchmark_rresamp_crcf_P17_Q128 RRESAMP_CRCF_BENCHMARK_API(17, 128)
 void benchmark_rresamp_crcf_P17_Q256 RRESAMP_CRCF_BENCHMARK_API(17, 256)
-
diff --git a/src/filter/bench/symsync_crcf_benchmark.c b/src/filter/bench/symsync_crcf_benchmark.c
index 37c517f2..6ccd1859 100644
--- a/src/filter/bench/symsync_crcf_benchmark.c
+++ b/src/filter/bench/symsync_crcf_benchmark.c
@@ -45,8 +45,8 @@ void symsync_crcf_bench(struct rusage *     _start,
     *_num_iterations /= num_samples;
 
     unsigned int num_written;
-    float complex x[num_samples];
-    float complex y[num_samples];
+    _Fcomplex x[num_samples];
+    _Fcomplex y[num_samples];
 
     // generate pseudo-random data
     msequence ms = msequence_create_default(6);
@@ -74,11 +74,10 @@ void symsync_crcf_bench(struct rusage *     _start,
     unsigned long int *_num_iterations)     \
 { symsync_crcf_bench(_start, _finish, _num_iterations, K, M); }
 
-// 
+//
 // BENCHMARKS
 //
 void benchmark_symsync_crcf_k2_m2   SYMSYNC_CRCF_BENCHMARK_API(2, 2)
 void benchmark_symsync_crcf_k2_m4   SYMSYNC_CRCF_BENCHMARK_API(2, 4)
 void benchmark_symsync_crcf_k2_m8   SYMSYNC_CRCF_BENCHMARK_API(2, 8)
 void benchmark_symsync_crcf_k2_m16  SYMSYNC_CRCF_BENCHMARK_API(2, 16)
-
diff --git a/src/filter/dds.readme.txt b/src/filter/dds.readme.txt
index 6d82825c..25d303d9 100644
--- a/src/filter/dds.readme.txt
+++ b/src/filter/dds.readme.txt
@@ -20,15 +20,13 @@ void dds_cccf_reset(dds_cccf _q);
     Reset/clear the internal buffers of the DDS object.
 
 void dds_cccf_decim_execute(dds_cccf _q,
-                            float complex * _x,
-                            float complex * _y);
+                            _Fcomplex * _x,
+                            _Fcomplex * _y);
     Run decimation on an input array of 2^_num_stages inputs,
     and store in a single output
 
 void dds_cccf_interp_execute(dds_cccf _q,
-                             float complex _x,
-                             float complex * _y);
+                             _Fcomplex _x,
+                             _Fcomplex * _y);
     Run interpolation on a single input and store result into
     an array of 2^_num_stages outputs.
-
-
diff --git a/src/filter/src/bessel.c b/src/filter/src/bessel.c
index 176f4b28..820c918d 100644
--- a/src/filter/src/bessel.c
+++ b/src/filter/src/bessel.c
@@ -43,9 +43,9 @@
 
 void fpoly_bessel(unsigned int _n, float * _p);
 
-void fpoly_bessel_roots(unsigned int _n, float complex * _roots);
+void fpoly_bessel_roots(unsigned int _n, _Fcomplex * _roots);
 
-void fpoly_bessel_roots_orchard(unsigned int _n, float complex * _roots);
+void fpoly_bessel_roots_orchard(unsigned int _n, _Fcomplex * _roots);
 
 void fpoly_bessel_roots_orchard_recursion(unsigned int _n,
                                           float _x,
@@ -65,9 +65,9 @@ void fpoly_bessel_roots_orchard_recursion(unsigned int _n,
 //  _p      :   output analog poles [length: _n]
 //  _k      :   output analog gain
 void bessel_azpkf(unsigned int _n,
-                  float complex * _za,
-                  float complex * _pa,
-                  float complex * _ka)
+                  _Fcomplex * _za,
+                  _Fcomplex * _pa,
+                  _Fcomplex * _ka)
 {
     // compute poles (roots to Bessel polynomial)
     fpoly_bessel_roots(_n+1,_pa);
@@ -122,7 +122,7 @@ void fpoly_bessel(unsigned int _n, float * _p)
 }
 
 void fpoly_bessel_roots(unsigned int _n,
-                        float complex * _roots)
+                        _Fcomplex * _roots)
 {
     fpoly_bessel_roots_orchard(_n, _roots);
 }
@@ -133,12 +133,12 @@ void fpoly_bessel_roots(unsigned int _n,
 // The resulting root is near enough the true root such that
 // Orchard's recursion will find it.
 void fpoly_bessel_roots_orchard(unsigned int _n,
-                                float complex * _roots)
+                                _Fcomplex * _roots)
 {
     // initialize arrays
-    float complex r0[_n];       // roots of L_{k-2}
-    float complex r1[_n];       // roots of L_{k-1}
-    float complex r_hat[_n];    // roots of L_{k}
+    _Fcomplex r0[_n];       // roots of L_{k-2}
+    _Fcomplex r1[_n];       // roots of L_{k-1}
+    _Fcomplex r_hat[_n];    // roots of L_{k}
 
     unsigned int i, j;
     unsigned int p, L;
@@ -180,8 +180,8 @@ void fpoly_bessel_roots_orchard(unsigned int _n,
 
         // copy roots:  roots(L_{k+1}) -> roots(L_{k+2))
         //              roots(L_{k})   -> roots(L_{k+1))
-        memmove(r0, r1,    (L-p)*sizeof(float complex));
-        memmove(r1, r_hat,     L*sizeof(float complex));
+        memmove(r0, r1,    (L-p)*sizeof(_Fcomplex));
+        memmove(r1, r_hat,     L*sizeof(_Fcomplex));
     }
 
     // copy results to output
@@ -260,4 +260,3 @@ void fpoly_bessel_roots_orchard_recursion(unsigned int _n,
     *_x_hat = x;
     *_y_hat = y;
 }
-
diff --git a/src/filter/src/bilinear.c b/src/filter/src/bilinear.c
index dbdc7dba..abbac94c 100644
--- a/src/filter/src/bilinear.c
+++ b/src/filter/src/bilinear.c
@@ -20,7 +20,7 @@
  * THE SOFTWARE.
  */
 
-// 
+//
 // binlinear z-transforms
 //
 
@@ -49,26 +49,26 @@
 // outputs
 //  _b      :   digital numerator (length _nz+1)
 //  _a      :   digital denominator (length _np+1)
-void bilinear_zpk(float complex * _z,
+void bilinear_zpk(_Fcomplex * _z,
                   unsigned int _nz,
-                  float complex * _p,
+                  _Fcomplex * _p,
                   unsigned int _np,
-                  float complex _k,
+                  _Fcomplex _k,
                   float _m,
-                  float complex * _b,
-                  float complex * _a)
+                  _Fcomplex * _b,
+                  _Fcomplex * _a)
 {
     unsigned int i;
 
     // expand numerator
     unsigned int nb = _nz+1;
-    float complex pb[nb];
+    _Fcomplex pb[nb];
     cfpoly_expandroots(_z,_nz,pb);
     if (_nz == 0) pb[0] = 1.;
 
     // expand denominator
     unsigned int na = _np+1;
-    float complex pa[na];
+    _Fcomplex pa[na];
     cfpoly_expandroots(_p,_np,pa);
     if (_np == 0) pa[0] = 1.;
 
@@ -116,13 +116,13 @@ void bilinear_zpk(float complex * _z,
 // outputs
 //  _bd         :   digital filter numerator (length _b_order+1)
 //  _ad         :   digital filter numerator (length _a_order+1)
-void bilinear_nd(float complex * _b,
+void bilinear_nd(_Fcomplex * _b,
                  unsigned int _b_order,
-                 float complex * _a,
+                 _Fcomplex * _a,
                  unsigned int _a_order,
                  float _m,
-                 float complex * _bd,
-                 float complex * _ad)
+                 _Fcomplex * _bd,
+                 _Fcomplex * _ad)
 {
     if (_b_order > _a_order) {
         fprintf(stderr,"error: bilinear_nd(), numerator order cannot be higher than denominator\n");
@@ -189,10 +189,9 @@ void bilinear_nd(float complex * _b,
     }
 
     // normalize by a[0]
-    float complex a0_inv = 1.0f / _ad[0];
+    _Fcomplex a0_inv = 1.0f / _ad[0];
     for (i=0; i<na; i++) {
         _bd[i] *= a0_inv;
         _ad[i] *= a0_inv;
     }
 }
-
diff --git a/src/filter/src/ellip.c b/src/filter/src/ellip.c
index 28a81fa1..b1032e93 100644
--- a/src/filter/src/ellip.c
+++ b/src/filter/src/ellip.c
@@ -77,7 +77,7 @@ void ellipkf(float _k,
     // define range for k due to machine precision
     float kmin = 4e-4f;
     float kmax = sqrtf(1-kmin*kmin);
-    
+
     float K;
     float Kp;
 
@@ -171,11 +171,11 @@ float ellipdegf(float _N,
 //  _u      :   vector in the complex u-plane
 //  _k      :   elliptic modulus (0 <= _k < 1)
 //  _n      :   number of Landen iterations (typically 5-6)
-float complex ellip_cdf(float complex _u,
+_Fcomplex ellip_cdf(_Fcomplex _u,
                         float _k,
                         unsigned int _n)
 {
-    float complex wn = ccosf(_u*M_PI*0.5f);
+    _Fcomplex wn = ccosf(_u*M_PI*0.5f);
     float v[_n];
     landenf(_k,_n,v);
     unsigned int i;
@@ -192,11 +192,11 @@ float complex ellip_cdf(float complex _u,
 //  _u      :   vector in the complex u-plane
 //  _k      :   elliptic modulus (0 <= _k < 1)
 //  _n      :   number of Landen iterations (typically 5-6)
-float complex ellip_snf(float complex _u,
+_Fcomplex ellip_snf(_Fcomplex _u,
                         float _k,
                         unsigned int _n)
 {
-    float complex wn = csinf(_u*M_PI*0.5f);
+    _Fcomplex wn = csinf(_u*M_PI*0.5f);
     float v[_n];
     landenf(_k,_n,v);
     unsigned int i;
@@ -214,7 +214,7 @@ float complex ellip_snf(float complex _u,
 //  _w      :   vector in the complex u-plane
 //  _k      :   elliptic modulus (0 <= _k < 1)
 //  _n      :   number of Landen iterations (typically 5-6)
-float complex ellip_acdf(float complex _w,
+_Fcomplex ellip_acdf(_Fcomplex _w,
                          float _k,
                          unsigned int _n)
 {
@@ -222,7 +222,7 @@ float complex ellip_acdf(float complex _w,
     landenf(_k,_n,v);
     float v1;
 
-    float complex w = _w;
+    _Fcomplex w = _w;
     unsigned int i;
     for (i=0; i<_n; i++) {
         v1 = (i==0) ? _k : v[i-1];
@@ -230,7 +230,7 @@ float complex ellip_acdf(float complex _w,
         //printf("  w[%3u] = %12.8f + j*%12.8f\n", i, crealf(w), cimagf(w));
     }
 
-    float complex u = liquid_cacosf(w) * 2.0 / M_PI;
+    _Fcomplex u = liquid_cacosf(w) * 2.0 / M_PI;
     //printf("  u = %12.8f + j*%12.8f\n", crealf(u), cimagf(u));
 
 #if 0
@@ -249,7 +249,7 @@ float complex ellip_acdf(float complex _w,
 //  _w      :   vector in the complex u-plane
 //  _k      :   elliptic modulus (0 <= _k < 1)
 //  _n      :   number of Landen iterations (typically 5-6)
-float complex ellip_asnf(float complex _w,
+_Fcomplex ellip_asnf(_Fcomplex _w,
                          float _k,
                          unsigned int _n)
 {
@@ -271,9 +271,9 @@ float complex ellip_asnf(float complex _w,
 void ellip_azpkf(unsigned int _n,
                  float _ep,
                  float _es,
-                 float complex * _za,
-                 float complex * _pa,
-                 float complex * _ka)
+                 _Fcomplex * _za,
+                 _Fcomplex * _pa,
+                 _Fcomplex * _ka)
 {
     // filter specifications
     float fp = 1.0f / (2.0f * M_PI);    // pass-band cutoff
@@ -339,7 +339,7 @@ void ellip_azpkf(unsigned int _n,
         printf("u[%3u]      : %12.8f\n", i, u[i]);
 #endif
     }
-    float complex zeta[L];
+    _Fcomplex zeta[L];
     for (i=0; i<L; i++) {
         zeta[i] = ellip_cdf(u[i],k,n);
 #if LIQUID_DEBUG_ELLIP_PRINT
@@ -348,7 +348,7 @@ void ellip_azpkf(unsigned int _n,
     }
 
     // compute filter zeros
-    float complex za[L];
+    _Fcomplex za[L];
     for (i=0; i<L; i++) {
         za[i] = _Complex_I * Wp / (k*zeta[i]);
 #if LIQUID_DEBUG_ELLIP_PRINT
@@ -356,19 +356,19 @@ void ellip_azpkf(unsigned int _n,
 #endif
     }
 
-    float complex v0 = -_Complex_I*ellip_asnf(_Complex_I/ep, k1, n)/N;
+    _Fcomplex v0 = -_Complex_I*ellip_asnf(_Complex_I/ep, k1, n)/N;
 #if LIQUID_DEBUG_ELLIP_PRINT
     printf("v0          : %12.8f + j*%12.8f\n", crealf(v0), cimagf(v0));
 #endif
 
-    float complex pa[L];
+    _Fcomplex pa[L];
     for (i=0; i<L; i++) {
         pa[i] = Wp*_Complex_I*ellip_cdf(u[i]-_Complex_I*v0, k, n);
 #if LIQUID_DEBUG_ELLIP_PRINT
         printf("pa[%3u]     : %12.8f + j*%12.8f\n", i, crealf(pa[i]), cimagf(pa[i]));
 #endif
     }
-    float complex pa0 = Wp * _Complex_I*ellip_snf(_Complex_I*v0, k, n);
+    _Fcomplex pa0 = Wp * _Complex_I*ellip_snf(_Complex_I*v0, k, n);
 #if LIQUID_DEBUG_ELLIP_PRINT
     printf("pa0         : %12.8f + j*%12.8f\n", crealf(pa0), cimagf(pa0));
 #endif
@@ -396,5 +396,3 @@ void ellip_azpkf(unsigned int _n,
     for (i=0; i<2*L; i++)
         *_ka /= _za[i];
 }
-
-
diff --git a/src/filter/src/fftfilt.c b/src/filter/src/fftfilt.c
index 53ceeb0f..f8342323 100644
--- a/src/filter/src/fftfilt.c
+++ b/src/filter/src/fftfilt.c
@@ -45,10 +45,10 @@ struct FFTFILT(_s) {
     // internal memory arrays
     // TODO: make TI/TO type, but ensuring complex
     // TODO: use special format for fftfilt_rrrf type
-    float complex * time_buf;   // time buffer [size: 2*n x 1]
-    float complex * freq_buf;   // freq buffer [size: 2*n x 1]
-    float complex * H;          // FFT of filter coefficients [size: 2*n x 1]
-    float complex * w;          // overlap array [size: n x 1]
+    _Fcomplex * time_buf;   // time buffer [size: 2*n x 1]
+    _Fcomplex * freq_buf;   // freq buffer [size: 2*n x 1]
+    _Fcomplex * H;          // FFT of filter coefficients [size: 2*n x 1]
+    _Fcomplex * w;          // overlap array [size: n x 1]
 
     // FFT objects
 #ifdef LIQUID_FFTOVERRIDE
@@ -92,10 +92,10 @@ FFTFILT() FFTFILT(_create)(TC *         _h,
     memmove(q->h, _h, _h_len*sizeof(TC));
 
     // allocate internal memory arrays
-    q->time_buf = (float complex *) malloc((2*q->n)* sizeof(float complex)); // time buffer
-    q->freq_buf = (float complex *) malloc((2*q->n)* sizeof(float complex)); // frequency buffer
-    q->H        = (float complex *) malloc((2*q->n)* sizeof(float complex)); // FFT{ h }
-    q->w        = (float complex *) malloc((  q->n)* sizeof(float complex)); // delay buffer
+    q->time_buf = (_Fcomplex *) malloc((2*q->n)* sizeof(_Fcomplex)); // time buffer
+    q->freq_buf = (_Fcomplex *) malloc((2*q->n)* sizeof(_Fcomplex)); // frequency buffer
+    q->H        = (_Fcomplex *) malloc((2*q->n)* sizeof(_Fcomplex)); // FFT{ h }
+    q->w        = (_Fcomplex *) malloc((  q->n)* sizeof(_Fcomplex)); // delay buffer
 
     // create internal FFT objects
 #ifdef LIQUID_FFTOVERRIDE
@@ -116,7 +116,7 @@ FFTFILT() FFTFILT(_create)(TC *         _h,
 #else
     FFT_EXECUTE(q->fft);
 #endif
-    memmove(q->H, q->freq_buf, 2*q->n*sizeof(float complex));
+    memmove(q->H, q->freq_buf, 2*q->n*sizeof(_Fcomplex));
 
     // set default scaling
     FFTFILT(_set_scale)(q, 1);
@@ -264,7 +264,7 @@ void FFTFILT(_execute)(FFTFILT() _q,
 #endif
 
     // copy buffer
-    memmove(_q->w, &_q->time_buf[_q->n], _q->n*sizeof(float complex));
+    memmove(_q->w, &_q->time_buf[_q->n], _q->n*sizeof(_Fcomplex));
 }
 
 // return length of filter object's internal coefficients
@@ -272,4 +272,3 @@ unsigned int FFTFILT(_get_length)(FFTFILT() _q)
 {
     return _q->h_len;
 }
-
diff --git a/src/filter/src/filter_cccf.c b/src/filter/src/filter_cccf.c
index ba9a519d..5d32e097 100644
--- a/src/filter/src/filter_cccf.c
+++ b/src/filter/src/filter_cccf.c
@@ -30,7 +30,7 @@
 #define EXTENSION_SHORT     "f"
 #define EXTENSION_FULL      "cccf"
 
-// 
+//
 #define AUTOCORR(name)      LIQUID_CONCAT(autocorr_cccf,name)
 #define FFTFILT(name)       LIQUID_CONCAT(fftfilt_cccf,name)
 #define FIRDECIM(name)      LIQUID_CONCAT(firdecim_cccf,name)
@@ -50,10 +50,10 @@
 #define RESAMP2(name)       LIQUID_CONCAT(resamp2_cccf,name)
 //#define SYMSYNC(name)       LIQUID_CONCAT(symsync_cccf,name)
 
-#define T                   float complex   // general
-#define TO                  float complex   // output
-#define TC                  float complex   // coefficients
-#define TI                  float complex   // input
+#define T                   _Fcomplex   // general
+#define TO                  _Fcomplex   // output
+#define TC                  _Fcomplex   // coefficients
+#define TI                  _Fcomplex   // input
 #define WINDOW(name)        LIQUID_CONCAT(windowcf,name)
 #define DOTPROD(name)       LIQUID_CONCAT(dotprod_cccf,name)
 #define POLY(name)          LIQUID_CONCAT(polyf,name)
diff --git a/src/filter/src/filter_crcf.c b/src/filter/src/filter_crcf.c
index c87ba86a..57b436e5 100644
--- a/src/filter/src/filter_crcf.c
+++ b/src/filter/src/filter_crcf.c
@@ -30,7 +30,7 @@
 #define EXTENSION_SHORT     "f"
 #define EXTENSION_FULL      "crcf"
 
-// 
+//
 #define AUTOCORR(name)      LIQUID_CONCAT(autocorr_crcf,name)
 #define FFTFILT(name)       LIQUID_CONCAT(fftfilt_crcf,name)
 #define FIRDECIM(name)      LIQUID_CONCAT(firdecim_crcf,name)
@@ -50,10 +50,10 @@
 #define RESAMP2(name)       LIQUID_CONCAT(resamp2_crcf,name)
 #define SYMSYNC(name)       LIQUID_CONCAT(symsync_crcf,name)
 
-#define T                   float complex   // general
-#define TO                  float complex   // output
+#define T                   _Fcomplex   // general
+#define TO                  _Fcomplex   // output
 #define TC                  float           // coefficients
-#define TI                  float complex   // input
+#define TI                  _Fcomplex   // input
 #define WINDOW(name)        LIQUID_CONCAT(windowcf,name)
 #define DOTPROD(name)       LIQUID_CONCAT(dotprod_crcf,name)
 #define POLY(name)          LIQUID_CONCAT(polyf,name)
diff --git a/src/filter/src/firdecim.c b/src/filter/src/firdecim.c
index 6788885e..9d77e78d 100644
--- a/src/filter/src/firdecim.c
+++ b/src/filter/src/firdecim.c
@@ -111,12 +111,12 @@ FIRDECIM() FIRDECIM(_create_kaiser)(unsigned int _M,
     float fc = 0.5f / (float) (_M);
     liquid_firdes_kaiser(h_len, fc, _As, 0.0f, hf);
 
-    // copy coefficients to type-specific array (e.g. float complex)
+    // copy coefficients to type-specific array (e.g. _Fcomplex)
     TC hc[h_len];
     unsigned int i;
     for (i=0; i<h_len; i++)
         hc[i] = hf[i];
-    
+
     // return decimator object
     return FIRDECIM(_create)(_M, hc, 2*_M*_m);
 }
@@ -153,7 +153,7 @@ FIRDECIM() FIRDECIM(_create_prototype)(int          _type,
     float h[h_len];
     liquid_firdes_prototype(_type,_M,_m,_beta,_dt,h);
 
-    // copy coefficients to type-specific array (e.g. float complex)
+    // copy coefficients to type-specific array (e.g. _Fcomplex)
     unsigned int i;
     TC hc[h_len];
     for (i=0; i<h_len; i++)
@@ -250,4 +250,3 @@ void FIRDECIM(_execute_block)(FIRDECIM()   _q,
         FIRDECIM(_execute)(_q, &_x[i*_q->M], &_y[i]);
     }
 }
-
diff --git a/src/filter/src/firdes.c b/src/filter/src/firdes.c
index af6c5506..f7ce1627 100644
--- a/src/filter/src/firdes.c
+++ b/src/filter/src/firdes.c
@@ -70,7 +70,7 @@ unsigned int estimate_req_filter_len(float _df,
 #else
 #   error "invalid required filter length estimation method"
 #endif
-    
+
     return h_len;
 }
 
@@ -214,7 +214,7 @@ float estimate_req_filter_len_Herrmann(float _df,
 
     // compute filter length estimate
     float h_len = (Dinf - f*_df*_df) / _df + 1.0f;
-    
+
     return h_len;
 }
 
@@ -262,11 +262,11 @@ void liquid_firdes_kaiser(unsigned int _n,
     // choose kaiser beta parameter (approximate)
     float beta = kaiser_beta_As(_As);
 
-    float t, h1, h2; 
+    float t, h1, h2;
     unsigned int i;
     for (i=0; i<_n; i++) {
         t = (float)i - (float)(_n-1)/2 + _mu;
-     
+
         // sinc prototype
         h1 = sincf(2.0f*_fc*t);
 
@@ -362,7 +362,7 @@ void liquid_firdes_prototype(liquid_firfilt_type _type,
                                         LIQUID_FIRDESPM_FLATWEIGHT};
 
     switch (_type) {
-    
+
     // Nyquist filter prototypes
 
     case LIQUID_FIRFILT_KAISER:
@@ -457,7 +457,7 @@ void liquid_firdes_doppler(unsigned int _n,
 }
 
 
-// 
+//
 // filter analysis
 //
 
@@ -573,7 +573,7 @@ void liquid_filter_isi(float *      _h,
         e = fabsf(e);
 
         isi_rms += e*e;
-        
+
         if (i==1 || e > isi_max)
             isi_max = e;
     }
@@ -606,7 +606,7 @@ float liquid_filter_energy(float *      _h,
     }
 
     // allocate memory for complex phasor
-    float complex expjwt[_h_len];
+    _Fcomplex expjwt[_h_len];
 
     // initialize accumulators
     float e_total = 0.0f;       // total energy
@@ -619,13 +619,13 @@ float liquid_filter_energy(float *      _h,
     unsigned int k;
     for (i=0; i<_nfft; i++) {
         float f = 0.5f * (float)i / (float)(_nfft);
-        
+
         // initialize complex phasor
         for (k=0; k<_h_len; k++)
             expjwt[k] = cexpf(_Complex_I*2*M_PI*f*k);
 
         // compute vector dot product
-        float complex v;
+        _Fcomplex v;
         dotprod_crcf_execute(dp, expjwt, &v);
 
         // accumulate output
@@ -647,7 +647,7 @@ int liquid_getopt_str2firfilt(const char * _str)
     // Generic filter designs
     if      (strcmp(_str,"kaiser")   ==0) return LIQUID_FIRFILT_KAISER;
     else if (strcmp(_str,"pm")       ==0) return LIQUID_FIRFILT_PM;
-    
+
     // Nyquist filter designs
     else if (strcmp(_str,"rcos")     ==0) return LIQUID_FIRFILT_RCOS;
     else if (strcmp(_str,"fexp")     ==0) return LIQUID_FIRFILT_FEXP;
@@ -668,6 +668,3 @@ int liquid_getopt_str2firfilt(const char * _str)
     // filter type unknown
     return LIQUID_FIRFILT_UNKNOWN;
 }
-
-
-
diff --git a/src/filter/src/firfarrow.c b/src/filter/src/firfarrow.c
index dddd7da2..165ad95d 100644
--- a/src/filter/src/firfarrow.c
+++ b/src/filter/src/firfarrow.c
@@ -275,10 +275,10 @@ void FIRFARROW(_get_coefficients)(FIRFARROW() _q,
 //  _H      : output frequency response
 void FIRFARROW(_freqresponse)(FIRFARROW() _q,
                               float _fc,
-                              float complex * _H)
+                              _Fcomplex * _H)
 {
     unsigned int i;
-    float complex H = 0.0f;
+    _Fcomplex H = 0.0f;
 
     for (i=0; i<_q->h_len; i++)
         H += _q->h[i] * cexpf(_Complex_I*2*M_PI*_fc*i);
@@ -305,7 +305,7 @@ float FIRFARROW(_groupdelay)(FIRFARROW() _q,
 
 
 
-// 
+//
 // internal
 //
 
@@ -370,4 +370,3 @@ void FIRFARROW(_genpoly)(FIRFARROW() _q)
     _q->gamma = 1.0f / (_q->gamma);   // invert result
 
 }
-
diff --git a/src/filter/src/firfilt.c b/src/filter/src/firfilt.c
index 8883f5d1..31fbe233 100644
--- a/src/filter/src/firfilt.c
+++ b/src/filter/src/firfilt.c
@@ -127,7 +127,7 @@ FIRFILT() FIRFILT(_create_kaiser)(unsigned int _n,
     for (i=0; i<_n; i++)
         h[i] = (TC) hf[i];
 
-    // 
+    //
     return FIRFILT(_create)(h, _n);
 }
 
@@ -160,7 +160,7 @@ FIRFILT() FIRFILT(_create_rnyquist)(int          _type,
     float hf[h_len];
     liquid_firdes_prototype(_type,_k,_m,_beta,_mu,hf);
 
-    // copy coefficients to type-specific array (e.g. float complex)
+    // copy coefficients to type-specific array (e.g. _Fcomplex)
     unsigned int i;
     TC hc[h_len];
     for (i=0; i<h_len; i++)
@@ -467,10 +467,10 @@ unsigned int FIRFILT(_get_length)(FIRFILT() _q)
 //  _H      :   output frequency response
 void FIRFILT(_freqresponse)(FIRFILT()       _q,
                             float           _fc,
-                            float complex * _H)
+                            _Fcomplex * _H)
 {
     unsigned int i;
-    float complex H = 0.0f;
+    _Fcomplex H = 0.0f;
 
     // compute dot product between coefficients and exp{ 2 pi fc {0..n-1} }
     for (i=0; i<_q->h_len; i++)
@@ -499,4 +499,3 @@ float FIRFILT(_groupdelay)(FIRFILT() _q,
 
     return fir_group_delay(h, n, _fc);
 }
-
diff --git a/src/filter/src/firinterp.c b/src/filter/src/firinterp.c
index e89a90b5..92ce8e68 100644
--- a/src/filter/src/firinterp.c
+++ b/src/filter/src/firinterp.c
@@ -105,12 +105,12 @@ FIRINTERP() FIRINTERP(_create_kaiser)(unsigned int _M,
     float fc = 0.5f / (float) (_M);
     liquid_firdes_kaiser(h_len, fc, _As, 0.0f, hf);
 
-    // copy coefficients to type-specific array (e.g. float complex)
+    // copy coefficients to type-specific array (e.g. _Fcomplex)
     TC hc[h_len];
     unsigned int i;
     for (i=0; i<h_len; i++)
         hc[i] = hf[i];
-    
+
     // return interpolator object
     return FIRINTERP(_create)(_M, hc, 2*_M*_m);
 }
@@ -147,7 +147,7 @@ FIRINTERP() FIRINTERP(_create_prototype)(int          _type,
     float h[h_len];
     liquid_firdes_prototype(_type,_k,_m,_beta,_dt,h);
 
-    // copy coefficients to type-specific array (e.g. float complex)
+    // copy coefficients to type-specific array (e.g. _Fcomplex)
     unsigned int i;
     TC hc[h_len];
     for (i=0; i<h_len; i++)
@@ -231,4 +231,3 @@ void FIRINTERP(_execute_block)(FIRINTERP()  _q,
         FIRINTERP(_execute)(_q, _x[i], &_y[i*_q->M]);
     }
 }
-
diff --git a/src/filter/src/firpfb.c b/src/filter/src/firpfb.c
index 332fd647..b24a7063 100644
--- a/src/filter/src/firpfb.c
+++ b/src/filter/src/firpfb.c
@@ -127,7 +127,7 @@ FIRPFB() FIRPFB(_create_kaiser)(unsigned int _M,
     float Hf[H_len];
     liquid_firdes_kaiser(H_len, _fc/(float)_M, _As, 0.0f, Hf);
 
-    // copy coefficients to type-specific array (e.g. float complex)
+    // copy coefficients to type-specific array (e.g. _Fcomplex)
     unsigned int i;
     TC Hc[H_len];
     for (i=0; i<H_len; i++)
@@ -169,7 +169,7 @@ FIRPFB() FIRPFB(_create_rnyquist)(int          _type,
     float Hf[H_len];
     liquid_firdes_prototype(_type,_M*_k,_m,_beta,0,Hf);
 
-    // copy coefficients to type-specific array (e.g. float complex)
+    // copy coefficients to type-specific array (e.g. _Fcomplex)
     unsigned int i;
     TC Hc[H_len];
     for (i=0; i<H_len; i++)
@@ -210,7 +210,7 @@ FIRPFB() FIRPFB(_create_drnyquist)(int          _type,
     unsigned int H_len = 2*_M*_k*_m + 1;
     float Hf[H_len];
     liquid_firdes_prototype(_type,_M*_k,_m,_beta,0,Hf);
-    
+
     // compute derivative filter
     float dHf[H_len];
     float HdH_max = 0.0f;
@@ -229,7 +229,7 @@ FIRPFB() FIRPFB(_create_drnyquist)(int          _type,
             HdH_max = fabsf(Hf[i]*dHf[i]);
     }
 
-    // copy coefficients to type-specific array (e.g. float complex)
+    // copy coefficients to type-specific array (e.g. _Fcomplex)
     // and apply scaling factor for normalized response
     TC Hc[H_len];
     for (i=0; i<H_len; i++)
@@ -373,4 +373,3 @@ void FIRPFB(_execute_block)(FIRPFB()     _q,
         FIRPFB(_execute)(_q, _i, &_y[i]);
     }
 }
-
diff --git a/src/filter/src/fnyquist.c b/src/filter/src/fnyquist.c
index d257257e..9fc055e0 100644
--- a/src/filter/src/fnyquist.c
+++ b/src/filter/src/fnyquist.c
@@ -69,8 +69,8 @@ void liquid_firdes_fnyquist(liquid_firfilt_type _type,
     unsigned int h_len = 2*_k*_m+1;   // filter length
 
     float H_prime[h_len];   // frequency response of Nyquist filter (real)
-    float complex H[h_len]; // frequency response of Nyquist filter
-    float complex h[h_len]; // impulse response of Nyquist filter
+    _Fcomplex H[h_len]; // frequency response of Nyquist filter
+    _Fcomplex h[h_len]; // impulse response of Nyquist filter
 
     // compute Nyquist filter frequency response
     switch (_type) {
@@ -95,7 +95,7 @@ void liquid_firdes_fnyquist(liquid_firfilt_type _type,
 
     // compute ifft
     fft_run(h_len, H, h, LIQUID_FFT_BACKWARD, 0);
-    
+
     // copy shifted, scaled response
     for (i=0; i<h_len; i++)
         _h[i] = crealf( h[(i+_k*_m+1)%h_len] ) * (float)_k / (float)(h_len);
@@ -342,4 +342,3 @@ void liquid_firdes_farcsech_freqresponse(unsigned int _k,
         }
     }
 }
-
diff --git a/src/filter/src/gmsk.c b/src/filter/src/gmsk.c
index 697563f7..1620e496 100644
--- a/src/filter/src/gmsk.c
+++ b/src/filter/src/gmsk.c
@@ -133,15 +133,15 @@ void liquid_firdes_gmskrx(unsigned int _k,
     float h_primef[h_len];          // temporary buffer for real 'prototype' coefficients
     float g_primef[h_len];          // temporary buffer for real 'gain' coefficient
 
-    float complex h_tx[h_len];      // impulse response of transmit filter
-    float complex h_prime[h_len];   // impulse response of 'prototype' filter
-    float complex g_prime[h_len];   // impulse response of 'gain' filter
-    float complex h_hat[h_len];     // impulse response of receive filter
-    
-    float complex H_tx[h_len];      // frequency response of transmit filter
-    float complex H_prime[h_len];   // frequency response of 'prototype' filter
-    float complex G_prime[h_len];   // frequency response of 'gain' filter
-    float complex H_hat[h_len];     // frequency response of receive filter
+    _Fcomplex h_tx[h_len];      // impulse response of transmit filter
+    _Fcomplex h_prime[h_len];   // impulse response of 'prototype' filter
+    _Fcomplex g_prime[h_len];   // impulse response of 'gain' filter
+    _Fcomplex h_hat[h_len];     // impulse response of receive filter
+
+    _Fcomplex H_tx[h_len];      // frequency response of transmit filter
+    _Fcomplex H_prime[h_len];   // frequency response of 'prototype' filter
+    _Fcomplex G_prime[h_len];   // frequency response of 'gain' filter
+    _Fcomplex H_hat[h_len];     // frequency response of receive filter
 
     // create 'prototype' matched filter
     liquid_firdes_prototype(prototype,k,m,beta,0.0f,h_primef);
@@ -191,4 +191,3 @@ void liquid_firdes_gmskrx(unsigned int _k,
     for (i=0; i<h_len; i++)
         _h[i] = hr[i]*_k*_k;
 }
-
diff --git a/src/filter/src/group_delay.c b/src/filter/src/group_delay.c
index f5a485b0..5de2ee61 100644
--- a/src/filter/src/group_delay.c
+++ b/src/filter/src/group_delay.c
@@ -45,8 +45,8 @@ float fir_group_delay(float * _h,
     }
 
     unsigned int i;
-    float complex t0=0.0f;
-    float complex t1=0.0f;
+    _Fcomplex t0=0.0f;
+    _Fcomplex t1=0.0f;
     for (i=0; i<_n; i++) {
         t0 += _h[i] * cexpf(_Complex_I*2*M_PI*_fc*i) * i;
         t1 += _h[i] * cexpf(_Complex_I*2*M_PI*_fc*i);
@@ -94,13 +94,13 @@ float iir_group_delay(float * _b,
         }
     }
 
-    // compute 
+    // compute
     //      sum(c[i] * exp(j 2 pi fc i) * i)
     //      --------------------------------
     //      sum(c[i] * exp(j 2 pi fc i))
-    float complex t0=0.0f;
-    float complex t1=0.0f;
-    float complex c0;
+    _Fcomplex t0=0.0f;
+    _Fcomplex t1=0.0f;
+    _Fcomplex c0;
     for (i=0; i<nc; i++) {
         c0  = c[i] * cexpf(_Complex_I*2*M_PI*_fc*i);
         t0 += c0*i;
@@ -115,4 +115,3 @@ float iir_group_delay(float * _b,
     // return result, scaled by length of denominator
     return crealf(t0/t1) - (_na - 1);
 }
-
diff --git a/src/filter/src/iirdes.c b/src/filter/src/iirdes.c
index 8f1f6c31..68f4d082 100644
--- a/src/filter/src/iirdes.c
+++ b/src/filter/src/iirdes.c
@@ -57,10 +57,10 @@
 //  _n      :   number of elements in _z
 //  _tol    :   tolerance for finding complex pairs
 //  _p      :   resulting pairs, pure real values of _z at end
-void liquid_cplxpair(float complex * _z,
+void liquid_cplxpair(_Fcomplex * _z,
                      unsigned int _n,
                      float _tol,
-                     float complex * _p)
+                     _Fcomplex * _p)
 {
     // validate input
     if (_tol < 0) {
@@ -137,13 +137,13 @@ void liquid_cplxpair(float complex * _z,
 //  _p          :   pre-processed complex array [size: _n x 1]
 //  _n          :   array length
 //  _num_pairs  :   number of complex conjugate pairs
-void liquid_cplxpair_cleanup(float complex * _p,
+void liquid_cplxpair_cleanup(_Fcomplex * _p,
                              unsigned int _n,
                              unsigned int _num_pairs)
 {
     unsigned int i;
     unsigned int j;
-    float complex tmp;
+    _Fcomplex tmp;
 
     // ensure perfect conjugates, with negative imaginary
     // element coming first
@@ -184,7 +184,7 @@ void liquid_cplxpair_cleanup(float complex * _p,
 }
 
 
-// 
+//
 // new IIR design
 //
 
@@ -229,32 +229,32 @@ float iirdes_freqprewarp(liquid_iirdes_bandtype _btype,
 // The filter order is characterized by the number of analog
 // poles.  The analog filter may have up to _npa zeros.
 // The number of digital zeros and poles is equal to _npa.
-void bilinear_zpkf(float complex * _za,
+void bilinear_zpkf(_Fcomplex * _za,
                    unsigned int _nza,
-                   float complex * _pa,
+                   _Fcomplex * _pa,
                    unsigned int _npa,
-                   float complex _ka,
+                   _Fcomplex _ka,
                    float _m,
-                   float complex * _zd,
-                   float complex * _pd,
-                   float complex * _kd)
+                   _Fcomplex * _zd,
+                   _Fcomplex * _pd,
+                   _Fcomplex * _kd)
 {
     unsigned int i;
 
     // filter order is equal to number of analog poles
     unsigned int n = _npa;
-    float complex G = _ka;  // nominal gain
+    _Fcomplex G = _ka;  // nominal gain
     for (i=0; i<n; i++) {
         // compute digital zeros (pad with -1s)
         if (i < _nza) {
-            float complex zm = _za[i] * _m;
+            _Fcomplex zm = _za[i] * _m;
             _zd[i] = (1.0 + zm)/(1.0 - zm);
         } else {
             _zd[i] = -1.0;
         }
 
         // compute digital poles
-        float complex pm = _pa[i] * _m;
+        _Fcomplex pm = _pa[i] * _m;
         _pd[i] = (1.0 + pm)/(1.0 - pm);
 
         // compute digital gain
@@ -282,15 +282,15 @@ void bilinear_zpkf(float complex * _za,
 //  _k      :   digital gain
 //  _b      :   output numerator (length: _n+1)
 //  _a      :   output denominator (length: _n+1)
-void iirdes_dzpk2tff(float complex * _zd,
-                     float complex * _pd,
+void iirdes_dzpk2tff(_Fcomplex * _zd,
+                     _Fcomplex * _pd,
                      unsigned int _n,
-                     float complex _k,
+                     _Fcomplex _k,
                      float * _b,
                      float * _a)
 {
     unsigned int i;
-    float complex q[_n+1];
+    _Fcomplex q[_n+1];
 
     // expand poles
     polycf_expandroots(_pd,_n,q);
@@ -317,10 +317,10 @@ void iirdes_dzpk2tff(float complex * _zd,
 //  L is the number of sections in the cascade:
 //      r = _n % 2
 //      L = (_n - r) / 2;
-void iirdes_dzpk2sosf(float complex * _zd,
-                      float complex * _pd,
+void iirdes_dzpk2sosf(_Fcomplex * _zd,
+                      _Fcomplex * _pd,
                       unsigned int _n,
-                      float complex _kd,
+                      _Fcomplex _kd,
                       float * _B,
                       float * _A)
 {
@@ -328,11 +328,11 @@ void iirdes_dzpk2sosf(float complex * _zd,
     float tol=1e-6f; // tolerance for conjuate pair computation
 
     // find/group complex conjugate pairs (poles)
-    float complex zp[_n];
+    _Fcomplex zp[_n];
     liquid_cplxpair(_zd,_n,tol,zp);
 
     // find/group complex conjugate pairs (zeros)
-    float complex pp[_n];
+    _Fcomplex pp[_n];
     liquid_cplxpair(_pd,_n,tol,pp);
 
     // TODO : group pole pairs with zero pairs
@@ -358,8 +358,8 @@ void iirdes_dzpk2sosf(float complex * _zd,
         printf("  z[%3u] = %12.8f + j*%12.8f\n", i, crealf(zp[i]), cimagf(zp[i]));
 #endif
 
-    float complex z0, z1;
-    float complex p0, p1;
+    _Fcomplex z0, z1;
+    _Fcomplex p0, p1;
     for (i=0; i<L; i++) {
         p0 = -pp[2*i+0];
         p1 = -pp[2*i+1];
@@ -383,7 +383,7 @@ void iirdes_dzpk2sosf(float complex * _zd,
         // keep these two lines for when poles and zeros get grouped
         p0 = -pp[_n-1];
         z0 = -zp[_n-1];
-        
+
         _A[3*i+0] = 1.0;
         _A[3*i+1] = p0;
         _A[3*i+2] = 0.0;
@@ -439,12 +439,12 @@ void iirdes_dzpk_lp2bp(liquid_float_complex * _zd,
                        liquid_float_complex * _zdt,
                        liquid_float_complex * _pdt)
 {
-    // 
+    //
     float c0 = cosf(2*M_PI*_f0);
 
     // transform zeros, poles using quadratic formula
     unsigned int i;
-    float complex t0;
+    _Fcomplex t0;
     for (i=0; i<_n; i++) {
         t0 = 1 + _zd[i];
         _zdt[2*i+0] = 0.5f*(c0*t0 + csqrtf(c0*c0*t0*t0 - 4*_zd[i]));
@@ -501,10 +501,10 @@ void liquid_iirdes(liquid_iirdes_filtertype _ftype,
     unsigned int nza;
 
     // analog poles/zeros/gain
-    float complex pa[_n];
-    float complex za[_n];
-    float complex ka;
-    float complex k0 = 1.0f; // nominal digital gain
+    _Fcomplex pa[_n];
+    _Fcomplex za[_n];
+    _Fcomplex ka;
+    _Fcomplex k0 = 1.0f; // nominal digital gain
 
     // derived values
     unsigned int r = _n%2;      // odd/even filter order
@@ -571,9 +571,9 @@ void liquid_iirdes(liquid_iirdes_filtertype _ftype,
 
     // complex digital poles/zeros/gain
     // NOTE: allocated double the filter order to cover band-pass, band-stop cases
-    float complex zd[2*_n];
-    float complex pd[2*_n];
-    float complex kd;
+    _Fcomplex zd[2*_n];
+    _Fcomplex pd[2*_n];
+    _Fcomplex kd;
     float m = iirdes_freqprewarp(_btype,_fc,_f0);
     //printf("m : %12.8f\n", m);
     bilinear_zpkf(za,    nza,
@@ -607,8 +607,8 @@ void liquid_iirdes(liquid_iirdes_filtertype _ftype,
         _btype == LIQUID_IIRDES_BANDSTOP)
     {
         // allocate memory for transformed zeros, poles
-        float complex zd1[2*_n];
-        float complex pd1[2*_n];
+        _Fcomplex zd1[2*_n];
+        _Fcomplex pd1[2*_n];
 
         // run zeros, poles low-pass -> band-pass trasform
         iirdes_dzpk_lp2bp(zd, pd,   // low-pass prototype zeros, poles
@@ -617,8 +617,8 @@ void liquid_iirdes(liquid_iirdes_filtertype _ftype,
                           zd1,pd1); // transformed zeros, poles (length: 2*n)
 
         // copy transformed zeros, poles
-        memmove(zd, zd1, 2*_n*sizeof(float complex));
-        memmove(pd, pd1, 2*_n*sizeof(float complex));
+        memmove(zd, zd1, 2*_n*sizeof(_Fcomplex));
+        memmove(pd, pd1, 2*_n*sizeof(_Fcomplex));
 
         // update paramters; filter order doubles which changes the
         // number of second-order sections and forces there to never
@@ -683,7 +683,7 @@ int iirdes_isstable(float * _b,
         a_hat[i] = _a[_n-i-1];
 
     // compute poles (roots of denominator)
-    float complex roots[_n-1];
+    _Fcomplex roots[_n-1];
     polyf_findroots_bairstow(a_hat, _n, roots);
 
 #if 0
@@ -701,5 +701,3 @@ int iirdes_isstable(float * _b,
 
     return 1;
 }
-
-
diff --git a/src/filter/src/iirfilt.c b/src/filter/src/iirfilt.c
index b7550ed1..7224c8f1 100644
--- a/src/filter/src/iirfilt.c
+++ b/src/filter/src/iirfilt.c
@@ -66,7 +66,7 @@ struct IIRFILT(_s) {
     DOTPROD() dpa;      // denominator dot product
 #endif
 
-    // second-order sections 
+    // second-order sections
     IIRFILTSOS() * qsos;    // second-order sections filters
     unsigned int nsos;      // number of second-order sections
 };
@@ -145,7 +145,7 @@ IIRFILT() IIRFILT(_create)(TC *         _b,
 
     // reset internal state
     IIRFILT(_reset)(q);
-    
+
     // return iirfilt object
     return q;
 }
@@ -239,7 +239,7 @@ IIRFILT() IIRFILT(_create_prototype)(liquid_iirdes_filtertype _ftype,
     // design filter (compute coefficients)
     liquid_iirdes(_ftype, _btype, _format, _order, _fc, _f0, _Ap, _As, B, A);
 
-    // move coefficients to type-specific arrays (e.g. float complex)
+    // move coefficients to type-specific arrays (e.g. _Fcomplex)
     TC Bc[h_len];
     TC Ac[h_len];
     unsigned int i;
@@ -279,11 +279,11 @@ IIRFILT() IIRFILT(_create_lowpass)(
 // create 8th-order integrating filter
 IIRFILT() IIRFILT(_create_integrator)()
 {
-    // 
+    //
     // integrator digital zeros/poles/gain, [Pintelon:1990] Table II
     //
     // zeros, digital, integrator
-    float complex zdi[8] = {
+    _Fcomplex zdi[8] = {
         1.175839 * -1.0f,
         3.371020 * cexpf(_Complex_I * M_PI / 180.0f * -125.1125f),
         3.371020 * cexpf(_Complex_I * M_PI / 180.0f *  125.1125f),
@@ -293,7 +293,7 @@ IIRFILT() IIRFILT(_create_integrator)()
         5.223966 * cexpf(_Complex_I * M_PI / 180.0f *   40.09347f),
         5.443743,};
     // poles, digital, integrator
-    float complex pdi[8] = {
+    _Fcomplex pdi[8] = {
         0.5805235f * -1.0f,
         0.2332021f * cexpf(_Complex_I * M_PI / 180.0f * -114.0968f),
         0.2332021f * cexpf(_Complex_I * M_PI / 180.0f *  114.0968f),
@@ -303,7 +303,7 @@ IIRFILT() IIRFILT(_create_integrator)()
         0.1641457f * cexpf(_Complex_I * M_PI / 180.0f *   21.89539f),
         1.0f,};
     // gain, digital, integrator
-    float complex kdi = -1.89213380759321e-05f;
+    _Fcomplex kdi = -1.89213380759321e-05f;
 
     // second-order sections
     // allocate 12 values for 4 second-order sections each with
@@ -328,11 +328,11 @@ IIRFILT() IIRFILT(_create_integrator)()
 // create 8th-order differentiation filter
 IIRFILT() IIRFILT(_create_differentiator)()
 {
-    // 
+    //
     // differentiator digital zeros/poles/gain, [Pintelon:1990] Table IV
     //
     // zeros, digital, differentiator
-    float complex zdd[8] = {
+    _Fcomplex zdd[8] = {
         1.702575f * -1.0f,
         5.877385f * cexpf(_Complex_I * M_PI / 180.0f * -221.4063f),
         5.877385f * cexpf(_Complex_I * M_PI / 180.0f *  221.4063f),
@@ -342,7 +342,7 @@ IIRFILT() IIRFILT(_create_differentiator)()
         5.350284f * cexpf(_Complex_I * M_PI / 180.0f *   66.88802f),
         1.0f,};
     // poles, digital, differentiator
-    float complex pdd[8] = {
+    _Fcomplex pdd[8] = {
         0.8476936f * -1.0f,
         0.2990781f * cexpf(_Complex_I * M_PI / 180.0f * -125.5188f),
         0.2990781f * cexpf(_Complex_I * M_PI / 180.0f *  125.5188f),
@@ -352,7 +352,7 @@ IIRFILT() IIRFILT(_create_differentiator)()
         0.1958670f * cexpf(_Complex_I * M_PI / 180.0f *   40.51510f),
         0.1886088f,};
     // gain, digital, differentiator
-    float complex kdd = 2.09049284907492e-05f;
+    _Fcomplex kdd = 2.09049284907492e-05f;
 
     // second-order sections
     // allocate 12 values for 4 second-order sections each with
@@ -608,15 +608,15 @@ unsigned int IIRFILT(_get_length)(IIRFILT() _q)
 //  _H      :   output frequency response
 void IIRFILT(_freqresponse)(IIRFILT()       _q,
                             float           _fc,
-                            float complex * _H)
+                            _Fcomplex * _H)
 {
     unsigned int i;
-    float complex H = 0.0f;
+    _Fcomplex H = 0.0f;
 
     if (_q->type == IIRFILT_TYPE_NORM) {
-        // 
-        float complex Ha = 0.0f;
-        float complex Hb = 0.0f;
+        //
+        _Fcomplex Ha = 0.0f;
+        _Fcomplex Hb = 0.0f;
 
         for (i=0; i<_q->nb; i++)
             Hb += _q->b[i] * cexpf(_Complex_I*2*M_PI*_fc*i);
@@ -632,11 +632,11 @@ void IIRFILT(_freqresponse)(IIRFILT()       _q,
 
         // compute 3-point DFT for each second-order section
         for (i=0; i<_q->nsos; i++) {
-            float complex Hb =  _q->b[3*i+0] * cexpf(_Complex_I*2*M_PI*_fc*0) +
+            _Fcomplex Hb =  _q->b[3*i+0] * cexpf(_Complex_I*2*M_PI*_fc*0) +
                                 _q->b[3*i+1] * cexpf(_Complex_I*2*M_PI*_fc*1) +
                                 _q->b[3*i+2] * cexpf(_Complex_I*2*M_PI*_fc*2);
 
-            float complex Ha =  _q->a[3*i+0] * cexpf(_Complex_I*2*M_PI*_fc*0) +
+            _Fcomplex Ha =  _q->a[3*i+0] * cexpf(_Complex_I*2*M_PI*_fc*0) +
                                 _q->a[3*i+1] * cexpf(_Complex_I*2*M_PI*_fc*1) +
                                 _q->a[3*i+2] * cexpf(_Complex_I*2*M_PI*_fc*2);
 
@@ -675,4 +675,3 @@ float IIRFILT(_groupdelay)(IIRFILT() _q,
 
     return groupdelay;
 }
-
diff --git a/src/filter/tests/data/fftfilt_cccf_data_h13x256.c b/src/filter/tests/data/fftfilt_cccf_data_h13x256.c
index e6d507f1..40bbd75c 100644
--- a/src/filter/tests/data/fftfilt_cccf_data_h13x256.c
+++ b/src/filter/tests/data/fftfilt_cccf_data_h13x256.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fftfilt_cccf_data_h13x256_h[] = {
+_Fcomplex fftfilt_cccf_data_h13x256_h[] = {
     0.101274943352 +  -0.122793912888*_Complex_I,
     0.058305418491 +  -0.133282411098*_Complex_I,
     0.040646758676 +  -0.024372637272*_Complex_I,
@@ -41,7 +41,7 @@ float complex fftfilt_cccf_data_h13x256_h[] = {
     0.155722010136 +  -0.206684422493*_Complex_I,
     0.158807659149 +  -0.032457110286*_Complex_I};
 
-float complex fftfilt_cccf_data_h13x256_x[] = {
+_Fcomplex fftfilt_cccf_data_h13x256_x[] = {
     0.033812573552 +   0.167574334145*_Complex_I,
    -0.180972433090 +   0.003268009797*_Complex_I,
    -0.158811461926 +   0.096975576878*_Complex_I,
@@ -299,7 +299,7 @@ float complex fftfilt_cccf_data_h13x256_x[] = {
     0.085063648224 +   0.024469487369*_Complex_I,
     0.107211554050 +  -0.066898560524*_Complex_I};
 
-float complex fftfilt_cccf_data_h13x256_y[] = {
+_Fcomplex fftfilt_cccf_data_h13x256_y[] = {
     0.024001474660 +   0.012819102986*_Complex_I,
     0.006379486345 +   0.027817151043*_Complex_I,
    -0.008833116513 +   0.059620513709*_Complex_I,
@@ -556,4 +556,3 @@ float complex fftfilt_cccf_data_h13x256_y[] = {
    -0.033553704471 +  -0.075678324986*_Complex_I,
     0.033838944413 +   0.008301990809*_Complex_I,
     0.001278998079 +  -0.054009422018*_Complex_I};
-
diff --git a/src/filter/tests/data/fftfilt_cccf_data_h23x256.c b/src/filter/tests/data/fftfilt_cccf_data_h23x256.c
index 01479dad..e70c1ef8 100644
--- a/src/filter/tests/data/fftfilt_cccf_data_h23x256.c
+++ b/src/filter/tests/data/fftfilt_cccf_data_h23x256.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fftfilt_cccf_data_h23x256_h[] = {
+_Fcomplex fftfilt_cccf_data_h23x256_h[] = {
    -0.113265895844 +  -0.022710527480*_Complex_I,
     0.017113091052 +  -0.012686794996*_Complex_I,
    -0.115593445301 +  -0.088176310062*_Complex_I,
@@ -51,7 +51,7 @@ float complex fftfilt_cccf_data_h23x256_h[] = {
     0.048448944092 +   0.068329632282*_Complex_I,
     0.053360801935 +   0.035232502222*_Complex_I};
 
-float complex fftfilt_cccf_data_h23x256_x[] = {
+_Fcomplex fftfilt_cccf_data_h23x256_x[] = {
     0.045492258668 +   0.087591451406*_Complex_I,
    -0.360275936127 +  -0.244660735130*_Complex_I,
    -0.076566338539 +   0.085396862030*_Complex_I,
@@ -309,7 +309,7 @@ float complex fftfilt_cccf_data_h23x256_x[] = {
    -0.111178684235 +   0.004780802876*_Complex_I,
    -0.256052374840 +  -0.011545106769*_Complex_I};
 
-float complex fftfilt_cccf_data_h23x256_y[] = {
+_Fcomplex fftfilt_cccf_data_h23x256_y[] = {
    -0.003163473368 +  -0.010954277402*_Complex_I,
     0.037140370260 +   0.036815583414*_Complex_I,
     0.003807251283 +  -0.021686181791*_Complex_I,
@@ -566,4 +566,3 @@ float complex fftfilt_cccf_data_h23x256_y[] = {
     0.017353066695 +  -0.086277701489*_Complex_I,
    -0.002902182702 +  -0.059776504802*_Complex_I,
    -0.044568379057 +  -0.090648234378*_Complex_I};
-
diff --git a/src/filter/tests/data/fftfilt_cccf_data_h4x256.c b/src/filter/tests/data/fftfilt_cccf_data_h4x256.c
index f3223970..4fca35fb 100644
--- a/src/filter/tests/data/fftfilt_cccf_data_h4x256.c
+++ b/src/filter/tests/data/fftfilt_cccf_data_h4x256.c
@@ -26,13 +26,13 @@
 
 #include <complex.h>
 
-float complex fftfilt_cccf_data_h4x256_h[] = {
+_Fcomplex fftfilt_cccf_data_h4x256_h[] = {
    -0.135231339931 +   0.062977480888*_Complex_I,
    -0.157240438461 +   0.037726294994*_Complex_I,
     0.169742667675 +  -0.043306457996*_Complex_I,
    -0.001679791883 +  -0.031882059574*_Complex_I};
 
-float complex fftfilt_cccf_data_h4x256_x[] = {
+_Fcomplex fftfilt_cccf_data_h4x256_x[] = {
    -0.145331311226 +   0.109500586987*_Complex_I,
     0.008576134592 +  -0.169542956352*_Complex_I,
     0.047844916582 +   0.149058306217*_Complex_I,
@@ -290,7 +290,7 @@ float complex fftfilt_cccf_data_h4x256_x[] = {
    -0.172086226940 +   0.121059966087*_Complex_I,
     0.119662201405 +  -0.004805976152*_Complex_I};
 
-float complex fftfilt_cccf_data_h4x256_y[] = {
+_Fcomplex fftfilt_cccf_data_h4x256_y[] = {
     0.012757276827 +  -0.023960510977*_Complex_I,
     0.028238533774 +   0.000766892287*_Complex_I,
    -0.030736578281 +   0.034719058493*_Complex_I,
@@ -547,4 +547,3 @@ float complex fftfilt_cccf_data_h4x256_y[] = {
    -0.029025601300 +   0.019024103552*_Complex_I,
     0.058627375247 +  -0.038320734588*_Complex_I,
    -0.014973530138 +  -0.021441866237*_Complex_I};
-
diff --git a/src/filter/tests/data/fftfilt_cccf_data_h7x256.c b/src/filter/tests/data/fftfilt_cccf_data_h7x256.c
index 7c2d918b..43545c3d 100644
--- a/src/filter/tests/data/fftfilt_cccf_data_h7x256.c
+++ b/src/filter/tests/data/fftfilt_cccf_data_h7x256.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex fftfilt_cccf_data_h7x256_h[] = {
+_Fcomplex fftfilt_cccf_data_h7x256_h[] = {
    -0.007281364501 +   0.082790547609*_Complex_I,
     0.009967260063 +  -0.094733065367*_Complex_I,
     0.081317949295 +  -0.022636219859*_Complex_I,
@@ -35,7 +35,7 @@ float complex fftfilt_cccf_data_h7x256_h[] = {
    -0.061433798075 +   0.010713580251*_Complex_I,
    -0.225753474236 +   0.128715121746*_Complex_I};
 
-float complex fftfilt_cccf_data_h7x256_x[] = {
+_Fcomplex fftfilt_cccf_data_h7x256_x[] = {
    -0.224034833908 +  -0.008699086308*_Complex_I,
    -0.049732953310 +  -0.031826138496*_Complex_I,
     0.076697158813 +   0.011335625499*_Complex_I,
@@ -293,7 +293,7 @@ float complex fftfilt_cccf_data_h7x256_x[] = {
    -0.060093468428 +   0.035650527477*_Complex_I,
     0.056396996975 +   0.005192263052*_Complex_I};
 
-float complex fftfilt_cccf_data_h7x256_y[] = {
+_Fcomplex fftfilt_cccf_data_h7x256_y[] = {
     0.002351481406 +  -0.018484625365*_Complex_I,
    -0.000060077369 +   0.017251119786*_Complex_I,
    -0.023422599244 +   0.015025306572*_Complex_I,
@@ -550,4 +550,3 @@ float complex fftfilt_cccf_data_h7x256_y[] = {
    -0.037693834890 +  -0.014701063462*_Complex_I,
    -0.006787010773 +  -0.016420585935*_Complex_I,
     0.026470441729 +   0.040610897283*_Complex_I};
-
diff --git a/src/filter/tests/data/fftfilt_crcf_data_h13x256.c b/src/filter/tests/data/fftfilt_crcf_data_h13x256.c
index e5d1be81..735a171a 100644
--- a/src/filter/tests/data/fftfilt_crcf_data_h13x256.c
+++ b/src/filter/tests/data/fftfilt_crcf_data_h13x256.c
@@ -41,7 +41,7 @@ float fftfilt_crcf_data_h13x256_h[] = {
    -0.079225271940,
     0.060841810703};
 
-float complex fftfilt_crcf_data_h13x256_x[] = {
+_Fcomplex fftfilt_crcf_data_h13x256_x[] = {
     0.085537636280 +  -0.046111658216*_Complex_I,
     0.225455975533 +  -0.212855386734*_Complex_I,
    -0.057062256336 +   0.128235316277*_Complex_I,
@@ -299,7 +299,7 @@ float complex fftfilt_crcf_data_h13x256_x[] = {
     0.072365719080 +   0.038520815969*_Complex_I,
     0.174543678761 +  -0.139873552322*_Complex_I};
 
-float complex fftfilt_crcf_data_h13x256_y[] = {
+_Fcomplex fftfilt_crcf_data_h13x256_y[] = {
     0.006707464887 +  -0.003615862465*_Complex_I,
     0.014358372283 +  -0.014900933014*_Complex_I,
    -0.017605463388 +   0.020679426057*_Complex_I,
@@ -556,4 +556,3 @@ float complex fftfilt_crcf_data_h13x256_y[] = {
    -0.003318140133 +   0.036850102200*_Complex_I,
     0.015644777552 +  -0.006720827246*_Complex_I,
     0.011761450619 +   0.045924263037*_Complex_I};
-
diff --git a/src/filter/tests/data/fftfilt_crcf_data_h23x256.c b/src/filter/tests/data/fftfilt_crcf_data_h23x256.c
index 50d4968a..a1d2ab17 100644
--- a/src/filter/tests/data/fftfilt_crcf_data_h23x256.c
+++ b/src/filter/tests/data/fftfilt_crcf_data_h23x256.c
@@ -51,7 +51,7 @@ float fftfilt_crcf_data_h23x256_h[] = {
     0.104599690437,
     0.007943090051};
 
-float complex fftfilt_crcf_data_h23x256_x[] = {
+_Fcomplex fftfilt_crcf_data_h23x256_x[] = {
     0.155103063583 +  -0.039989483356*_Complex_I,
     0.089731889963 +   0.007783630490*_Complex_I,
     0.031814819574 +  -0.092475223541*_Complex_I,
@@ -309,7 +309,7 @@ float complex fftfilt_crcf_data_h23x256_x[] = {
    -0.046347615123 +   0.012207016349*_Complex_I,
    -0.022019737959 +   0.008490467072*_Complex_I};
 
-float complex fftfilt_crcf_data_h23x256_y[] = {
+_Fcomplex fftfilt_crcf_data_h23x256_y[] = {
     0.027262836609 +  -0.007029047174*_Complex_I,
     0.018346427661 +   0.000704495242*_Complex_I,
    -0.004460839644 +  -0.013149554871*_Complex_I,
@@ -566,4 +566,3 @@ float complex fftfilt_crcf_data_h23x256_y[] = {
    -0.000873772321 +   0.003555393272*_Complex_I,
    -0.047364452139 +   0.039519457621*_Complex_I,
    -0.075184690098 +   0.032775776752*_Complex_I};
-
diff --git a/src/filter/tests/data/fftfilt_crcf_data_h4x256.c b/src/filter/tests/data/fftfilt_crcf_data_h4x256.c
index 0ee622b3..e58e2371 100644
--- a/src/filter/tests/data/fftfilt_crcf_data_h4x256.c
+++ b/src/filter/tests/data/fftfilt_crcf_data_h4x256.c
@@ -32,7 +32,7 @@ float fftfilt_crcf_data_h4x256_h[] = {
    -0.168462336063,
     0.090250796080};
 
-float complex fftfilt_crcf_data_h4x256_x[] = {
+_Fcomplex fftfilt_crcf_data_h4x256_x[] = {
     0.038939061761 +   0.066255682707*_Complex_I,
     0.119283056259 +   0.056196963787*_Complex_I,
    -0.040920588374 +  -0.079775565863*_Complex_I,
@@ -290,7 +290,7 @@ float complex fftfilt_crcf_data_h4x256_x[] = {
    -0.118900668621 +  -0.002717586420*_Complex_I,
    -0.069598269463 +  -0.110835444927*_Complex_I};
 
-float complex fftfilt_crcf_data_h4x256_y[] = {
+_Fcomplex fftfilt_crcf_data_h4x256_y[] = {
     0.006059868184 +   0.010311000972*_Complex_I,
     0.023178078930 +   0.016597675907*_Complex_I,
     0.001208400606 +  -0.016916628103*_Complex_I,
@@ -547,4 +547,3 @@ float complex fftfilt_crcf_data_h4x256_y[] = {
     0.015631583001 +  -0.046464537818*_Complex_I,
    -0.036593182213 +   0.039547933437*_Complex_I,
    -0.024611804187 +  -0.022132462723*_Complex_I};
-
diff --git a/src/filter/tests/data/fftfilt_crcf_data_h7x256.c b/src/filter/tests/data/fftfilt_crcf_data_h7x256.c
index 722d9e4e..d14780bb 100644
--- a/src/filter/tests/data/fftfilt_crcf_data_h7x256.c
+++ b/src/filter/tests/data/fftfilt_crcf_data_h7x256.c
@@ -35,7 +35,7 @@ float fftfilt_crcf_data_h7x256_h[] = {
     0.155969536304,
     0.169374001026};
 
-float complex fftfilt_crcf_data_h7x256_x[] = {
+_Fcomplex fftfilt_crcf_data_h7x256_x[] = {
     0.040651902556 +   0.099964648485*_Complex_I,
    -0.099666911364 +   0.065967345238*_Complex_I,
     0.160125207901 +   0.220931744576*_Complex_I,
@@ -293,7 +293,7 @@ float complex fftfilt_crcf_data_h7x256_x[] = {
     0.003785865381 +  -0.108235859871*_Complex_I,
    -0.007453963161 +   0.090025615692*_Complex_I};
 
-float complex fftfilt_crcf_data_h7x256_y[] = {
+_Fcomplex fftfilt_crcf_data_h7x256_y[] = {
    -0.001664060705 +  -0.004091991592*_Complex_I,
     0.009572387490 +   0.010806149100*_Complex_I,
    -0.019901401209 +   0.000163118771*_Complex_I,
@@ -550,4 +550,3 @@ float complex fftfilt_crcf_data_h7x256_y[] = {
     0.013883703469 +  -0.003931123862*_Complex_I,
     0.016113428385 +   0.014312499105*_Complex_I,
    -0.025629511396 +  -0.029198167224*_Complex_I};
-
diff --git a/src/filter/tests/data/firdecim_cccf_data_M2h4x20.c b/src/filter/tests/data/firdecim_cccf_data_M2h4x20.c
index e221ffdf..156e2891 100644
--- a/src/filter/tests/data/firdecim_cccf_data_M2h4x20.c
+++ b/src/filter/tests/data/firdecim_cccf_data_M2h4x20.c
@@ -26,13 +26,13 @@
 
 #include <complex.h>
 
-float complex firdecim_cccf_data_M2h4x20_h[] = {
+_Fcomplex firdecim_cccf_data_M2h4x20_h[] = {
    -0.010020822840 +   0.161896349165*_Complex_I,
    -0.160666600378 +  -0.002813281324*_Complex_I,
     0.074990149666 +  -0.043630565869*_Complex_I,
    -0.147489652317 +  -0.117556939153*_Complex_I};
 
-float complex firdecim_cccf_data_M2h4x20_x[] = {
+_Fcomplex firdecim_cccf_data_M2h4x20_x[] = {
    -0.062219283216 +   0.083707729807*_Complex_I,
     0.142772365864 +  -0.155087351763*_Complex_I,
    -0.035707773590 +  -0.015572103950*_Complex_I,
@@ -54,7 +54,7 @@ float complex firdecim_cccf_data_M2h4x20_x[] = {
     0.008377427496 +  -0.015424316799*_Complex_I,
    -0.115074264949 +   0.025508983239*_Complex_I};
 
-float complex firdecim_cccf_data_M2h4x20_y[] = {
+_Fcomplex firdecim_cccf_data_M2h4x20_y[] = {
    -0.012928487438 +  -0.010911895131*_Complex_I,
    -0.021509784691 +   0.027882703574*_Complex_I,
    -0.012073246090 +   0.010047339289*_Complex_I,
@@ -65,4 +65,3 @@ float complex firdecim_cccf_data_M2h4x20_y[] = {
    -0.004777468860 +  -0.026060577544*_Complex_I,
    -0.035559582789 +  -0.027278788500*_Complex_I,
     0.014869302818 +   0.023426450224*_Complex_I};
-
diff --git a/src/filter/tests/data/firdecim_cccf_data_M3h7x30.c b/src/filter/tests/data/firdecim_cccf_data_M3h7x30.c
index 24f60424..d5ff9908 100644
--- a/src/filter/tests/data/firdecim_cccf_data_M3h7x30.c
+++ b/src/filter/tests/data/firdecim_cccf_data_M3h7x30.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex firdecim_cccf_data_M3h7x30_h[] = {
+_Fcomplex firdecim_cccf_data_M3h7x30_h[] = {
    -0.006640626991 +   0.118904206653*_Complex_I,
    -0.083146000558 +  -0.275130943103*_Complex_I,
     0.079550052655 +   0.061532677877*_Complex_I,
@@ -35,7 +35,7 @@ float complex firdecim_cccf_data_M3h7x30_h[] = {
     0.055782888955 +   0.071073047549*_Complex_I,
    -0.102933394297 +  -0.076862023914*_Complex_I};
 
-float complex firdecim_cccf_data_M3h7x30_x[] = {
+_Fcomplex firdecim_cccf_data_M3h7x30_x[] = {
     0.069053975334 +  -0.000060226964*_Complex_I,
     0.052934817246 +   0.026246887839*_Complex_I,
    -0.008314557685 +   0.123860251104*_Complex_I,
@@ -67,7 +67,7 @@ float complex firdecim_cccf_data_M3h7x30_x[] = {
    -0.063513872529 +  -0.087941912765*_Complex_I,
    -0.065933510466 +   0.101592986516*_Complex_I};
 
-float complex firdecim_cccf_data_M3h7x30_y[] = {
+_Fcomplex firdecim_cccf_data_M3h7x30_y[] = {
    -0.000451400453 +   0.008211208098*_Complex_I,
     0.046679220394 +   0.009712412319*_Complex_I,
    -0.017763427623 +  -0.015970470090*_Complex_I,
@@ -78,4 +78,3 @@ float complex firdecim_cccf_data_M3h7x30_y[] = {
    -0.013695440245 +  -0.005147235363*_Complex_I,
     0.018210209849 +  -0.062011233592*_Complex_I,
    -0.014235918784 +   0.002032286514*_Complex_I};
-
diff --git a/src/filter/tests/data/firdecim_cccf_data_M4h13x40.c b/src/filter/tests/data/firdecim_cccf_data_M4h13x40.c
index 781fc3a5..f8af95bf 100644
--- a/src/filter/tests/data/firdecim_cccf_data_M4h13x40.c
+++ b/src/filter/tests/data/firdecim_cccf_data_M4h13x40.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex firdecim_cccf_data_M4h13x40_h[] = {
+_Fcomplex firdecim_cccf_data_M4h13x40_h[] = {
    -0.002562542003 +  -0.154124323834*_Complex_I,
    -0.023583498668 +   0.104733275459*_Complex_I,
     0.022367426058 +  -0.120923475320*_Complex_I,
@@ -41,7 +41,7 @@ float complex firdecim_cccf_data_M4h13x40_h[] = {
     0.011361818419 +  -0.070937481458*_Complex_I,
     0.094086356591 +  -0.103332276920*_Complex_I};
 
-float complex firdecim_cccf_data_M4h13x40_x[] = {
+_Fcomplex firdecim_cccf_data_M4h13x40_x[] = {
    -0.024194231006 +  -0.138925187631*_Complex_I,
     0.203856156849 +  -0.080078393335*_Complex_I,
    -0.068961728054 +   0.201298529466*_Complex_I,
@@ -83,7 +83,7 @@ float complex firdecim_cccf_data_M4h13x40_x[] = {
     0.075234897328 +   0.138257000400*_Complex_I,
    -0.097930194448 +  -0.076486145877*_Complex_I};
 
-float complex firdecim_cccf_data_M4h13x40_y[] = {
+_Fcomplex firdecim_cccf_data_M4h13x40_y[] = {
    -0.021349751874 +   0.004084921123*_Complex_I,
    -0.045716199011 +   0.026670647628*_Complex_I,
     0.062793796326 +   0.020298966406*_Complex_I,
@@ -94,4 +94,3 @@ float complex firdecim_cccf_data_M4h13x40_y[] = {
    -0.058971359279 +  -0.004947680884*_Complex_I,
    -0.009091338962 +  -0.022653029705*_Complex_I,
     0.017223757651 +   0.057653177650*_Complex_I};
-
diff --git a/src/filter/tests/data/firdecim_cccf_data_M5h23x50.c b/src/filter/tests/data/firdecim_cccf_data_M5h23x50.c
index 37f17248..f640b37c 100644
--- a/src/filter/tests/data/firdecim_cccf_data_M5h23x50.c
+++ b/src/filter/tests/data/firdecim_cccf_data_M5h23x50.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex firdecim_cccf_data_M5h23x50_h[] = {
+_Fcomplex firdecim_cccf_data_M5h23x50_h[] = {
     0.105720400924 +   0.057437069192*_Complex_I,
    -0.028209083196 +  -0.004313504575*_Complex_I,
    -0.072874560021 +   0.042888303750*_Complex_I,
@@ -51,7 +51,7 @@ float complex firdecim_cccf_data_M5h23x50_h[] = {
     0.052374918456 +  -0.044109539660*_Complex_I,
     0.013011637257 +  -0.076892387668*_Complex_I};
 
-float complex firdecim_cccf_data_M5h23x50_x[] = {
+_Fcomplex firdecim_cccf_data_M5h23x50_x[] = {
    -0.045706059285 +  -0.026925548272*_Complex_I,
     0.074640818692 +   0.020008220501*_Complex_I,
    -0.041286610033 +  -0.136882935267*_Complex_I,
@@ -103,7 +103,7 @@ float complex firdecim_cccf_data_M5h23x50_x[] = {
     0.126368745124 +   0.002307518720*_Complex_I,
     0.014850257877 +   0.006988676981*_Complex_I};
 
-float complex firdecim_cccf_data_M5h23x50_y[] = {
+_Fcomplex firdecim_cccf_data_M5h23x50_y[] = {
    -0.003285538333 +  -0.005471801848*_Complex_I,
     0.007588480326 +   0.024542591101*_Complex_I,
    -0.057029837651 +   0.045181309977*_Complex_I,
@@ -114,4 +114,3 @@ float complex firdecim_cccf_data_M5h23x50_y[] = {
     0.037166575400 +   0.001442464438*_Complex_I,
     0.015685676896 +   0.008079773457*_Complex_I,
    -0.025642858413 +   0.014281592109*_Complex_I};
-
diff --git a/src/filter/tests/data/firdecim_crcf_data_M2h4x20.c b/src/filter/tests/data/firdecim_crcf_data_M2h4x20.c
index d4a64d2a..7f87e84b 100644
--- a/src/filter/tests/data/firdecim_crcf_data_M2h4x20.c
+++ b/src/filter/tests/data/firdecim_crcf_data_M2h4x20.c
@@ -32,7 +32,7 @@ float firdecim_crcf_data_M2h4x20_h[] = {
    -0.123125426658,
     0.014724190886};
 
-float complex firdecim_crcf_data_M2h4x20_x[] = {
+_Fcomplex firdecim_crcf_data_M2h4x20_x[] = {
    -0.121360059018 +  -0.040946328225*_Complex_I,
    -0.048183917318 +  -0.090893384286*_Complex_I,
     0.050431539967 +  -0.039477767743*_Complex_I,
@@ -54,7 +54,7 @@ float complex firdecim_crcf_data_M2h4x20_x[] = {
     0.181551012573 +   0.015635958339*_Complex_I,
     0.081568978667 +   0.051967040191*_Complex_I};
 
-float complex firdecim_crcf_data_M2h4x20_y[] = {
+_Fcomplex firdecim_crcf_data_M2h4x20_y[] = {
    -0.003790779673 +  -0.001278991704*_Complex_I,
     0.026926548630 +   0.023443353500*_Complex_I,
     0.015265670091 +   0.008127371986*_Complex_I,
@@ -65,4 +65,3 @@ float complex firdecim_crcf_data_M2h4x20_y[] = {
    -0.023962832263 +   0.006444039955*_Complex_I,
    -0.023581901158 +  -0.005760782332*_Complex_I,
     0.019033897622 +  -0.010698088224*_Complex_I};
-
diff --git a/src/filter/tests/data/firdecim_crcf_data_M3h7x30.c b/src/filter/tests/data/firdecim_crcf_data_M3h7x30.c
index 39ef6d62..f9ed5f72 100644
--- a/src/filter/tests/data/firdecim_crcf_data_M3h7x30.c
+++ b/src/filter/tests/data/firdecim_crcf_data_M3h7x30.c
@@ -35,7 +35,7 @@ float firdecim_crcf_data_M3h7x30_h[] = {
    -0.026617010237,
     0.011725565067};
 
-float complex firdecim_crcf_data_M3h7x30_x[] = {
+_Fcomplex firdecim_crcf_data_M3h7x30_x[] = {
    -0.088297122268 +   0.055665944654*_Complex_I,
    -0.016432697221 +   0.148455554729*_Complex_I,
     0.140757522457 +   0.073543902343*_Complex_I,
@@ -67,7 +67,7 @@ float complex firdecim_crcf_data_M3h7x30_x[] = {
     0.216869453975 +   0.054039885226*_Complex_I,
     0.165978694869 +  -0.091956658785*_Complex_I};
 
-float complex firdecim_crcf_data_M3h7x30_y[] = {
+_Fcomplex firdecim_crcf_data_M3h7x30_y[] = {
     0.005928065557 +  -0.003737283399*_Complex_I,
     0.011225704498 +  -0.028387046159*_Complex_I,
    -0.009438639157 +   0.009365565615*_Complex_I,
@@ -78,4 +78,3 @@ float complex firdecim_crcf_data_M3h7x30_y[] = {
     0.021530701506 +   0.030652367492*_Complex_I,
    -0.021493289366 +   0.012309152915*_Complex_I,
    -0.009126109290 +   0.046129860989*_Complex_I};
-
diff --git a/src/filter/tests/data/firdecim_crcf_data_M4h13x40.c b/src/filter/tests/data/firdecim_crcf_data_M4h13x40.c
index 3e4f867c..d5967c94 100644
--- a/src/filter/tests/data/firdecim_crcf_data_M4h13x40.c
+++ b/src/filter/tests/data/firdecim_crcf_data_M4h13x40.c
@@ -41,7 +41,7 @@ float firdecim_crcf_data_M4h13x40_h[] = {
     0.045576979285,
    -0.032175124851};
 
-float complex firdecim_crcf_data_M4h13x40_x[] = {
+_Fcomplex firdecim_crcf_data_M4h13x40_x[] = {
    -0.112962750920 +  -0.174396579717*_Complex_I,
     0.036553706748 +  -0.051072169083*_Complex_I,
     0.022797265387 +   0.042572931849*_Complex_I,
@@ -83,7 +83,7 @@ float complex firdecim_crcf_data_M4h13x40_x[] = {
     0.091043924052 +  -0.118961124120*_Complex_I,
    -0.060921349688 +  -0.036527277081*_Complex_I};
 
-float complex firdecim_crcf_data_M4h13x40_y[] = {
+_Fcomplex firdecim_crcf_data_M4h13x40_y[] = {
     0.001992039351 +   0.003075392964*_Complex_I,
     0.000572688534 +   0.004492265743*_Complex_I,
    -0.010835528800 +   0.003970601587*_Complex_I,
@@ -94,4 +94,3 @@ float complex firdecim_crcf_data_M4h13x40_y[] = {
     0.007921191245 +  -0.004652046754*_Complex_I,
    -0.019294993452 +  -0.027474217637*_Complex_I,
     0.025318608692 +  -0.002964377998*_Complex_I};
-
diff --git a/src/filter/tests/data/firdecim_crcf_data_M5h23x50.c b/src/filter/tests/data/firdecim_crcf_data_M5h23x50.c
index 6d002817..47860117 100644
--- a/src/filter/tests/data/firdecim_crcf_data_M5h23x50.c
+++ b/src/filter/tests/data/firdecim_crcf_data_M5h23x50.c
@@ -51,7 +51,7 @@ float firdecim_crcf_data_M5h23x50_h[] = {
    -0.061515114912,
     0.038253839794};
 
-float complex firdecim_crcf_data_M5h23x50_x[] = {
+_Fcomplex firdecim_crcf_data_M5h23x50_x[] = {
    -0.182183709645 +  -0.105810548671*_Complex_I,
    -0.119835664561 +   0.052187599214*_Complex_I,
    -0.080413311444 +  -0.007654126449*_Complex_I,
@@ -103,7 +103,7 @@ float complex firdecim_crcf_data_M5h23x50_x[] = {
    -0.145263809029 +   0.080441672618*_Complex_I,
    -0.065703128284 +   0.056608305388*_Complex_I};
 
-float complex firdecim_crcf_data_M5h23x50_y[] = {
+_Fcomplex firdecim_crcf_data_M5h23x50_y[] = {
    -0.000415418699 +  -0.000241271190*_Complex_I,
     0.009483904304 +   0.033419922261*_Complex_I,
     0.053902979681 +   0.014937609575*_Complex_I,
@@ -114,4 +114,3 @@ float complex firdecim_crcf_data_M5h23x50_y[] = {
    -0.000363929634 +  -0.002841410024*_Complex_I,
    -0.028488318939 +  -0.002263371809*_Complex_I,
     0.049749343516 +   0.025688357259*_Complex_I};
-
diff --git a/src/filter/tests/data/firfilt_cccf_data_h13x32.c b/src/filter/tests/data/firfilt_cccf_data_h13x32.c
index b7d011f1..89bbaab9 100644
--- a/src/filter/tests/data/firfilt_cccf_data_h13x32.c
+++ b/src/filter/tests/data/firfilt_cccf_data_h13x32.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex firfilt_cccf_data_h13x32_h[] = {
+_Fcomplex firfilt_cccf_data_h13x32_h[] = {
    -0.016900612660 +  -0.094711890552*_Complex_I,
     0.021604417271 +   0.142776429157*_Complex_I,
    -0.115236149764 +  -0.169153952067*_Complex_I,
@@ -41,7 +41,7 @@ float complex firfilt_cccf_data_h13x32_h[] = {
     0.073260028098 +   0.102435049392*_Complex_I,
    -0.064585416482 +   0.016491998619*_Complex_I};
 
-float complex firfilt_cccf_data_h13x32_x[] = {
+_Fcomplex firfilt_cccf_data_h13x32_x[] = {
    -0.230394652772 +  -0.084902186709*_Complex_I,
     0.116521954181 +  -0.075921100646*_Complex_I,
    -0.037505572140 +   0.050295775262*_Complex_I,
@@ -75,7 +75,7 @@ float complex firfilt_cccf_data_h13x32_x[] = {
    -0.166213598571 +   0.030726287248*_Complex_I,
    -0.276903984324 +  -0.003789664941*_Complex_I};
 
-float complex firfilt_cccf_data_h13x32_y[] = {
+_Fcomplex firfilt_cccf_data_h13x32_y[] = {
    -0.004147435830 +   0.023256012109*_Complex_I,
    -0.002015434559 +  -0.044482089545*_Complex_I,
     0.030942859967 +   0.066454518780*_Complex_I,
@@ -108,4 +108,3 @@ float complex firfilt_cccf_data_h13x32_y[] = {
    -0.009114204900 +   0.008932656001*_Complex_I,
    -0.003773949758 +   0.033245440352*_Complex_I,
    -0.062498938791 +   0.037655501652*_Complex_I};
-
diff --git a/src/filter/tests/data/firfilt_cccf_data_h23x64.c b/src/filter/tests/data/firfilt_cccf_data_h23x64.c
index 252be57e..5f5b4bc7 100644
--- a/src/filter/tests/data/firfilt_cccf_data_h23x64.c
+++ b/src/filter/tests/data/firfilt_cccf_data_h23x64.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex firfilt_cccf_data_h23x64_h[] = {
+_Fcomplex firfilt_cccf_data_h23x64_h[] = {
     0.007386483162 +  -0.009424072453*_Complex_I,
     0.050423187035 +   0.150124405632*_Complex_I,
     0.243542351374 +   0.080326589069*_Complex_I,
@@ -51,7 +51,7 @@ float complex firfilt_cccf_data_h23x64_h[] = {
    -0.061473756719 +  -0.101802249138*_Complex_I,
    -0.069996222196 +   0.068670445429*_Complex_I};
 
-float complex firfilt_cccf_data_h23x64_x[] = {
+_Fcomplex firfilt_cccf_data_h23x64_x[] = {
    -0.078781393877 +   0.110995541416*_Complex_I,
    -0.047869391092 +  -0.021406341819*_Complex_I,
     0.037075730398 +   0.142733143372*_Complex_I,
@@ -117,7 +117,7 @@ float complex firfilt_cccf_data_h23x64_x[] = {
     0.214202412315 +  -0.062090364159*_Complex_I,
     0.051648310107 +   0.008540965007*_Complex_I};
 
-float complex firfilt_cccf_data_h23x64_y[] = {
+_Fcomplex firfilt_cccf_data_h23x64_y[] = {
     0.000464112585 +   0.001562308262*_Complex_I,
    -0.021190870009 +  -0.005937253959*_Complex_I,
    -0.025683625328 +   0.013143026224*_Complex_I,
@@ -182,4 +182,3 @@ float complex firfilt_cccf_data_h23x64_y[] = {
    -0.073363097948 +  -0.031874352056*_Complex_I,
     0.007512286472 +  -0.110602957303*_Complex_I,
     0.074317818667 +  -0.076288705193*_Complex_I};
-
diff --git a/src/filter/tests/data/firfilt_cccf_data_h4x8.c b/src/filter/tests/data/firfilt_cccf_data_h4x8.c
index d8b0980c..3db38a72 100644
--- a/src/filter/tests/data/firfilt_cccf_data_h4x8.c
+++ b/src/filter/tests/data/firfilt_cccf_data_h4x8.c
@@ -26,13 +26,13 @@
 
 #include <complex.h>
 
-float complex firfilt_cccf_data_h4x8_h[] = {
+_Fcomplex firfilt_cccf_data_h4x8_h[] = {
    -0.031084031859 +  -0.013523088141*_Complex_I,
    -0.129175459526 +   0.067705781544*_Complex_I,
     0.221460930668 +  -0.057515301525*_Complex_I,
    -0.023734659272 +   0.094741117144*_Complex_I};
 
-float complex firfilt_cccf_data_h4x8_x[] = {
+_Fcomplex firfilt_cccf_data_h4x8_x[] = {
     0.035529355081 +  -0.025645176804*_Complex_I,
     0.010053327033 +   0.058182925297*_Complex_I,
    -0.051911580279 +  -0.038455783791*_Complex_I,
@@ -42,7 +42,7 @@ float complex firfilt_cccf_data_h4x8_x[] = {
     0.072440149482 +   0.119581756000*_Complex_I,
    -0.070807340362 +   0.027693599784*_Complex_I};
 
-float complex firfilt_cccf_data_h4x8_y[] = {
+_Fcomplex firfilt_cccf_data_h4x8_y[] = {
    -0.001451197592 +   0.000316688892*_Complex_I,
    -0.002378879142 +   0.003773758321*_Complex_I,
     0.002248990658 +  -0.012660658356*_Complex_I,
@@ -51,4 +51,3 @@ float complex firfilt_cccf_data_h4x8_y[] = {
     0.048100008285 +  -0.032526172551*_Complex_I,
    -0.047049781567 +   0.010960128197*_Complex_I,
    -0.012767824065 +  -0.007537619160*_Complex_I};
-
diff --git a/src/filter/tests/data/firfilt_cccf_data_h7x16.c b/src/filter/tests/data/firfilt_cccf_data_h7x16.c
index 913454a3..06c8fa49 100644
--- a/src/filter/tests/data/firfilt_cccf_data_h7x16.c
+++ b/src/filter/tests/data/firfilt_cccf_data_h7x16.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex firfilt_cccf_data_h7x16_h[] = {
+_Fcomplex firfilt_cccf_data_h7x16_h[] = {
     0.059672454354 +  -0.020066091352*_Complex_I,
    -0.074492656514 +  -0.047414131969*_Complex_I,
     0.035667494507 +  -0.071294810193*_Complex_I,
@@ -35,7 +35,7 @@ float complex firfilt_cccf_data_h7x16_h[] = {
     0.072724115403 +   0.012655052298*_Complex_I,
    -0.195972668164 +  -0.009791166658*_Complex_I};
 
-float complex firfilt_cccf_data_h7x16_x[] = {
+_Fcomplex firfilt_cccf_data_h7x16_x[] = {
    -0.078420841238 +   0.087748743839*_Complex_I,
    -0.108100101013 +   0.135812982907*_Complex_I,
    -0.084609799993 +  -0.122999836505*_Complex_I,
@@ -53,7 +53,7 @@ float complex firfilt_cccf_data_h7x16_x[] = {
    -0.022799538279 +   0.052284827296*_Complex_I,
    -0.019334058586 +   0.032106298627*_Complex_I};
 
-float complex firfilt_cccf_data_h7x16_y[] = {
+_Fcomplex firfilt_cccf_data_h7x16_y[] = {
    -0.002918789759 +   0.006809782675*_Complex_I,
     0.006276944689 +   0.007455059607*_Complex_I,
     0.010434073117 +  -0.001912734754*_Complex_I,
@@ -70,4 +70,3 @@ float complex firfilt_cccf_data_h7x16_y[] = {
     0.007947112966 +   0.022079470097*_Complex_I,
    -0.003430027671 +  -0.018931432282*_Complex_I,
     0.001572545942 +   0.003497349824*_Complex_I};
-
diff --git a/src/filter/tests/data/firfilt_crcf_data_h13x32.c b/src/filter/tests/data/firfilt_crcf_data_h13x32.c
index c0ac4059..db335958 100644
--- a/src/filter/tests/data/firfilt_crcf_data_h13x32.c
+++ b/src/filter/tests/data/firfilt_crcf_data_h13x32.c
@@ -41,7 +41,7 @@ float firfilt_crcf_data_h13x32_h[] = {
     0.059428974785,
     0.036011050317};
 
-float complex firfilt_crcf_data_h13x32_x[] = {
+_Fcomplex firfilt_crcf_data_h13x32_x[] = {
    -0.150478051517 +   0.011369787230*_Complex_I,
    -0.011682362019 +  -0.131898855698*_Complex_I,
     0.002241423344 +   0.056583759593*_Complex_I,
@@ -75,7 +75,7 @@ float complex firfilt_crcf_data_h13x32_x[] = {
     0.154250187563 +  -0.051859524539*_Complex_I,
     0.085702710731 +  -0.034956856551*_Complex_I};
 
-float complex firfilt_crcf_data_h13x32_y[] = {
+_Fcomplex firfilt_crcf_data_h13x32_y[] = {
    -0.000769529978 +   0.000058143975*_Complex_I,
    -0.000855209812 +  -0.000614414049*_Complex_I,
     0.017978713542 +  -0.001770120683*_Complex_I,
@@ -108,4 +108,3 @@ float complex firfilt_crcf_data_h13x32_y[] = {
     0.000657385901 +   0.001192381502*_Complex_I,
    -0.008080139857 +   0.018480645475*_Complex_I,
    -0.007551765865 +   0.003627711775*_Complex_I};
-
diff --git a/src/filter/tests/data/firfilt_crcf_data_h23x64.c b/src/filter/tests/data/firfilt_crcf_data_h23x64.c
index e3691fb7..1216ae7a 100644
--- a/src/filter/tests/data/firfilt_crcf_data_h23x64.c
+++ b/src/filter/tests/data/firfilt_crcf_data_h23x64.c
@@ -51,7 +51,7 @@ float firfilt_crcf_data_h23x64_h[] = {
    -0.088642880661,
     0.061210119166};
 
-float complex firfilt_crcf_data_h23x64_x[] = {
+_Fcomplex firfilt_crcf_data_h23x64_x[] = {
    -0.061754655621 +   0.035123551291*_Complex_I,
    -0.042987945529 +   0.204710494551*_Complex_I,
    -0.115448103025 +  -0.048546960311*_Complex_I,
@@ -117,7 +117,7 @@ float complex firfilt_crcf_data_h23x64_x[] = {
    -0.056671384848 +   0.100393269844*_Complex_I,
     0.047875493425 +  -0.053453060952*_Complex_I};
 
-float complex firfilt_crcf_data_h23x64_y[] = {
+_Fcomplex firfilt_crcf_data_h23x64_y[] = {
    -0.009797648512 +   0.005572506341*_Complex_I,
    -0.005560604075 +   0.031761800240*_Complex_I,
    -0.014087267678 +  -0.013784337240*_Complex_I,
@@ -182,4 +182,3 @@ float complex firfilt_crcf_data_h23x64_y[] = {
    -0.069716561264 +   0.004791194532*_Complex_I,
    -0.004221111697 +  -0.015828369005*_Complex_I,
     0.018252044788 +   0.020184229477*_Complex_I};
-
diff --git a/src/filter/tests/data/firfilt_crcf_data_h4x8.c b/src/filter/tests/data/firfilt_crcf_data_h4x8.c
index 35eb624f..d16501c1 100644
--- a/src/filter/tests/data/firfilt_crcf_data_h4x8.c
+++ b/src/filter/tests/data/firfilt_crcf_data_h4x8.c
@@ -32,7 +32,7 @@ float firfilt_crcf_data_h4x8_h[] = {
     0.083945750272,
     0.016820374297};
 
-float complex firfilt_crcf_data_h4x8_x[] = {
+_Fcomplex firfilt_crcf_data_h4x8_x[] = {
     0.212556497097 +  -0.062593316778*_Complex_I,
     0.074632428892 +  -0.155168218555*_Complex_I,
    -0.139928836211 +  -0.151937330426*_Complex_I,
@@ -42,7 +42,7 @@ float complex firfilt_crcf_data_h4x8_x[] = {
    -0.134588116658 +  -0.011633439603*_Complex_I,
     0.035369414992 +  -0.047878728319*_Complex_I};
 
-float complex firfilt_crcf_data_h4x8_y[] = {
+_Fcomplex firfilt_crcf_data_h4x8_y[] = {
     0.017243764119 +  -0.005077917658*_Complex_I,
    -0.004168844485 +  -0.009577524353*_Complex_I,
     0.002901774665 +  -0.010117235877*_Complex_I,
@@ -51,4 +51,3 @@ float complex firfilt_crcf_data_h4x8_y[] = {
     0.011608332082 +   0.024557748499*_Complex_I,
    -0.012737392976 +  -0.016099749821*_Complex_I,
     0.021907294708 +   0.021294289547*_Complex_I};
-
diff --git a/src/filter/tests/data/firfilt_crcf_data_h7x16.c b/src/filter/tests/data/firfilt_crcf_data_h7x16.c
index f399bf60..63c07a7e 100644
--- a/src/filter/tests/data/firfilt_crcf_data_h7x16.c
+++ b/src/filter/tests/data/firfilt_crcf_data_h7x16.c
@@ -35,7 +35,7 @@ float firfilt_crcf_data_h7x16_h[] = {
    -0.084839081860,
     0.026675441534};
 
-float complex firfilt_crcf_data_h7x16_x[] = {
+_Fcomplex firfilt_crcf_data_h7x16_x[] = {
    -0.050554619430 +  -0.051932459243*_Complex_I,
     0.033654160787 +   0.041969310283*_Complex_I,
     0.083110727700 +   0.078162488859*_Complex_I,
@@ -53,7 +53,7 @@ float complex firfilt_crcf_data_h7x16_x[] = {
     0.026416620904 +   0.138990393077*_Complex_I,
    -0.116423582608 +  -0.028759261678*_Complex_I};
 
-float complex firfilt_crcf_data_h7x16_y[] = {
+_Fcomplex firfilt_crcf_data_h7x16_y[] = {
    -0.001407198576 +  -0.001445551040*_Complex_I,
     0.002991596797 +   0.003279053964*_Complex_I,
     0.005792966776 +   0.005449371658*_Complex_I,
@@ -70,4 +70,3 @@ float complex firfilt_crcf_data_h7x16_y[] = {
     0.022929460881 +   0.022153334200*_Complex_I,
    -0.038653803420 +   0.008885169596*_Complex_I,
    -0.048989194709 +   0.030055784593*_Complex_I};
-
diff --git a/src/filter/tests/data/iirfilt_cccf_data_h3x64.c b/src/filter/tests/data/iirfilt_cccf_data_h3x64.c
index 88168255..d0e60f80 100644
--- a/src/filter/tests/data/iirfilt_cccf_data_h3x64.c
+++ b/src/filter/tests/data/iirfilt_cccf_data_h3x64.c
@@ -26,17 +26,17 @@
 
 #include <complex.h>
 
-float complex iirfilt_cccf_data_h3x64_b[] = {
+_Fcomplex iirfilt_cccf_data_h3x64_b[] = {
     0.054572462936 +   0.039649215181*_Complex_I,
     0.041689651984 +   0.128307555581*_Complex_I,
    -0.020844825992 +   0.064153777791*_Complex_I};
 
-float complex iirfilt_cccf_data_h3x64_a[] = {
+_Fcomplex iirfilt_cccf_data_h3x64_a[] = {
     0.809016994375 +   0.587785252292*_Complex_I,
    -0.353200399524 +  -1.087039054939*_Complex_I,
    -0.127562709117 +   0.392597649806*_Complex_I};
 
-float complex iirfilt_cccf_data_h3x64_x[] = {
+_Fcomplex iirfilt_cccf_data_h3x64_x[] = {
    -0.024833213118 +  -0.034917156419*_Complex_I,
    -0.203303753453 +  -0.146194321825*_Complex_I,
     0.046955837790 +  -0.018522626941*_Complex_I,
@@ -102,7 +102,7 @@ float complex iirfilt_cccf_data_h3x64_x[] = {
    -0.115073955933 +  -0.091807014377*_Complex_I,
     0.153344859386 +  -0.062742865142*_Complex_I};
 
-float complex iirfilt_cccf_data_h3x64_y[] = {
+_Fcomplex iirfilt_cccf_data_h3x64_y[] = {
    -0.001675131192 +  -0.002355346350*_Complex_I,
    -0.013622046565 +  -0.018945208542*_Complex_I,
    -0.006286044544 +  -0.061360482408*_Complex_I,
@@ -167,4 +167,3 @@ float complex iirfilt_cccf_data_h3x64_y[] = {
    -0.096355781376 +   0.032987760948*_Complex_I,
    -0.090540548264 +  -0.030202075604*_Complex_I,
    -0.036200313340 +  -0.078861745571*_Complex_I};
-
diff --git a/src/filter/tests/data/iirfilt_cccf_data_h5x64.c b/src/filter/tests/data/iirfilt_cccf_data_h5x64.c
index 71b8e362..28cef26e 100644
--- a/src/filter/tests/data/iirfilt_cccf_data_h5x64.c
+++ b/src/filter/tests/data/iirfilt_cccf_data_h5x64.c
@@ -26,21 +26,21 @@
 
 #include <complex.h>
 
-float complex iirfilt_cccf_data_h5x64_b[] = {
+_Fcomplex iirfilt_cccf_data_h5x64_b[] = {
     0.003902975763 +   0.002835677878*_Complex_I,
     0.005963216337 +   0.018352892749*_Complex_I,
    -0.008944824505 +   0.027529339123*_Complex_I,
    -0.015611903052 +   0.011342711511*_Complex_I,
    -0.004824343358 +   0.000000000000*_Complex_I};
 
-float complex iirfilt_cccf_data_h5x64_a[] = {
+_Fcomplex iirfilt_cccf_data_h5x64_a[] = {
     0.809016994375 +   0.587785252292*_Complex_I,
    -0.732219787612 +  -2.253540785927*_Complex_I,
    -0.715061744841 +   2.200733760162*_Complex_I,
     0.853242236735 +  -0.619916771678*_Complex_I,
    -0.187379492368 +   0.000000000000*_Complex_I};
 
-float complex iirfilt_cccf_data_h5x64_x[] = {
+_Fcomplex iirfilt_cccf_data_h5x64_x[] = {
    -0.139691779780 +  -0.008483106386*_Complex_I,
    -0.016364784445 +  -0.044182994598*_Complex_I,
    -0.027693468539 +  -0.032794063650*_Complex_I,
@@ -106,7 +106,7 @@ float complex iirfilt_cccf_data_h5x64_x[] = {
     0.020341098638 +  -0.131272589643*_Complex_I,
    -0.037882757496 +   0.067034671078*_Complex_I};
 
-float complex iirfilt_cccf_data_h5x64_y[] = {
+_Fcomplex iirfilt_cccf_data_h5x64_y[] = {
    -0.000673921110 +  -0.000040925418*_Complex_I,
    -0.003398473742 +  -0.002947141586*_Complex_I,
    -0.002922206681 +  -0.013825603768*_Complex_I,
@@ -171,4 +171,3 @@ float complex iirfilt_cccf_data_h5x64_y[] = {
    -0.038765003010 +   0.039996085676*_Complex_I,
    -0.035736567857 +  -0.000694897676*_Complex_I,
    -0.015553151187 +  -0.003464831303*_Complex_I};
-
diff --git a/src/filter/tests/data/iirfilt_cccf_data_h7x64.c b/src/filter/tests/data/iirfilt_cccf_data_h7x64.c
index 064ca431..f613344c 100644
--- a/src/filter/tests/data/iirfilt_cccf_data_h7x64.c
+++ b/src/filter/tests/data/iirfilt_cccf_data_h7x64.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex iirfilt_cccf_data_h7x64_b[] = {
+_Fcomplex iirfilt_cccf_data_h7x64_b[] = {
     0.000275500748 +   0.000200163010*_Complex_I,
     0.000631391531 +   0.001943223322*_Complex_I,
    -0.001578478829 +   0.004858058305*_Complex_I,
@@ -35,7 +35,7 @@ float complex iirfilt_cccf_data_h7x64_b[] = {
    -0.001653004490 +  -0.001200978061*_Complex_I,
    -0.000105231922 +  -0.000323870554*_Complex_I};
 
-float complex iirfilt_cccf_data_h7x64_a[] = {
+_Fcomplex iirfilt_cccf_data_h7x64_a[] = {
     0.809016994375 +   0.587785252292*_Complex_I,
    -1.106106182941 +  -3.404244789607*_Complex_I,
    -1.748624319785 +   5.381712281707*_Complex_I,
@@ -44,7 +44,7 @@ float complex iirfilt_cccf_data_h7x64_a[] = {
     0.570578744331 +   0.414549723333*_Complex_I,
    -0.025882175591 +  -0.079657145723*_Complex_I};
 
-float complex iirfilt_cccf_data_h7x64_x[] = {
+_Fcomplex iirfilt_cccf_data_h7x64_x[] = {
    -0.098550426609 +  -0.003621212634*_Complex_I,
    -0.016756220318 +   0.048451159934*_Complex_I,
     0.128559901552 +  -0.175906398240*_Complex_I,
@@ -110,7 +110,7 @@ float complex iirfilt_cccf_data_h7x64_x[] = {
     0.076788203575 +   0.031140443013*_Complex_I,
     0.140726220651 +  -0.116220629853*_Complex_I};
 
-float complex iirfilt_cccf_data_h7x64_y[] = {
+_Fcomplex iirfilt_cccf_data_h7x64_y[] = {
    -0.000033560131 +  -0.000001233159*_Complex_I,
    -0.000258851151 +  -0.000182022816*_Complex_I,
    -0.000494649917 +  -0.001373362038*_Complex_I,
@@ -175,4 +175,3 @@ float complex iirfilt_cccf_data_h7x64_y[] = {
     0.058934016585 +  -0.030613923443*_Complex_I,
     0.051235943856 +   0.012914473925*_Complex_I,
     0.016853513686 +   0.024980258409*_Complex_I};
-
diff --git a/src/filter/tests/data/iirfilt_crcf_data_h3x64.c b/src/filter/tests/data/iirfilt_crcf_data_h3x64.c
index 387305f5..4bfd975e 100644
--- a/src/filter/tests/data/iirfilt_crcf_data_h3x64.c
+++ b/src/filter/tests/data/iirfilt_crcf_data_h3x64.c
@@ -36,7 +36,7 @@ float iirfilt_crcf_data_h3x64_a[] = {
    -1.142980502540,
     0.412801598096};
 
-float complex iirfilt_crcf_data_h3x64_x[] = {
+_Fcomplex iirfilt_crcf_data_h3x64_x[] = {
     0.157714921372 +   0.096933651372*_Complex_I,
     0.112931825396 +   0.063629523666*_Complex_I,
     0.036350589338 +   0.126527528681*_Complex_I,
@@ -102,7 +102,7 @@ float complex iirfilt_crcf_data_h3x64_x[] = {
    -0.022768793380 +  -0.030601437534*_Complex_I,
     0.108180951121 +   0.069467116791*_Complex_I};
 
-float complex iirfilt_crcf_data_h3x64_y[] = {
+_Fcomplex iirfilt_crcf_data_h3x64_y[] = {
     0.010638703218 +   0.006538686002*_Complex_I,
     0.041055083998 +   0.024843109564*_Complex_I,
     0.070859923453 +   0.049353938820*_Complex_I,
@@ -167,4 +167,3 @@ float complex iirfilt_crcf_data_h3x64_y[] = {
     0.011102622655 +  -0.030445232324*_Complex_I,
    -0.005846867304 +  -0.039949067467*_Complex_I,
    -0.009834168653 +  -0.037451411970*_Complex_I};
-
diff --git a/src/filter/tests/data/iirfilt_crcf_data_h5x64.c b/src/filter/tests/data/iirfilt_crcf_data_h5x64.c
index 13b5ae16..3f39079f 100644
--- a/src/filter/tests/data/iirfilt_crcf_data_h5x64.c
+++ b/src/filter/tests/data/iirfilt_crcf_data_h5x64.c
@@ -40,7 +40,7 @@ float iirfilt_crcf_data_h5x64_a[] = {
    -1.054665405879,
     0.187379492368};
 
-float complex iirfilt_crcf_data_h5x64_x[] = {
+_Fcomplex iirfilt_crcf_data_h5x64_x[] = {
     0.034816486087 +  -0.057435933225*_Complex_I,
    -0.138922686034 +   0.002487157060*_Complex_I,
     0.002168200782 +   0.075752631688*_Complex_I,
@@ -106,7 +106,7 @@ float complex iirfilt_crcf_data_h5x64_x[] = {
     0.066507006426 +   0.153027239112*_Complex_I,
    -0.093381553000 +   0.004333390574*_Complex_I};
 
-float complex iirfilt_crcf_data_h5x64_y[] = {
+_Fcomplex iirfilt_crcf_data_h5x64_y[] = {
     0.000167966683 +  -0.000277090663*_Complex_I,
     0.000399655237 +  -0.001752933682*_Complex_I,
    -0.001104267382 +  -0.004761506250*_Complex_I,
@@ -171,4 +171,3 @@ float complex iirfilt_crcf_data_h5x64_y[] = {
    -0.055715901366 +  -0.041773963667*_Complex_I,
    -0.087248260391 +  -0.024536503294*_Complex_I,
    -0.103228307102 +   0.002973369704*_Complex_I};
-
diff --git a/src/filter/tests/data/iirfilt_crcf_data_h7x64.c b/src/filter/tests/data/iirfilt_crcf_data_h7x64.c
index 6e6ac9c6..ba93f8bf 100644
--- a/src/filter/tests/data/iirfilt_crcf_data_h7x64.c
+++ b/src/filter/tests/data/iirfilt_crcf_data_h7x64.c
@@ -44,7 +44,7 @@ float iirfilt_crcf_data_h7x64_a[] = {
    -0.705274114510,
     0.083756479619};
 
-float complex iirfilt_crcf_data_h7x64_x[] = {
+_Fcomplex iirfilt_crcf_data_h7x64_x[] = {
     0.004233635522 +   0.032166672422*_Complex_I,
    -0.157552590267 +   0.250368602921*_Complex_I,
     0.054267060665 +  -0.005044027264*_Complex_I,
@@ -110,7 +110,7 @@ float complex iirfilt_crcf_data_h7x64_x[] = {
    -0.097352654114 +  -0.073775329625*_Complex_I,
    -0.160782253378 +   0.108482062513*_Complex_I};
 
-float complex iirfilt_crcf_data_h7x64_y[] = {
+_Fcomplex iirfilt_crcf_data_h7x64_y[] = {
     0.000001441712 +   0.000010953963*_Complex_I,
    -0.000039841800 +   0.000190192712*_Complex_I,
    -0.000432579170 +   0.001292948964*_Complex_I,
@@ -175,4 +175,3 @@ float complex iirfilt_crcf_data_h7x64_y[] = {
    -0.012808887831 +   0.051482609352*_Complex_I,
    -0.019272140076 +   0.038484586328*_Complex_I,
    -0.034383553960 +   0.022386350903*_Complex_I};
-
diff --git a/src/filter/tests/fftfilt_autotest.h b/src/filter/tests/fftfilt_autotest.h
index 45a3b48c..4f607687 100644
--- a/src/filter/tests/fftfilt_autotest.h
+++ b/src/filter/tests/fftfilt_autotest.h
@@ -43,19 +43,19 @@ void fftfilt_rrrf_test(float *      _h,
 
 void fftfilt_crcf_test(float *         _h,
                        unsigned int    _h_len,
-                       float complex * _x,
+                       _Fcomplex * _x,
                        unsigned int    _x_len,
-                       float complex * _y,
+                       _Fcomplex * _y,
                        unsigned int    _y_len);
 
-void fftfilt_cccf_test(float complex * _h,
+void fftfilt_cccf_test(_Fcomplex * _h,
                        unsigned int    _h_len,
-                       float complex * _x,
+                       _Fcomplex * _x,
                        unsigned int    _x_len,
-                       float complex * _y,
+                       _Fcomplex * _y,
                        unsigned int    _y_len);
 
-// 
+//
 // autotest datasets
 //
 
@@ -78,37 +78,36 @@ extern float         fftfilt_rrrf_data_h23x256_y[];
 
 // crcf
 extern float         fftfilt_crcf_data_h4x256_h[];
-extern float complex fftfilt_crcf_data_h4x256_x[];
-extern float complex fftfilt_crcf_data_h4x256_y[];
+extern _Fcomplex fftfilt_crcf_data_h4x256_x[];
+extern _Fcomplex fftfilt_crcf_data_h4x256_y[];
 
 extern float         fftfilt_crcf_data_h7x256_h[];
-extern float complex fftfilt_crcf_data_h7x256_x[];
-extern float complex fftfilt_crcf_data_h7x256_y[];
+extern _Fcomplex fftfilt_crcf_data_h7x256_x[];
+extern _Fcomplex fftfilt_crcf_data_h7x256_y[];
 
 extern float         fftfilt_crcf_data_h13x256_h[];
-extern float complex fftfilt_crcf_data_h13x256_x[];
-extern float complex fftfilt_crcf_data_h13x256_y[];
+extern _Fcomplex fftfilt_crcf_data_h13x256_x[];
+extern _Fcomplex fftfilt_crcf_data_h13x256_y[];
 
 extern float         fftfilt_crcf_data_h23x256_h[];
-extern float complex fftfilt_crcf_data_h23x256_x[];
-extern float complex fftfilt_crcf_data_h23x256_y[];
+extern _Fcomplex fftfilt_crcf_data_h23x256_x[];
+extern _Fcomplex fftfilt_crcf_data_h23x256_y[];
 
 // cccf
-extern float complex fftfilt_cccf_data_h4x256_h[];
-extern float complex fftfilt_cccf_data_h4x256_x[];
-extern float complex fftfilt_cccf_data_h4x256_y[];
+extern _Fcomplex fftfilt_cccf_data_h4x256_h[];
+extern _Fcomplex fftfilt_cccf_data_h4x256_x[];
+extern _Fcomplex fftfilt_cccf_data_h4x256_y[];
 
-extern float complex fftfilt_cccf_data_h7x256_h[];
-extern float complex fftfilt_cccf_data_h7x256_x[];
-extern float complex fftfilt_cccf_data_h7x256_y[];
+extern _Fcomplex fftfilt_cccf_data_h7x256_h[];
+extern _Fcomplex fftfilt_cccf_data_h7x256_x[];
+extern _Fcomplex fftfilt_cccf_data_h7x256_y[];
 
-extern float complex fftfilt_cccf_data_h13x256_h[];
-extern float complex fftfilt_cccf_data_h13x256_x[];
-extern float complex fftfilt_cccf_data_h13x256_y[];
+extern _Fcomplex fftfilt_cccf_data_h13x256_h[];
+extern _Fcomplex fftfilt_cccf_data_h13x256_x[];
+extern _Fcomplex fftfilt_cccf_data_h13x256_y[];
 
-extern float complex fftfilt_cccf_data_h23x256_h[];
-extern float complex fftfilt_cccf_data_h23x256_x[];
-extern float complex fftfilt_cccf_data_h23x256_y[];
+extern _Fcomplex fftfilt_cccf_data_h23x256_h[];
+extern _Fcomplex fftfilt_cccf_data_h23x256_x[];
+extern _Fcomplex fftfilt_cccf_data_h23x256_y[];
 
 #endif // __LIQUID_FFTFILT_AUTOTEST_H__
-
diff --git a/src/filter/tests/fftfilt_runtest.c b/src/filter/tests/fftfilt_runtest.c
index 5a7377b2..8214a7a5 100644
--- a/src/filter/tests/fftfilt_runtest.c
+++ b/src/filter/tests/fftfilt_runtest.c
@@ -68,7 +68,7 @@ void fftfilt_rrrf_test(float *      _h,
     // compare results
     for (i=0; i<_y_len; i++)
         CONTEND_DELTA( y_test[i], _y[i], tol );
-    
+
     // destroy filter object
     fftfilt_rrrf_destroy(q);
 }
@@ -82,9 +82,9 @@ void fftfilt_rrrf_test(float *      _h,
 //  _y_len  :   output array length
 void fftfilt_crcf_test(float *         _h,
                        unsigned int    _h_len,
-                       float complex * _x,
+                       _Fcomplex * _x,
                        unsigned int    _x_len,
-                       float complex * _y,
+                       _Fcomplex * _y,
                        unsigned int    _y_len)
 {
     float tol = 0.001f;
@@ -105,7 +105,7 @@ void fftfilt_crcf_test(float *         _h,
     fftfilt_crcf q = fftfilt_crcf_create(_h, _h_len, n);
 
     // allocate memory for output
-    float complex y_test[n*num_blocks];
+    _Fcomplex y_test[n*num_blocks];
 
     unsigned int i;
 
@@ -118,7 +118,7 @@ void fftfilt_crcf_test(float *         _h,
         CONTEND_DELTA( crealf(y_test[i]), crealf(_y[i]), tol );
         CONTEND_DELTA( cimagf(y_test[i]), cimagf(_y[i]), tol );
     }
-    
+
     // destroy filter object
     fftfilt_crcf_destroy(q);
 }
@@ -130,11 +130,11 @@ void fftfilt_crcf_test(float *         _h,
 //  _x_len  :   input array length
 //  _y      :   output array
 //  _y_len  :   output array length
-void fftfilt_cccf_test(float complex * _h,
+void fftfilt_cccf_test(_Fcomplex * _h,
                        unsigned int    _h_len,
-                       float complex * _x,
+                       _Fcomplex * _x,
                        unsigned int    _x_len,
-                       float complex * _y,
+                       _Fcomplex * _y,
                        unsigned int    _y_len)
 {
     float tol = 0.001f;
@@ -155,7 +155,7 @@ void fftfilt_cccf_test(float complex * _h,
     fftfilt_cccf q = fftfilt_cccf_create(_h, _h_len, n);
 
     // allocate memory for output
-    float complex y_test[n*num_blocks];
+    _Fcomplex y_test[n*num_blocks];
 
     unsigned int i;
 
@@ -168,8 +168,7 @@ void fftfilt_cccf_test(float complex * _h,
         CONTEND_DELTA( crealf(y_test[i]), crealf(_y[i]), tol );
         CONTEND_DELTA( cimagf(y_test[i]), cimagf(_y[i]), tol );
     }
-    
+
     // destroy filter object
     fftfilt_cccf_destroy(q);
 }
-
diff --git a/src/filter/tests/firdecim_autotest.h b/src/filter/tests/firdecim_autotest.h
index b5993645..50cafd1d 100644
--- a/src/filter/tests/firdecim_autotest.h
+++ b/src/filter/tests/firdecim_autotest.h
@@ -46,20 +46,20 @@ void firdecim_rrrf_test(unsigned int _M,
 void firdecim_crcf_test(unsigned int    _M,
                         float *         _h,
                         unsigned int    _h_len,
-                        float complex * _x,
+                        _Fcomplex * _x,
                         unsigned int    _x_len,
-                        float complex * _y,
+                        _Fcomplex * _y,
                         unsigned int    _y_len);
 
 void firdecim_cccf_test(unsigned int    _M,
-                        float complex * _h,
+                        _Fcomplex * _h,
                         unsigned int    _h_len,
-                        float complex * _x,
+                        _Fcomplex * _x,
                         unsigned int    _x_len,
-                        float complex * _y,
+                        _Fcomplex * _y,
                         unsigned int    _y_len);
 
-// 
+//
 // autotest datasets
 //
 
@@ -82,37 +82,36 @@ extern float         firdecim_rrrf_data_M5h23x50_y[];
 
 // crcf
 extern float         firdecim_crcf_data_M2h4x20_h[];
-extern float complex firdecim_crcf_data_M2h4x20_x[];
-extern float complex firdecim_crcf_data_M2h4x20_y[];
+extern _Fcomplex firdecim_crcf_data_M2h4x20_x[];
+extern _Fcomplex firdecim_crcf_data_M2h4x20_y[];
 
 extern float         firdecim_crcf_data_M3h7x30_h[];
-extern float complex firdecim_crcf_data_M3h7x30_x[];
-extern float complex firdecim_crcf_data_M3h7x30_y[];
+extern _Fcomplex firdecim_crcf_data_M3h7x30_x[];
+extern _Fcomplex firdecim_crcf_data_M3h7x30_y[];
 
 extern float         firdecim_crcf_data_M4h13x40_h[];
-extern float complex firdecim_crcf_data_M4h13x40_x[];
-extern float complex firdecim_crcf_data_M4h13x40_y[];
+extern _Fcomplex firdecim_crcf_data_M4h13x40_x[];
+extern _Fcomplex firdecim_crcf_data_M4h13x40_y[];
 
 extern float         firdecim_crcf_data_M5h23x50_h[];
-extern float complex firdecim_crcf_data_M5h23x50_x[];
-extern float complex firdecim_crcf_data_M5h23x50_y[];
+extern _Fcomplex firdecim_crcf_data_M5h23x50_x[];
+extern _Fcomplex firdecim_crcf_data_M5h23x50_y[];
 
 // cccf
-extern float complex firdecim_cccf_data_M2h4x20_h[];
-extern float complex firdecim_cccf_data_M2h4x20_x[];
-extern float complex firdecim_cccf_data_M2h4x20_y[];
+extern _Fcomplex firdecim_cccf_data_M2h4x20_h[];
+extern _Fcomplex firdecim_cccf_data_M2h4x20_x[];
+extern _Fcomplex firdecim_cccf_data_M2h4x20_y[];
 
-extern float complex firdecim_cccf_data_M3h7x30_h[];
-extern float complex firdecim_cccf_data_M3h7x30_x[];
-extern float complex firdecim_cccf_data_M3h7x30_y[];
+extern _Fcomplex firdecim_cccf_data_M3h7x30_h[];
+extern _Fcomplex firdecim_cccf_data_M3h7x30_x[];
+extern _Fcomplex firdecim_cccf_data_M3h7x30_y[];
 
-extern float complex firdecim_cccf_data_M4h13x40_h[];
-extern float complex firdecim_cccf_data_M4h13x40_x[];
-extern float complex firdecim_cccf_data_M4h13x40_y[];
+extern _Fcomplex firdecim_cccf_data_M4h13x40_h[];
+extern _Fcomplex firdecim_cccf_data_M4h13x40_x[];
+extern _Fcomplex firdecim_cccf_data_M4h13x40_y[];
 
-extern float complex firdecim_cccf_data_M5h23x50_h[];
-extern float complex firdecim_cccf_data_M5h23x50_x[];
-extern float complex firdecim_cccf_data_M5h23x50_y[];
+extern _Fcomplex firdecim_cccf_data_M5h23x50_h[];
+extern _Fcomplex firdecim_cccf_data_M5h23x50_x[];
+extern _Fcomplex firdecim_cccf_data_M5h23x50_y[];
 
 #endif // __LIQUID_FIRDECIM_H__
-
diff --git a/src/filter/tests/firdecim_runtest.c b/src/filter/tests/firdecim_runtest.c
index 6c3a5b86..e0a17064 100644
--- a/src/filter/tests/firdecim_runtest.c
+++ b/src/filter/tests/firdecim_runtest.c
@@ -51,10 +51,10 @@ void firdecim_rrrf_test(unsigned int    _M,
     // compute output
     for (i=0; i<_y_len; i++) {
         firdecim_rrrf_execute(q, &_x[_M*i], &y_test[i]);
-        
+
         CONTEND_DELTA( y_test[i], _y[i], tol );
     }
-    
+
     // destroy decimator object object
     firdecim_rrrf_destroy(q);
 }
@@ -70,9 +70,9 @@ void firdecim_rrrf_test(unsigned int    _M,
 void firdecim_crcf_test(unsigned int    _M,
                         float *         _h,
                         unsigned int    _h_len,
-                        float complex * _x,
+                        _Fcomplex * _x,
                         unsigned int    _x_len,
-                        float complex * _y,
+                        _Fcomplex * _y,
                         unsigned int    _y_len)
 {
     float tol = 0.001f;
@@ -81,17 +81,17 @@ void firdecim_crcf_test(unsigned int    _M,
     firdecim_crcf q = firdecim_crcf_create(_M, _h, _h_len);
 
     // allocate memory for output
-    float complex y_test[_y_len];
+    _Fcomplex y_test[_y_len];
 
     unsigned int i;
     // compute output
     for (i=0; i<_y_len; i++) {
         firdecim_crcf_execute(q, &_x[_M*i], &y_test[i]);
-        
+
         CONTEND_DELTA( crealf(y_test[i]), crealf(_y[i]), tol );
         CONTEND_DELTA( cimagf(y_test[i]), cimagf(_y[i]), tol );
     }
-    
+
     // destroy decimator object object
     firdecim_crcf_destroy(q);
 }
@@ -105,11 +105,11 @@ void firdecim_crcf_test(unsigned int    _M,
 //  _y      :   output array
 //  _y_len  :   output array length
 void firdecim_cccf_test(unsigned int    _M,
-                        float complex * _h,
+                        _Fcomplex * _h,
                         unsigned int    _h_len,
-                        float complex * _x,
+                        _Fcomplex * _x,
                         unsigned int    _x_len,
-                        float complex * _y,
+                        _Fcomplex * _y,
                         unsigned int    _y_len)
 {
     float tol = 0.001f;
@@ -118,18 +118,17 @@ void firdecim_cccf_test(unsigned int    _M,
     firdecim_cccf q = firdecim_cccf_create(_M, _h, _h_len);
 
     // allocate memory for output
-    float complex y_test[_y_len];
+    _Fcomplex y_test[_y_len];
 
     unsigned int i;
     // compute output
     for (i=0; i<_y_len; i++) {
         firdecim_cccf_execute(q, &_x[_M*i], &y_test[i]);
-        
+
         CONTEND_DELTA( crealf(y_test[i]), crealf(_y[i]), tol );
         CONTEND_DELTA( cimagf(y_test[i]), cimagf(_y[i]), tol );
     }
-    
+
     // destroy decimator object object
     firdecim_cccf_destroy(q);
 }
-
diff --git a/src/filter/tests/firdes_autotest.c b/src/filter/tests/firdes_autotest.c
index a2a4ab04..faf4c0cd 100644
--- a/src/filter/tests/firdes_autotest.c
+++ b/src/filter/tests/firdes_autotest.c
@@ -65,19 +65,19 @@ void autotest_liquid_firdes_rrcos() {
 
     // Initialize pre-determined coefficient array
     float h0[13] = {
-       -3.311577E-02, 
-        4.501582E-02, 
-        5.659688E-02, 
-       -1.536039E-01, 
-       -7.500154E-02, 
-        6.153450E-01, 
-        1.081972E+00, 
-        6.153450E-01, 
-       -7.500154E-02, 
-       -1.536039E-01, 
-        5.659688E-02, 
+       -3.311577E-02,
         4.501582E-02,
-       -3.311577E-02}; 
+        5.659688E-02,
+       -1.536039E-01,
+       -7.500154E-02,
+        6.153450E-01,
+        1.081972E+00,
+        6.153450E-01,
+       -7.500154E-02,
+       -1.536039E-01,
+        5.659688E-02,
+        4.501582E-02,
+       -3.311577E-02};
 
     // Create filter
     float h[13];
@@ -130,8 +130,8 @@ void autotest_liquid_firdes_dcblock()
 
     // compute filter response and evaluate at several frequencies
     unsigned int  nfft = 1200;
-    float complex buf_time[nfft];
-    float complex buf_freq[nfft];
+    _Fcomplex buf_time[nfft];
+    _Fcomplex buf_freq[nfft];
     unsigned int i;
     for (i=0; i<nfft; i++)
         buf_time[i] = i < h_len ? h[i] : 0;
@@ -159,8 +159,8 @@ void autotest_liquid_firdes_notch()
 
     // compute filter response and evaluate at several frequencies
     unsigned int  nfft = 1200;
-    float complex buf_time[nfft];
-    float complex buf_freq[nfft];
+    _Fcomplex buf_time[nfft];
+    _Fcomplex buf_freq[nfft];
     unsigned int i;
     for (i=0; i<nfft; i++)
         buf_time[i] = i < h_len ? h[i] : 0;
@@ -177,5 +177,3 @@ void autotest_liquid_firdes_notch()
     CONTEND_DELTA(cabsf(buf_freq[     0]), 1.0f, tol);   // pass at  0
     CONTEND_DELTA(cabsf(buf_freq[nfft/2]), 1.0f, tol);   // pass at  Fs/2
 }
-
-
diff --git a/src/filter/tests/firfilt_autotest.h b/src/filter/tests/firfilt_autotest.h
index d3d980b8..cbc9149e 100644
--- a/src/filter/tests/firfilt_autotest.h
+++ b/src/filter/tests/firfilt_autotest.h
@@ -43,19 +43,19 @@ void firfilt_rrrf_test(float *      _h,
 
 void firfilt_crcf_test(float *         _h,
                        unsigned int    _h_len,
-                       float complex * _x,
+                       _Fcomplex * _x,
                        unsigned int    _x_len,
-                       float complex * _y,
+                       _Fcomplex * _y,
                        unsigned int    _y_len);
 
-void firfilt_cccf_test(float complex * _h,
+void firfilt_cccf_test(_Fcomplex * _h,
                        unsigned int    _h_len,
-                       float complex * _x,
+                       _Fcomplex * _x,
                        unsigned int    _x_len,
-                       float complex * _y,
+                       _Fcomplex * _y,
                        unsigned int    _y_len);
 
-// 
+//
 // autotest datasets
 //
 
@@ -78,37 +78,36 @@ extern float         firfilt_rrrf_data_h23x64_y[];
 
 // crcf
 extern float         firfilt_crcf_data_h4x8_h[];
-extern float complex firfilt_crcf_data_h4x8_x[];
-extern float complex firfilt_crcf_data_h4x8_y[];
+extern _Fcomplex firfilt_crcf_data_h4x8_x[];
+extern _Fcomplex firfilt_crcf_data_h4x8_y[];
 
 extern float         firfilt_crcf_data_h7x16_h[];
-extern float complex firfilt_crcf_data_h7x16_x[];
-extern float complex firfilt_crcf_data_h7x16_y[];
+extern _Fcomplex firfilt_crcf_data_h7x16_x[];
+extern _Fcomplex firfilt_crcf_data_h7x16_y[];
 
 extern float         firfilt_crcf_data_h13x32_h[];
-extern float complex firfilt_crcf_data_h13x32_x[];
-extern float complex firfilt_crcf_data_h13x32_y[];
+extern _Fcomplex firfilt_crcf_data_h13x32_x[];
+extern _Fcomplex firfilt_crcf_data_h13x32_y[];
 
 extern float         firfilt_crcf_data_h23x64_h[];
-extern float complex firfilt_crcf_data_h23x64_x[];
-extern float complex firfilt_crcf_data_h23x64_y[];
+extern _Fcomplex firfilt_crcf_data_h23x64_x[];
+extern _Fcomplex firfilt_crcf_data_h23x64_y[];
 
 // cccf
-extern float complex firfilt_cccf_data_h4x8_h[];
-extern float complex firfilt_cccf_data_h4x8_x[];
-extern float complex firfilt_cccf_data_h4x8_y[];
+extern _Fcomplex firfilt_cccf_data_h4x8_h[];
+extern _Fcomplex firfilt_cccf_data_h4x8_x[];
+extern _Fcomplex firfilt_cccf_data_h4x8_y[];
 
-extern float complex firfilt_cccf_data_h7x16_h[];
-extern float complex firfilt_cccf_data_h7x16_x[];
-extern float complex firfilt_cccf_data_h7x16_y[];
+extern _Fcomplex firfilt_cccf_data_h7x16_h[];
+extern _Fcomplex firfilt_cccf_data_h7x16_x[];
+extern _Fcomplex firfilt_cccf_data_h7x16_y[];
 
-extern float complex firfilt_cccf_data_h13x32_h[];
-extern float complex firfilt_cccf_data_h13x32_x[];
-extern float complex firfilt_cccf_data_h13x32_y[];
+extern _Fcomplex firfilt_cccf_data_h13x32_h[];
+extern _Fcomplex firfilt_cccf_data_h13x32_x[];
+extern _Fcomplex firfilt_cccf_data_h13x32_y[];
 
-extern float complex firfilt_cccf_data_h23x64_h[];
-extern float complex firfilt_cccf_data_h23x64_x[];
-extern float complex firfilt_cccf_data_h23x64_y[];
+extern _Fcomplex firfilt_cccf_data_h23x64_h[];
+extern _Fcomplex firfilt_cccf_data_h23x64_x[];
+extern _Fcomplex firfilt_cccf_data_h23x64_y[];
 
 #endif // __LIQUID_FIRFILT_H__
-
diff --git a/src/filter/tests/firfilt_cccf_notch_autotest.c b/src/filter/tests/firfilt_cccf_notch_autotest.c
index 235e2fc8..f7149d0e 100644
--- a/src/filter/tests/firfilt_cccf_notch_autotest.c
+++ b/src/filter/tests/firfilt_cccf_notch_autotest.c
@@ -41,10 +41,10 @@ void firfilt_cccf_notch_test_harness(unsigned int _m,
     float y2 = 0.0f;
     for (i=0; i<num_samples+h_len; i++) {
         // compute input: tone at f0
-        float complex x = cexpf(_Complex_I*2*M_PI*_f0*i);
+        _Fcomplex x = cexpf(_Complex_I*2*M_PI*_f0*i);
 
         // filter input
-        float complex y;
+        _Fcomplex y;
         firfilt_cccf_push   (q,  x);
         firfilt_cccf_execute(q, &y);
 
@@ -70,11 +70,10 @@ void firfilt_cccf_notch_test_harness(unsigned int _m,
     firfilt_cccf_destroy(q);
 }
 
-// AUTOTESTS: 
+// AUTOTESTS:
 void autotest_firfilt_cccf_notch_0() { firfilt_cccf_notch_test_harness(20,60.0f, 0.000f); }
 void autotest_firfilt_cccf_notch_1() { firfilt_cccf_notch_test_harness(20,60.0f, 0.100f); }
 void autotest_firfilt_cccf_notch_2() { firfilt_cccf_notch_test_harness(20,60.0f, 0.456f); }
 void autotest_firfilt_cccf_notch_3() { firfilt_cccf_notch_test_harness(20,60.0f, 0.500f); }
 void autotest_firfilt_cccf_notch_4() { firfilt_cccf_notch_test_harness(20,60.0f,-0.250f); }
 void autotest_firfilt_cccf_notch_5() { firfilt_cccf_notch_test_harness(20,60.0f,-0.389f); }
-
diff --git a/src/filter/tests/firfilt_runtest.c b/src/filter/tests/firfilt_runtest.c
index 4ab75d99..65e12d81 100644
--- a/src/filter/tests/firfilt_runtest.c
+++ b/src/filter/tests/firfilt_runtest.c
@@ -50,7 +50,7 @@ void firfilt_rrrf_test(float *      _h,
     for (i=0; i<_x_len; i++) {
         firfilt_rrrf_push(q, _x[i]);
         firfilt_rrrf_execute(q, &y_test[i]);
-        
+
         CONTEND_DELTA( y_test[i], _y[i], tol );
     }
 
@@ -67,9 +67,9 @@ void firfilt_rrrf_test(float *      _h,
 //  _y_len  :   output array length
 void firfilt_crcf_test(float *         _h,
                        unsigned int    _h_len,
-                       float complex * _x,
+                       _Fcomplex * _x,
                        unsigned int    _x_len,
-                       float complex * _y,
+                       _Fcomplex * _y,
                        unsigned int    _y_len)
 {
     float tol = 0.001f;
@@ -78,18 +78,18 @@ void firfilt_crcf_test(float *         _h,
     firfilt_crcf q = firfilt_crcf_create(_h, _h_len);
 
     // allocate memory for output
-    float complex y_test[_y_len];
+    _Fcomplex y_test[_y_len];
 
     unsigned int i;
     // compute output
     for (i=0; i<_x_len; i++) {
         firfilt_crcf_push(q, _x[i]);
         firfilt_crcf_execute(q, &y_test[i]);
-        
+
         CONTEND_DELTA( crealf(y_test[i]), crealf(_y[i]), tol );
         CONTEND_DELTA( cimagf(y_test[i]), cimagf(_y[i]), tol );
     }
-    
+
     // destroy filter object
     firfilt_crcf_destroy(q);
 }
@@ -101,11 +101,11 @@ void firfilt_crcf_test(float *         _h,
 //  _x_len  :   input array length
 //  _y      :   output array
 //  _y_len  :   output array length
-void firfilt_cccf_test(float complex * _h,
+void firfilt_cccf_test(_Fcomplex * _h,
                        unsigned int    _h_len,
-                       float complex * _x,
+                       _Fcomplex * _x,
                        unsigned int    _x_len,
-                       float complex * _y,
+                       _Fcomplex * _y,
                        unsigned int    _y_len)
 {
     float tol = 0.001f;
@@ -114,19 +114,18 @@ void firfilt_cccf_test(float complex * _h,
     firfilt_cccf q = firfilt_cccf_create(_h, _h_len);
 
     // allocate memory for output
-    float complex y_test[_y_len];
+    _Fcomplex y_test[_y_len];
 
     unsigned int i;
     // compute output
     for (i=0; i<_x_len; i++) {
         firfilt_cccf_push(q, _x[i]);
         firfilt_cccf_execute(q, &y_test[i]);
-        
+
         CONTEND_DELTA( crealf(y_test[i]), crealf(_y[i]), tol );
         CONTEND_DELTA( cimagf(y_test[i]), cimagf(_y[i]), tol );
     }
-    
+
     // destroy filter object
     firfilt_cccf_destroy(q);
 }
-
diff --git a/src/filter/tests/firhilb_autotest.c b/src/filter/tests/firhilb_autotest.c
index 28e1242d..ef7c3493 100644
--- a/src/filter/tests/firhilb_autotest.c
+++ b/src/filter/tests/firhilb_autotest.c
@@ -37,14 +37,14 @@ void autotest_firhilbf_decim()
          1.0000,  0.7071, -0.0000, -0.7071, -1.0000, -0.7071, -0.0000,  0.7071
     };
 
-    float complex test[16] = {
+    _Fcomplex test[16] = {
          0.0000+J*-0.0055, -0.0000+J* 0.0231,  0.0000+J*-0.0605, -0.0000+J* 0.1459,
          0.0000+J*-0.5604, -0.7071+J*-0.7669, -0.7071+J* 0.7294,  0.7071+J* 0.7008,
          0.7071+J*-0.7064, -0.7071+J*-0.7064, -0.7071+J* 0.7064,  0.7071+J* 0.7064,
          0.7071+J*-0.7064, -0.7071+J*-0.7064, -0.7071+J* 0.7064,  0.7071+J* 0.7064
     };
 
-    float complex y[16];
+    _Fcomplex y[16];
     unsigned int m=5;   // h_len = 4*m+1 = 21
     firhilbf ht = firhilbf_create(m,60.0f);
     float tol=0.005f;
@@ -75,7 +75,7 @@ void autotest_firhilbf_decim()
 //
 void autotest_firhilbf_interp()
 {
-    float complex x[16] = {
+    _Fcomplex x[16] = {
          1.0000+J* 0.0000, -0.0000+J*-1.0000, -1.0000+J* 0.0000,  0.0000+J* 1.0000,
          1.0000+J*-0.0000, -0.0000+J*-1.0000, -1.0000+J* 0.0000,  0.0000+J* 1.0000,
          1.0000+J*-0.0000, -0.0000+J*-1.0000, -1.0000+J* 0.0000,  0.0000+J* 1.0000,
@@ -114,4 +114,3 @@ void autotest_firhilbf_interp()
     // clean up filter object
     firhilbf_destroy(ht);
 }
-
diff --git a/src/filter/tests/firinterp_autotest.c b/src/filter/tests/firinterp_autotest.c
index 0509401f..02857a0a 100644
--- a/src/filter/tests/firinterp_autotest.c
+++ b/src/filter/tests/firinterp_autotest.c
@@ -24,7 +24,7 @@
 #include "liquid.h"
 
 //
-// AUTOTEST: 
+// AUTOTEST:
 //
 void autotest_firinterp_rrrf_generic()
 {
@@ -100,18 +100,18 @@ void autotest_firinterp_crcf_generic()
     firinterp_crcf q = firinterp_crcf_create(M,h,9);
 
     //  x = [1+j*0.2, -0.2+j*1.3, 0.5+j*0.3, 1.1-j*0.2]
-    float complex x[4] = {
-      1.0000e+00+  2.0000e-01*_Complex_I, 
-     -2.0000e-01+  1.3000e+00*_Complex_I, 
-      5.0000e-01+  3.0000e-01*_Complex_I, 
+    _Fcomplex x[4] = {
+      1.0000e+00+  2.0000e-01*_Complex_I,
+     -2.0000e-01+  1.3000e+00*_Complex_I,
+      5.0000e-01+  3.0000e-01*_Complex_I,
       1.1000e+00+ -2.0000e-01*_Complex_I
     };
-        
-    float complex y[16];
+
+    _Fcomplex y[16];
 
     // z = [x(1) 0 0 0 x(2) 0 0 0 x(3) 0 0 0 x(4) 0 0 0];
     // test = filter(h,1,z)
-    float complex test[16] = {
+    _Fcomplex test[16] = {
       -0.7393353832652201 - 0.1478670766530440*_Complex_I,
        0.1909821993029451 + 0.0381964398605890*_Complex_I,
       -1.7013834621383086 - 0.3402766924276617*_Complex_I,
@@ -149,4 +149,3 @@ void autotest_firinterp_crcf_generic()
     // destroy interpolator object
     firinterp_crcf_destroy(q);
 }
-
diff --git a/src/filter/tests/iirdes_autotest.c b/src/filter/tests/iirdes_autotest.c
index 138497f4..a1674d10 100644
--- a/src/filter/tests/iirdes_autotest.c
+++ b/src/filter/tests/iirdes_autotest.c
@@ -29,7 +29,7 @@
 #include "autotest/autotest.h"
 #include "liquid.internal.h"
 
-// 
+//
 // AUTOTEST : design 2nd-order butterworth filter (design comes
 //            from [Ziemer:1998] Example 9-7, pp. 440--442)
 //
@@ -76,7 +76,7 @@ void autotest_iirdes_butter_2()
     }
 }
 
-// 
+//
 // AUTOTEST : complex pair, n=6
 //
 
@@ -85,7 +85,7 @@ void autotest_iirdes_cplxpair_n6()
     float tol = 1e-8f;
 
     //
-    float complex r[6] = {
+    _Fcomplex r[6] = {
        0.980066577841242 + 0.198669330795061 * _Complex_I,
        5.000000000000000 + 0.000000000000000 * _Complex_I,
       -0.416146836547142 + 0.909297426825682 * _Complex_I,
@@ -94,9 +94,9 @@ void autotest_iirdes_cplxpair_n6()
       -0.416146836547142 - 0.909297426825682 * _Complex_I
     };
 
-    float complex p[6];
+    _Fcomplex p[6];
 
-    float complex ptest[6] = {
+    _Fcomplex ptest[6] = {
       -0.416146836547142 - 0.909297426825682 * _Complex_I,
       -0.416146836547142 + 0.909297426825682 * _Complex_I,
        0.980066577841242 - 0.198669330795061 * _Complex_I,
@@ -128,7 +128,7 @@ void autotest_iirdes_cplxpair_n6()
 }
 
 
-// 
+//
 // AUTOTEST : complex pair, n=20
 //
 
@@ -137,7 +137,7 @@ void autotest_iirdes_cplxpair_n20()
     float tol = 1e-8f;
 
     //
-    float complex r[20] = {
+    _Fcomplex r[20] = {
       -0.340396183901119 + 1.109902927794652 * _Complex_I,
        1.148964416793990 + 0.000000000000000 * _Complex_I,
        0.190037889511651 + 0.597517076404221 * _Complex_I,
@@ -160,9 +160,9 @@ void autotest_iirdes_cplxpair_n20()
       -0.089598596934739 + 0.000000000000000 * _Complex_I
     };
 
-    float complex p[20];
+    _Fcomplex p[20];
 
-    float complex ptest[20] = {
+    _Fcomplex ptest[20] = {
       -0.485244526317243 - 0.452251520655749 * _Complex_I,
       -0.485244526317243 + 0.452251520655749 * _Complex_I,
       -0.340396183901119 - 1.109902927794652 * _Complex_I,
@@ -207,8 +207,8 @@ void autotest_iirdes_cplxpair_n20()
     }
 }
 
-// 
-// AUTOTEST : 
+//
+// AUTOTEST :
 //
 void autotest_iirdes_dzpk2sosf()
 {
@@ -220,14 +220,14 @@ void autotest_iirdes_dzpk2sosf()
     float B[3*L];
     float A[3*L];
 
-    float complex za[n];    // analog zeros
-    float complex pa[n];    // analog poles
-    float complex ka;       // analog gain
+    _Fcomplex za[n];    // analog zeros
+    _Fcomplex pa[n];    // analog poles
+    _Fcomplex ka;       // analog gain
     butter_azpkf(n,za,pa,&ka);
 
-    float complex zd[n];    // digital zeros
-    float complex pd[n];    // digital poles
-    float complex kd;       // digital gain
+    _Fcomplex zd[n];    // digital zeros
+    _Fcomplex pd[n];    // digital poles
+    _Fcomplex kd;       // digital gain
     float m = 1 / tanf(M_PI * fc);
     bilinear_zpkf(za,  0,
                   pa,  n,
@@ -257,7 +257,7 @@ void autotest_iirdes_dzpk2sosf()
     }
 }
 
-// 
+//
 // AUTOTEST : iirdes_isstable
 //
 void autotest_iirdes_isstable_n2_yes()
@@ -279,7 +279,7 @@ void autotest_iirdes_isstable_n2_yes()
 }
 
 
-// 
+//
 // AUTOTEST : iirdes_isstable
 //
 void autotest_iirdes_isstable_n2_no()
@@ -297,4 +297,3 @@ void autotest_iirdes_isstable_n2_no()
     int stable = iirdes_isstable(b,a,3);
     CONTEND_EQUALITY( stable, 0 );
 }
-
diff --git a/src/filter/tests/iirfilt_autotest.h b/src/filter/tests/iirfilt_autotest.h
index 17b4cd27..21ed5708 100644
--- a/src/filter/tests/iirfilt_autotest.h
+++ b/src/filter/tests/iirfilt_autotest.h
@@ -46,20 +46,20 @@ void iirfilt_rrrf_test(float *      _b,
 void iirfilt_crcf_test(float *         _b,
                        float *         _a,
                        unsigned int    _h_len,
-                       float complex * _x,
+                       _Fcomplex * _x,
                        unsigned int    _x_len,
-                       float complex * _y,
+                       _Fcomplex * _y,
                        unsigned int    _y_len);
 
-void iirfilt_cccf_test(float complex * _b,
-                       float complex * _a,
+void iirfilt_cccf_test(_Fcomplex * _b,
+                       _Fcomplex * _a,
                        unsigned int    _h_len,
-                       float complex * _x,
+                       _Fcomplex * _x,
                        unsigned int    _x_len,
-                       float complex * _y,
+                       _Fcomplex * _y,
                        unsigned int    _y_len);
 
-// 
+//
 // autotest datasets
 //
 
@@ -82,34 +82,33 @@ extern float         iirfilt_rrrf_data_h7x64_y[];
 // crcf
 extern float         iirfilt_crcf_data_h3x64_b[];
 extern float         iirfilt_crcf_data_h3x64_a[];
-extern float complex iirfilt_crcf_data_h3x64_x[];
-extern float complex iirfilt_crcf_data_h3x64_y[];
+extern _Fcomplex iirfilt_crcf_data_h3x64_x[];
+extern _Fcomplex iirfilt_crcf_data_h3x64_y[];
 
 extern float         iirfilt_crcf_data_h5x64_b[];
 extern float         iirfilt_crcf_data_h5x64_a[];
-extern float complex iirfilt_crcf_data_h5x64_x[];
-extern float complex iirfilt_crcf_data_h5x64_y[];
+extern _Fcomplex iirfilt_crcf_data_h5x64_x[];
+extern _Fcomplex iirfilt_crcf_data_h5x64_y[];
 
 extern float         iirfilt_crcf_data_h7x64_b[];
 extern float         iirfilt_crcf_data_h7x64_a[];
-extern float complex iirfilt_crcf_data_h7x64_x[];
-extern float complex iirfilt_crcf_data_h7x64_y[];
+extern _Fcomplex iirfilt_crcf_data_h7x64_x[];
+extern _Fcomplex iirfilt_crcf_data_h7x64_y[];
 
 // cccf
-extern float complex iirfilt_cccf_data_h3x64_b[];
-extern float complex iirfilt_cccf_data_h3x64_a[];
-extern float complex iirfilt_cccf_data_h3x64_x[];
-extern float complex iirfilt_cccf_data_h3x64_y[];
+extern _Fcomplex iirfilt_cccf_data_h3x64_b[];
+extern _Fcomplex iirfilt_cccf_data_h3x64_a[];
+extern _Fcomplex iirfilt_cccf_data_h3x64_x[];
+extern _Fcomplex iirfilt_cccf_data_h3x64_y[];
 
-extern float complex iirfilt_cccf_data_h5x64_b[];
-extern float complex iirfilt_cccf_data_h5x64_a[];
-extern float complex iirfilt_cccf_data_h5x64_x[];
-extern float complex iirfilt_cccf_data_h5x64_y[];
+extern _Fcomplex iirfilt_cccf_data_h5x64_b[];
+extern _Fcomplex iirfilt_cccf_data_h5x64_a[];
+extern _Fcomplex iirfilt_cccf_data_h5x64_x[];
+extern _Fcomplex iirfilt_cccf_data_h5x64_y[];
 
-extern float complex iirfilt_cccf_data_h7x64_b[];
-extern float complex iirfilt_cccf_data_h7x64_a[];
-extern float complex iirfilt_cccf_data_h7x64_x[];
-extern float complex iirfilt_cccf_data_h7x64_y[];
+extern _Fcomplex iirfilt_cccf_data_h7x64_b[];
+extern _Fcomplex iirfilt_cccf_data_h7x64_a[];
+extern _Fcomplex iirfilt_cccf_data_h7x64_x[];
+extern _Fcomplex iirfilt_cccf_data_h7x64_y[];
 
 #endif // __LIQUID_IIRFILT_H__
-
diff --git a/src/filter/tests/iirfilt_runtest.c b/src/filter/tests/iirfilt_runtest.c
index 9dd30e5c..9be6ea91 100644
--- a/src/filter/tests/iirfilt_runtest.c
+++ b/src/filter/tests/iirfilt_runtest.c
@@ -51,7 +51,7 @@ void iirfilt_rrrf_test(float *      _b,
     // compute output
     for (i=0; i<_x_len; i++) {
         iirfilt_rrrf_execute(q, _x[i], &y_test[i]);
-        
+
         CONTEND_DELTA( y_test[i], _y[i], tol );
     }
 
@@ -70,9 +70,9 @@ void iirfilt_rrrf_test(float *      _b,
 void iirfilt_crcf_test(float *         _b,
                        float *         _a,
                        unsigned int    _h_len,
-                       float complex * _x,
+                       _Fcomplex * _x,
                        unsigned int    _x_len,
-                       float complex * _y,
+                       _Fcomplex * _y,
                        unsigned int    _y_len)
 {
     float tol = 0.001f;
@@ -81,17 +81,17 @@ void iirfilt_crcf_test(float *         _b,
     iirfilt_crcf q = iirfilt_crcf_create(_b, _h_len, _a, _h_len);
 
     // allocate memory for output
-    float complex y_test[_y_len];
+    _Fcomplex y_test[_y_len];
 
     unsigned int i;
     // compute output
     for (i=0; i<_x_len; i++) {
         iirfilt_crcf_execute(q, _x[i], &y_test[i]);
-        
+
         CONTEND_DELTA( crealf(y_test[i]), crealf(_y[i]), tol );
         CONTEND_DELTA( cimagf(y_test[i]), cimagf(_y[i]), tol );
     }
-    
+
     // destroy filter object
     iirfilt_crcf_destroy(q);
 }
@@ -104,12 +104,12 @@ void iirfilt_crcf_test(float *         _b,
 //  _x_len  :   input array length
 //  _y      :   output array
 //  _y_len  :   output array length
-void iirfilt_cccf_test(float complex * _b,
-                       float complex * _a,
+void iirfilt_cccf_test(_Fcomplex * _b,
+                       _Fcomplex * _a,
                        unsigned int    _h_len,
-                       float complex * _x,
+                       _Fcomplex * _x,
                        unsigned int    _x_len,
-                       float complex * _y,
+                       _Fcomplex * _y,
                        unsigned int    _y_len)
 {
     float tol = 0.001f;
@@ -118,18 +118,17 @@ void iirfilt_cccf_test(float complex * _b,
     iirfilt_cccf q = iirfilt_cccf_create(_b, _h_len, _a, _h_len);
 
     // allocate memory for output
-    float complex y_test[_y_len];
+    _Fcomplex y_test[_y_len];
 
     unsigned int i;
     // compute output
     for (i=0; i<_x_len; i++) {
         iirfilt_cccf_execute(q, _x[i], &y_test[i]);
-        
+
         CONTEND_DELTA( crealf(y_test[i]), crealf(_y[i]), tol );
         CONTEND_DELTA( cimagf(y_test[i]), cimagf(_y[i]), tol );
     }
-    
+
     // destroy filter object
     iirfilt_cccf_destroy(q);
 }
-
diff --git a/src/filter/tests/msresamp_crcf_autotest.c b/src/filter/tests/msresamp_crcf_autotest.c
index 897dc3e6..36ec3d88 100644
--- a/src/filter/tests/msresamp_crcf_autotest.c
+++ b/src/filter/tests/msresamp_crcf_autotest.c
@@ -23,7 +23,7 @@
 #include "autotest/autotest.h"
 #include "liquid.h"
 
-// 
+//
 // AUTOTEST : test multi-stage arbitrary resampler
 //
 void autotest_msresamp_crcf()
@@ -46,8 +46,8 @@ void autotest_msresamp_crcf()
     unsigned int y_len = (unsigned int) ceilf(1.1 * nx * r) + 4;
 
     // arrays
-    float complex x[nx];
-    float complex y[y_len];
+    _Fcomplex x[nx];
+    _Fcomplex y[y_len];
 
     // create resampler
     msresamp_crcf q = msresamp_crcf_create(r,As);
@@ -79,7 +79,7 @@ void autotest_msresamp_crcf()
     // clean up allocated objects
     msresamp_crcf_destroy(q);
 
-    // 
+    //
     // analyze resulting signal
     //
 
@@ -90,8 +90,8 @@ void autotest_msresamp_crcf()
     // run FFT and ensure that carrier has moved and that image
     // frequencies and distortion have been adequately suppressed
     unsigned int nfft = 1 << liquid_nextpow2(ny);
-    float complex yfft[nfft];   // fft input
-    float complex Yfft[nfft];   // fft output
+    _Fcomplex yfft[nfft];   // fft input
+    _Fcomplex Yfft[nfft];   // fft output
     for (i=0; i<nfft; i++)
         yfft[i] = i < ny ? y[i] : 0.0f;
     fft_run(nfft, yfft, Yfft, LIQUID_FFT_FORWARD, 0);
diff --git a/src/filter/tests/resamp2_crcf_autotest.c b/src/filter/tests/resamp2_crcf_autotest.c
index bfd5f6f7..d92b5b62 100644
--- a/src/filter/tests/resamp2_crcf_autotest.c
+++ b/src/filter/tests/resamp2_crcf_autotest.c
@@ -23,7 +23,7 @@
 #include "autotest/autotest.h"
 #include "liquid.h"
 
-// 
+//
 // AUTOTEST : test half-band filterbank (analyzer)
 //
 void autotest_resamp2_analysis()
@@ -38,9 +38,9 @@ void autotest_resamp2_analysis()
     unsigned int i;
 
     // allocate memory for data arrays
-    float complex x[2*n+2*m+1]; // input signal (with delay)
-    float complex y0[n];        // low-pass output
-    float complex y1[n];        // high-pass output
+    _Fcomplex x[2*n+2*m+1]; // input signal (with delay)
+    _Fcomplex y0[n];        // low-pass output
+    _Fcomplex y1[n];        // high-pass output
 
     // generate the baseband signal
     for (i=0; i<2*n+2*m+1; i++)
@@ -51,7 +51,7 @@ void autotest_resamp2_analysis()
     resamp2_crcf q = resamp2_crcf_create(m,0,As);
 
     // run half-band decimation
-    float complex y_hat[2];
+    _Fcomplex y_hat[2];
     for (i=0; i<n; i++) {
         resamp2_crcf_analyzer_execute(q, &x[2*i], y_hat);
         y0[i] = y_hat[0];
@@ -99,7 +99,7 @@ void autotest_resamp2_analysis()
 #endif
 }
 
-// 
+//
 // AUTOTEST : test half-band filterbank (synthesizer)
 //
 void autotest_resamp2_synthesis()
@@ -114,9 +114,9 @@ void autotest_resamp2_synthesis()
     unsigned int i;
 
     // allocate memory for data arrays
-    float complex x0[n+2*m+1];  // input signal (with delay)
-    float complex x1[n+2*m+1];  // input signal (with delay)
-    float complex y[2*n];       // synthesized output
+    _Fcomplex x0[n+2*m+1];  // input signal (with delay)
+    _Fcomplex x1[n+2*m+1];  // input signal (with delay)
+    _Fcomplex y[2*n];       // synthesized output
 
     // generate the baseband signals
     for (i=0; i<n+2*m+1; i++) {
@@ -129,7 +129,7 @@ void autotest_resamp2_synthesis()
     resamp2_crcf q = resamp2_crcf_create(m,0,As);
 
     // run synthesis
-    float complex x_hat[2];
+    _Fcomplex x_hat[2];
     for (i=0; i<n; i++) {
         x_hat[0] = x0[i];
         x_hat[1] = x1[i];
diff --git a/src/filter/tests/resamp_crcf_autotest.c b/src/filter/tests/resamp_crcf_autotest.c
index 08cbfd10..f441abb6 100644
--- a/src/filter/tests/resamp_crcf_autotest.c
+++ b/src/filter/tests/resamp_crcf_autotest.c
@@ -23,7 +23,7 @@
 #include "autotest/autotest.h"
 #include "liquid.h"
 
-// 
+//
 // AUTOTEST : test arbitrary resampler
 //
 void autotest_resamp_crcf()
@@ -46,8 +46,8 @@ void autotest_resamp_crcf()
     unsigned int y_len = (unsigned int) ceilf(1.1 * nx * r) + 4;
 
     // arrays
-    float complex x[nx];
-    float complex y[y_len];
+    _Fcomplex x[nx];
+    _Fcomplex y[y_len];
 
     // create resampler
     resamp_crcf q = resamp_crcf_create(r,m,bw,As,npfb);
@@ -79,7 +79,7 @@ void autotest_resamp_crcf()
     // clean up allocated objects
     resamp_crcf_destroy(q);
 
-    // 
+    //
     // analyze resulting signal
     //
 
@@ -90,8 +90,8 @@ void autotest_resamp_crcf()
     // run FFT and ensure that carrier has moved and that image
     // frequencies and distortion have been adequately suppressed
     unsigned int nfft = 1 << liquid_nextpow2(ny);
-    float complex yfft[nfft];   // fft input
-    float complex Yfft[nfft];   // fft output
+    _Fcomplex yfft[nfft];   // fft input
+    _Fcomplex Yfft[nfft];   // fft output
     for (i=0; i<nfft; i++)
         yfft[i] = i < ny ? y[i] : 0.0f;
     fft_run(nfft, yfft, Yfft, LIQUID_FFT_FORWARD, 0);
diff --git a/src/filter/tests/rresamp_crcf_autotest.c b/src/filter/tests/rresamp_crcf_autotest.c
index 487e7270..d1791ee8 100644
--- a/src/filter/tests/rresamp_crcf_autotest.c
+++ b/src/filter/tests/rresamp_crcf_autotest.c
@@ -27,7 +27,7 @@
 #define min(a,b) ((a)<(b)?(a):(b))
 #define max(a,b) ((a)>(b)?(a):(b))
 
-// 
+//
 // AUTOTEST : test rational-rate resampler
 //
 void test_harness_rresamp_crcf(unsigned int _P,
@@ -42,8 +42,8 @@ void test_harness_rresamp_crcf(unsigned int _P,
     unsigned int  nx = n * _Q;  // number of input samples
 
     // buffers
-    float complex x[nx];        // input sample buffer
-    float complex y[ny];        // output sample buffer
+    _Fcomplex x[nx];        // input sample buffer
+    _Fcomplex y[ny];        // output sample buffer
 
     // create resampler
     rresamp_crcf q = rresamp_crcf_create_kaiser(_P, _Q, _m, _bw, _As);
@@ -72,7 +72,7 @@ void test_harness_rresamp_crcf(unsigned int _P,
     // clean up allocated objects
     rresamp_crcf_destroy(q);
 
-    // 
+    //
     // analyze resulting signal
     //
 
@@ -82,8 +82,8 @@ void test_harness_rresamp_crcf(unsigned int _P,
     // run FFT and ensure that carrier has moved and that image
     // frequencies and distortion have been adequately suppressed
     unsigned int nfft = 8192;   // about 1500 max samples
-    float complex yfft[nfft];   // fft input
-    float complex Yfft[nfft];   // fft output
+    _Fcomplex yfft[nfft];   // fft input
+    _Fcomplex Yfft[nfft];   // fft output
     for (i=0; i<nfft; i++)
         yfft[i] = i < ny ? y[i]/(wsum*sqrt(r)) : 0.0f;
     fft_run(nfft, yfft, Yfft, LIQUID_FFT_FORWARD, 0);
@@ -191,4 +191,3 @@ void autotest_rresamp_crcf_P3_Q5() { test_harness_rresamp_crcf( 3, 5, 15, 0.4f,
 void autotest_rresamp_crcf_P6_Q5() { test_harness_rresamp_crcf( 6, 5, 15, 0.4f, 60.0f); }
 void autotest_rresamp_crcf_P8_Q5() { test_harness_rresamp_crcf( 8, 5, 15, 0.4f, 60.0f); }
 void autotest_rresamp_crcf_P9_Q5() { test_harness_rresamp_crcf( 9, 5, 15, 0.4f, 60.0f); }
-
diff --git a/src/filter/tests/symsync_crcf_autotest.c b/src/filter/tests/symsync_crcf_autotest.c
index 30383e53..6f22930c 100644
--- a/src/filter/tests/symsync_crcf_autotest.c
+++ b/src/filter/tests/symsync_crcf_autotest.c
@@ -56,7 +56,7 @@ void symsync_crcf_test(unsigned int _k,
     unsigned int num_symbols = num_symbols_init + num_symbols_test;
     unsigned int num_samples = k*num_symbols;
     unsigned int num_samples_resamp = (unsigned int) ceilf(num_samples*rate*1.1f) + 4;
-    
+
     // compute delay
     while (tau < 0) tau += 1.0f;    // ensure positive tau
     float g = k*tau;                // number of samples offset
@@ -70,10 +70,10 @@ void symsync_crcf_test(unsigned int _k,
     unsigned int i;
 
     // allocate arrays
-    float complex s[num_symbols];       // data symbols
-    float complex x[num_samples];       // interpolated samples
-    float complex y[num_samples_resamp];// resampled data (resamp_crcf)
-    float complex z[num_symbols + 64];  // synchronized symbols
+    _Fcomplex s[num_symbols];       // data symbols
+    _Fcomplex x[num_samples];       // interpolated samples
+    _Fcomplex y[num_samples_resamp];// resampled data (resamp_crcf)
+    _Fcomplex z[num_symbols + 64];  // synchronized symbols
 
     // generate pseudo-random QPSK symbols
     // NOTE: by using an m-sequence generator this sequence will be identical
@@ -87,7 +87,7 @@ void symsync_crcf_test(unsigned int _k,
     }
     msequence_destroy(ms);
 
-    // 
+    //
     // create and run interpolator
     //
 
@@ -100,7 +100,7 @@ void symsync_crcf_test(unsigned int _k,
     // destroy interpolator
     firinterp_crcf_destroy(interp);
 
-    // 
+    //
     // run resampler
     //
 
@@ -118,7 +118,7 @@ void symsync_crcf_test(unsigned int _k,
     // destroy resampler
     resamp_crcf_destroy(resamp);
 
-    // 
+    //
     // create and run symbol synchronizer
     //
 
@@ -153,7 +153,7 @@ void symsync_crcf_test(unsigned int _k,
     for (i=nz-num_symbols_test; i<nz; i++) {
         // compute error
         float err = cabsf( z[i] - s[i-delay] );
-        
+
         // assert that error is below tolerance
         CONTEND_LESS_THAN( err, tol );
 
@@ -174,4 +174,3 @@ void autotest_symsync_crcf_scenario_0() { symsync_crcf_test(2, 7, 0.35,  0.00, 1
 void autotest_symsync_crcf_scenario_1() { symsync_crcf_test(2, 7, 0.35, -0.25, 1.0f    ); }
 void autotest_symsync_crcf_scenario_2() { symsync_crcf_test(2, 7, 0.35, -0.25, 1.0001f ); }
 void autotest_symsync_crcf_scenario_3() { symsync_crcf_test(2, 7, 0.35, -0.25, 0.9999f ); }
-
diff --git a/src/framing/bench/bpresync_benchmark.c b/src/framing/bench/bpresync_benchmark.c
index 5eeb88c0..6c60ab66 100644
--- a/src/framing/bench/bpresync_benchmark.c
+++ b/src/framing/bench/bpresync_benchmark.c
@@ -40,7 +40,7 @@ void bpresync_cccf_bench(struct rusage *     _start,
     *_num_iterations /= _m;
 
     // generate sequence (random)
-    float complex h[_n];
+    _Fcomplex h[_n];
     unsigned long int i;
     for (i=0; i<_n; i++) {
         h[i] = (rand() % 2 ? 1.0f : -1.0f) +
@@ -51,13 +51,13 @@ void bpresync_cccf_bench(struct rusage *     _start,
     bpresync_cccf q = bpresync_cccf_create(h, _n, 0.1f, _m);
 
     // input sequence (random)
-    float complex x[7];
+    _Fcomplex x[7];
     for (i=0; i<7; i++) {
         x[i] = (rand() % 2 ? 1.0f : -1.0f) +
                (rand() % 2 ? 1.0f : -1.0f)*_Complex_I;
     }
 
-    float complex rxy;
+    _Fcomplex rxy;
     float dphi_hat;
 
     // start trials
@@ -90,4 +90,3 @@ void benchmark_bpresync_cccf_32   BPRESYNC_CCCF_BENCHMARK_API(32,   6);
 void benchmark_bpresync_cccf_64   BPRESYNC_CCCF_BENCHMARK_API(64,   6);
 void benchmark_bpresync_cccf_128  BPRESYNC_CCCF_BENCHMARK_API(128,  6);
 void benchmark_bpresync_cccf_256  BPRESYNC_CCCF_BENCHMARK_API(256,  6);
-
diff --git a/src/framing/bench/bsync_benchmark.c b/src/framing/bench/bsync_benchmark.c
index eca86d75..2a9a22f3 100644
--- a/src/framing/bench/bsync_benchmark.c
+++ b/src/framing/bench/bsync_benchmark.c
@@ -38,7 +38,7 @@ void bsync_cccf_bench(struct rusage *     _start,
     *_num_iterations /= _n;
 
     // generate sequence (random)
-    float complex h[_n];
+    _Fcomplex h[_n];
     unsigned long int i;
     for (i=0; i<_n; i++) {
         h[i] = (rand() % 2 ? 1.0f : -1.0f) +
@@ -49,13 +49,13 @@ void bsync_cccf_bench(struct rusage *     _start,
     bsync_cccf q = bsync_cccf_create(_n,h);
 
     // input sequence (random)
-    float complex x[7];
+    _Fcomplex x[7];
     for (i=0; i<7; i++) {
         x[i] = (rand() % 2 ? 1.0f : -1.0f) +
                (rand() % 2 ? 1.0f : -1.0f)*_Complex_I;
     }
 
-    float complex rxy;
+    _Fcomplex rxy;
 
     // start trials
     getrusage(RUSAGE_SELF, _start);
@@ -87,4 +87,3 @@ void benchmark_bsync_cccf_32   BSYNC_CCCF_BENCHMARK_API(32)
 void benchmark_bsync_cccf_64   BSYNC_CCCF_BENCHMARK_API(64)
 void benchmark_bsync_cccf_128  BSYNC_CCCF_BENCHMARK_API(128)
 void benchmark_bsync_cccf_256  BSYNC_CCCF_BENCHMARK_API(256)
-
diff --git a/src/framing/bench/detector_benchmark.c b/src/framing/bench/detector_benchmark.c
index 1024108c..29988e0c 100644
--- a/src/framing/bench/detector_benchmark.c
+++ b/src/framing/bench/detector_benchmark.c
@@ -38,7 +38,7 @@ void detector_cccf_bench(struct rusage *     _start,
     *_num_iterations /= _n;
 
     // generate sequence (random)
-    float complex h[_n];
+    _Fcomplex h[_n];
     unsigned long int i;
     for (i=0; i<_n; i++) {
         h[i] = (rand() % 2 ? 1.0f : -1.0f) +
@@ -51,7 +51,7 @@ void detector_cccf_bench(struct rusage *     _start,
     detector_cccf q = detector_cccf_create(h, _n, threshold, dphi_max);
 
     // input sequence (random)
-    float complex x[7];
+    _Fcomplex x[7];
     for (i=0; i<7; i++) {
         x[i] = (rand() % 2 ? 1.0f : -1.0f) +
                (rand() % 2 ? 1.0f : -1.0f)*_Complex_I;
@@ -92,4 +92,3 @@ void benchmark_detector_cccf_32   DETECTOR_CCCF_BENCHMARK_API(32);
 void benchmark_detector_cccf_64   DETECTOR_CCCF_BENCHMARK_API(64);
 void benchmark_detector_cccf_128  DETECTOR_CCCF_BENCHMARK_API(128);
 void benchmark_detector_cccf_256  DETECTOR_CCCF_BENCHMARK_API(256);
-
diff --git a/src/framing/bench/flexframesync_benchmark.c b/src/framing/bench/flexframesync_benchmark.c
index 611bc5a3..39665c65 100644
--- a/src/framing/bench/flexframesync_benchmark.c
+++ b/src/framing/bench/flexframesync_benchmark.c
@@ -97,7 +97,7 @@ void benchmark_flexframesync(
     // generate the frame
     flexframegen_assemble(fg, header, payload, payload_len);
     unsigned int frame_len = flexframegen_getframelen(fg);
-    float complex frame[frame_len];
+    _Fcomplex frame[frame_len];
     int frame_complete = 0;
     while (!frame_complete) {
         frame_complete = flexframegen_write_samples(fg, frame, frame_len);
@@ -106,7 +106,7 @@ void benchmark_flexframesync(
     for (i=0; i<frame_len; i++)
         frame[i] += 0.02f*(randnf() + _Complex_I*randnf());
 
-    // 
+    //
     // start trials
     //
     getrusage(RUSAGE_SELF, _start);
@@ -127,4 +127,3 @@ void benchmark_flexframesync(
     flexframegen_destroy(fg);
     flexframesync_destroy(fs);
 }
-
diff --git a/src/framing/bench/framesync64_benchmark.c b/src/framing/bench/framesync64_benchmark.c
index 8032eba8..0ac46ed0 100644
--- a/src/framing/bench/framesync64_benchmark.c
+++ b/src/framing/bench/framesync64_benchmark.c
@@ -74,14 +74,14 @@ void benchmark_framesync64(
     // generate the frame
     //unsigned int frame_len = framegen64_getframelen(fg);
     unsigned int frame_len = LIQUID_FRAME64_LEN;
-    float complex frame[frame_len];
+    _Fcomplex frame[frame_len];
     framegen64_execute(fg, header, payload, frame);
 
     // add some noise
     for (i=0; i<frame_len; i++)
         frame[i] += 0.01f*(randnf() + _Complex_I*randnf()) * M_SQRT1_2;
 
-    // 
+    //
     // start trials
     //
     getrusage(RUSAGE_SELF, _start);
@@ -100,4 +100,3 @@ void benchmark_framesync64(
     framegen64_destroy(fg);
     framesync64_destroy(fs);
 }
-
diff --git a/src/framing/bench/gmskframesync_benchmark.c b/src/framing/bench/gmskframesync_benchmark.c
index b8f70d3d..213616d4 100644
--- a/src/framing/bench/gmskframesync_benchmark.c
+++ b/src/framing/bench/gmskframesync_benchmark.c
@@ -101,7 +101,7 @@ void benchmark_gmskframesync(struct rusage *     _start,
     gmskframegen_assemble(fg, header, payload, payload_len, check, fec0, fec1);
     gmskframegen_print(fg);
     unsigned int frame_len = gmskframegen_getframelen(fg);
-    float complex frame[frame_len];
+    _Fcomplex frame[frame_len];
     int frame_complete = 0;
     unsigned int n=0;
     while (!frame_complete) {
@@ -113,7 +113,7 @@ void benchmark_gmskframesync(struct rusage *     _start,
     for (i=0; i<frame_len; i++)
         frame[i] += nstd*(randnf() + _Complex_I*randnf());
 
-    // 
+    //
     // start trials
     //
     getrusage(RUSAGE_SELF, _start);
@@ -155,11 +155,11 @@ void benchmark_gmskframesync_noise(struct rusage *     _start,
 
     // allocate memory for noise buffer and initialize
     unsigned int num_samples = 1024;
-    float complex y[num_samples];
+    _Fcomplex y[num_samples];
     for (i=0; i<num_samples; i++)
         y[i] = nstd*(randnf() + randnf()*_Complex_I)*M_SQRT1_2;
 
-    // 
+    //
     // start trials
     //
     getrusage(RUSAGE_SELF, _start);
@@ -175,4 +175,3 @@ void benchmark_gmskframesync_noise(struct rusage *     _start,
     // destroy framing objects
     gmskframesync_destroy(fs);
 }
-
diff --git a/src/framing/bench/presync_benchmark.c b/src/framing/bench/presync_benchmark.c
index 7a41516d..8c202e40 100644
--- a/src/framing/bench/presync_benchmark.c
+++ b/src/framing/bench/presync_benchmark.c
@@ -40,7 +40,7 @@ void presync_cccf_bench(struct rusage *     _start,
     *_num_iterations /= _m;
 
     // generate sequence (random)
-    float complex h[_n];
+    _Fcomplex h[_n];
     unsigned long int i;
     for (i=0; i<_n; i++) {
         h[i] = (rand() % 2 ? 1.0f : -1.0f) +
@@ -51,13 +51,13 @@ void presync_cccf_bench(struct rusage *     _start,
     presync_cccf q = presync_cccf_create(h, _n, 0.1f, _m);
 
     // input sequence (random)
-    float complex x[7];
+    _Fcomplex x[7];
     for (i=0; i<7; i++) {
         x[i] = (rand() % 2 ? 1.0f : -1.0f) +
                (rand() % 2 ? 1.0f : -1.0f)*_Complex_I;
     }
 
-    float complex rxy;
+    _Fcomplex rxy;
     float dphi_hat;
 
     // start trials
@@ -90,4 +90,3 @@ void benchmark_presync_cccf_32   PRESYNC_CCCF_BENCHMARK_API(32,   6);
 void benchmark_presync_cccf_64   PRESYNC_CCCF_BENCHMARK_API(64,   6);
 void benchmark_presync_cccf_128  PRESYNC_CCCF_BENCHMARK_API(128,  6);
 void benchmark_presync_cccf_256  PRESYNC_CCCF_BENCHMARK_API(256,  6);
-
diff --git a/src/framing/bench/qdetector_benchmark.c b/src/framing/bench/qdetector_benchmark.c
index c9965bea..61357a1b 100644
--- a/src/framing/bench/qdetector_benchmark.c
+++ b/src/framing/bench/qdetector_benchmark.c
@@ -38,7 +38,7 @@ void qdetector_cccf_bench(struct rusage *     _start,
     *_num_iterations /= _n;
 
     // generate sequence (random)
-    float complex h[_n];
+    _Fcomplex h[_n];
     unsigned long int i;
     for (i=0; i<_n; i++) {
         h[i] = (rand() % 2 ? 1.0f : -1.0f) +
@@ -57,7 +57,7 @@ void qdetector_cccf_bench(struct rusage *     _start,
     qdetector_cccf_set_range    (q, range);
 
     // input sequence (random)
-    float complex x[7];
+    _Fcomplex x[7];
     for (i=0; i<7; i++) {
         x[i] = (rand() % 2 ? 1.0f : -1.0f) +
                (rand() % 2 ? 1.0f : -1.0f)*_Complex_I;
@@ -94,4 +94,3 @@ void benchmark_qdetector_cccf_32   QDETECTOR_CCCF_BENCHMARK_API(32);
 void benchmark_qdetector_cccf_64   QDETECTOR_CCCF_BENCHMARK_API(64);
 void benchmark_qdetector_cccf_128  QDETECTOR_CCCF_BENCHMARK_API(128);
 void benchmark_qdetector_cccf_256  QDETECTOR_CCCF_BENCHMARK_API(256);
-
diff --git a/src/framing/src/bpresync.c b/src/framing/src/bpresync.c
index 216453da..9f58c549 100644
--- a/src/framing/src/bpresync.c
+++ b/src/framing/src/bpresync.c
@@ -34,10 +34,10 @@
 struct BPRESYNC(_s) {
     unsigned int n;     // sequence length
     unsigned int m;     // number of binary synchronizers
-    
+
     bsequence rx_i;     // received pattern (in-phase)
     bsequence rx_q;     // received pattern (quadrature)
-    
+
     float * dphi;       // array of frequency offsets [size: m x 1]
     bsequence * sync_i; // synchronization pattern (in-phase)
     bsequence * sync_q; // synchronization pattern (quadrature)
@@ -54,8 +54,8 @@ struct BPRESYNC(_s) {
 //  _rxy1   : negative frequency correlation output (conjugated)
 void BPRESYNC(_correlatex)(BPRESYNC()      _q,
                            unsigned int    _id,
-                           float complex * _rxy0,
-                           float complex * _rxy1);
+                           _Fcomplex * _rxy0,
+                           _Fcomplex * _rxy1);
 
 // create binary pre-demod synchronizer
 //  _v          :   baseband sequence
@@ -180,10 +180,10 @@ void BPRESYNC(_execute)(BPRESYNC() _q,
                         float *    _dphi_hat)
 {
     unsigned int i;
-    float complex rxy_max = 0;  // maximum cross-correlation
+    _Fcomplex rxy_max = 0;  // maximum cross-correlation
     float abs_rxy_max = 0;      // absolute value of rxy_max
-    float complex rxy0;
-    float complex rxy1;
+    _Fcomplex rxy0;
+    _Fcomplex rxy1;
     float dphi_hat = 0.0f;
     for (i=0; i<_q->m; i++)  {
 
@@ -219,8 +219,8 @@ void BPRESYNC(_execute)(BPRESYNC() _q,
 //  _rxy1   : negative frequency correlation output (conjugated)
 void BPRESYNC(_correlatex)(BPRESYNC()      _q,
                            unsigned int    _id,
-                           float complex * _rxy0,
-                           float complex * _rxy1)
+                           _Fcomplex * _rxy0,
+                           _Fcomplex * _rxy1)
 {
     // validate input...
     if (_id >= _q->m) {
@@ -244,4 +244,3 @@ void BPRESYNC(_correlatex)(BPRESYNC()      _q,
     int rxy_q1 = rxy_iq - rxy_qi;
     *_rxy1 = (rxy_i1 + rxy_q1 * _Complex_I) * _q->n_inv;
 }
-
diff --git a/src/framing/src/bpresync_cccf.c b/src/framing/src/bpresync_cccf.c
index fa58482f..5159e4f4 100644
--- a/src/framing/src/bpresync_cccf.c
+++ b/src/framing/src/bpresync_cccf.c
@@ -26,7 +26,7 @@
 
 #include "liquid.internal.h"
 
-// 
+//
 #define BPRESYNC(name)      LIQUID_CONCAT(bpresync_cccf,name)
 
 // print and naming extensions
@@ -34,9 +34,9 @@
 #define EXTENSION_SHORT     "f"
 #define EXTENSION_FULL      "cccf"
 
-#define TO                  float complex
-#define TC                  float complex
-#define TI                  float complex
+#define TO                  _Fcomplex
+#define TC                  _Fcomplex
+#define TI                  _Fcomplex
 
 #define ABS(X)              cabsf(X)
 #define REAL(X)             crealf(X)
@@ -50,4 +50,3 @@
 
 // source files
 #include "bpresync.c"
-
diff --git a/src/framing/src/bsync_cccf.c b/src/framing/src/bsync_cccf.c
index 2073075a..3942ef4d 100644
--- a/src/framing/src/bsync_cccf.c
+++ b/src/framing/src/bsync_cccf.c
@@ -26,14 +26,14 @@
 
 #include "liquid.internal.h"
 
-// 
+//
 #define BSYNC(name)         LIQUID_CONCAT(bsync_cccf,name)
 
 #define PRINTVAL(x)         printf("%12.4e + j%12.4e", crealf(x), cimagf(x))
 
-#define TO                  float complex
-#define TC                  float complex
-#define TI                  float complex
+#define TO                  _Fcomplex
+#define TC                  _Fcomplex
+#define TI                  _Fcomplex
 #define ABS(X)              cabsf(X)
 #define WINDOW(name)        LIQUID_CONCAT(windowcf,name)
 #define DOTPROD(name)       LIQUID_CONCAT(dotprod_cccf,name)
@@ -44,4 +44,3 @@
 
 // source files
 #include "bsync.c"
-
diff --git a/src/framing/src/bsync_crcf.c b/src/framing/src/bsync_crcf.c
index 087adb63..50ea68e9 100644
--- a/src/framing/src/bsync_crcf.c
+++ b/src/framing/src/bsync_crcf.c
@@ -26,14 +26,14 @@
 
 #include "liquid.internal.h"
 
-// 
+//
 #define BSYNC(name)         LIQUID_CONCAT(bsync_crcf,name)
 
 #define PRINTVAL(x)         printf("%12.4e + j%12.4e", crealf(x), cimagf(x))
 
-#define TO                  float complex
+#define TO                  _Fcomplex
 #define TC                  float
-#define TI                  float complex
+#define TI                  _Fcomplex
 #define ABS(X)              cabsf(X)
 #define WINDOW(name)        LIQUID_CONCAT(windowcf,name)
 #define DOTPROD(name)       LIQUID_CONCAT(dotprod_crcf,name)
@@ -44,4 +44,3 @@
 
 // source files
 #include "bsync.c"
-
diff --git a/src/framing/src/detector_cccf.c b/src/framing/src/detector_cccf.c
index ceb1969d..046c6832 100644
--- a/src/framing/src/detector_cccf.c
+++ b/src/framing/src/detector_cccf.c
@@ -40,13 +40,13 @@
 #define DEBUG_DETECTOR_BUFFER_LEN   (1600)
 #define DEBUG_DETECTOR_FILENAME     "detector_cccf_debug.m"
 
-// 
+//
 // internal method declarations
 //
 
 // update sum{ |x|^2 }
 void detector_cccf_update_sumsq(detector_cccf _q,
-                                float complex _x);
+                                _Fcomplex _x);
 
 // compute all dot product outputs
 void detector_cccf_compute_dotprods(detector_cccf _q);
@@ -61,13 +61,13 @@ void detector_cccf_debug_print(detector_cccf _q,
                                const char *  _filename);
 
 struct detector_cccf_s {
-    float complex * s;      // sequence
+    _Fcomplex * s;      // sequence
     unsigned int n;         // sequence length
     float threshold;        // detection threshold
-    
+
     // derived values
     float n_inv;            // 1/n (pre-computed for speed)
-    
+
     windowcf buffer;        // input buffer
 
     // internal correlators
@@ -106,7 +106,7 @@ struct detector_cccf_s {
 //  _n          :   sequence length
 //  _threshold  :   detection threshold (default: 0.7)
 //  _dphi_max   :   maximum carrier offset
-detector_cccf detector_cccf_create(float complex * _s,
+detector_cccf detector_cccf_create(_Fcomplex * _s,
                                    unsigned int    _n,
                                    float           _threshold,
                                    float           _dphi_max)
@@ -119,7 +119,7 @@ detector_cccf detector_cccf_create(float complex * _s,
         fprintf(stderr,"error: detector_cccf_create(), threshold must be greater than zero (0.6 recommended)\n");
         exit(1);
     }
-    
+
     // allocate memory for main object
     detector_cccf q = (detector_cccf) malloc(sizeof(struct detector_cccf_s));
     unsigned int i;
@@ -135,7 +135,7 @@ detector_cccf detector_cccf_create(float complex * _s,
 
     // compute number of correlators
     q->m = (int) ceilf( fabsf(_dphi_max / q->dphi_step) );
-    
+
     // ensure at least two correlators
     if (q->m < 2)
         q->m = 2;
@@ -144,8 +144,8 @@ detector_cccf detector_cccf_create(float complex * _s,
     q->dphi_max = q->m * q->dphi_step;
 
     // allocate memory for sequence and copy
-    q->s = (float complex*) malloc((q->n)*sizeof(float complex));
-    memmove(q->s, _s, q->n*sizeof(float complex));
+    q->s = (_Fcomplex*) malloc((q->n)*sizeof(_Fcomplex));
+    memmove(q->s, _s, q->n*sizeof(_Fcomplex));
 
     // create internal buffer
     q->buffer = windowcf_create(q->n);
@@ -158,7 +158,7 @@ detector_cccf detector_cccf_create(float complex * _s,
     q->rxy1 = (float*)        malloc((q->m)*sizeof(float));
     q->rxy  = (float*)        malloc((q->m)*sizeof(float));
     unsigned int k;
-    float complex sconj[q->n];
+    _Fcomplex sconj[q->n];
     for (k=0; k<q->m; k++) {
         // pre-spin sequence (slightly over-sampled in frequency)
         q->dphi[k] = ((float)k - (float)(q->m-1)/2) * q->dphi_step;
@@ -231,7 +231,7 @@ void detector_cccf_reset(detector_cccf _q)
     _q->imax    = 0;                    // index of maximum rxy value
     _q->idetect = 0;                    // index of detected maximum
     _q->x2_sum  = 0.0f;                 // sum{ |x|^2 }
-    
+
     // clear cross-correlator outputs
     //memset(_q->rxy, 0x00, sizeof(_q->rxy));
     memset(_q->rxy0, 0x00, _q->m*sizeof(float));
@@ -246,7 +246,7 @@ void detector_cccf_reset(detector_cccf _q)
 //  _dphi_hat   :   carrier frequency offset estimate (set when detected)
 //  _gamma_hat  :   channel gain estimate (set when detected)
 int detector_cccf_correlate(detector_cccf _q,
-                            float complex _x,
+                            _Fcomplex _x,
                             float *       _tau_hat,
                             float *       _dphi_hat,
                             float *       _gamma_hat)
@@ -285,7 +285,7 @@ int detector_cccf_correlate(detector_cccf _q,
 #if DEBUG_DETECTOR
     windowf_push(_q->debug_rxy, rxy_abs);
 #endif
-    
+
     if (_q->state == DETECTOR_STATE_SEEK) {
         // check to see if value exceeds threshold
         if (rxy_abs > _q->threshold) {
@@ -309,7 +309,7 @@ int detector_cccf_correlate(detector_cccf _q,
 #if DEBUG_DETECTOR_PRINT
             printf("maximum found:           rxy = %8.4f\n", rxy_abs);
 #endif
-            
+
             // estimate timing and carrier offsets
             detector_cccf_estimate_offsets(_q, _tau_hat, _dphi_hat);
 
@@ -330,13 +330,13 @@ int detector_cccf_correlate(detector_cccf _q,
     return 0;
 }
 
-// 
+//
 // internal methods
 //
 
 // compute sum{ |x|^2 }
 void detector_cccf_update_sumsq(detector_cccf _q,
-                                float complex _x)
+                                _Fcomplex _x)
 {
     // update estimate of signal magnitude
     float x2_n = crealf(_x * conjf(_x));    // |x[n-1]|^2 (input sample)
@@ -361,13 +361,13 @@ void detector_cccf_update_sumsq(detector_cccf _q,
 void detector_cccf_compute_dotprods(detector_cccf _q)
 {
     // read buffer
-    float complex * r;
+    _Fcomplex * r;
     windowcf_read(_q->buffer, &r);
 
     // compute dot products
     // TODO: compute conjugate as well
     unsigned int k;
-    float complex rxy;
+    _Fcomplex rxy;
 #if DEBUG_DETECTOR_PRINT
     printf("  rxy : ");
 #endif
@@ -461,13 +461,13 @@ void detector_cccf_estimate_offsets(detector_cccf _q,
 float detector_cccf_estimate_dphi(detector_cccf _q)
 {
     // read buffer...
-    float complex * r;
+    _Fcomplex * r;
     windowcf_read(_q->buffer, &r);
 
     //
-    float complex r0 = 0.0f;
-    float complex r1 = 0.0f;
-    float complex metric = 0.0f;
+    _Fcomplex r0 = 0.0f;
+    _Fcomplex r1 = 0.0f;
+    _Fcomplex metric = 0.0f;
     unsigned int i;
     for (i=0; i<_q->n; i++) {
         r0 = r1;
@@ -494,7 +494,7 @@ void detector_cccf_debug_print(detector_cccf _q,
     fprintf(fid,"clear all;\n");
     fprintf(fid,"N = %u;\n", DEBUG_DETECTOR_BUFFER_LEN);
     unsigned int i;
-    float complex * rc;
+    _Fcomplex * rc;
     float * r;
 
     fprintf(fid,"x = zeros(1,N);\n");
diff --git a/src/framing/src/dsssframegen.c b/src/framing/src/dsssframegen.c
index 09d5e9c0..9e666833 100644
--- a/src/framing/src/dsssframegen.c
+++ b/src/framing/src/dsssframegen.c
@@ -117,7 +117,7 @@ dsssframegen dsssframegen_create(dsssframegenprops_s * _fgprops)
     q->interp = firinterp_crcf_create_prototype(LIQUID_FIRFILT_ARKAISER, q->k, q->m, q->beta, 0);
 
     // generate pn sequence
-    q->preamble_pn = (float complex *)malloc(64 * sizeof(liquid_float_complex));
+    q->preamble_pn = (_Fcomplex *)malloc(64 * sizeof(liquid_float_complex));
     msequence ms   = msequence_create(7, 0x0089, 1);
     for (i = 0; i < 64; i++) {
         q->preamble_pn[i] = (msequence_advance(ms) ? M_SQRT1_2 : -M_SQRT1_2);
@@ -125,7 +125,7 @@ dsssframegen dsssframegen_create(dsssframegenprops_s * _fgprops)
     }
     msequence_destroy(ms);
 
-    liquid_float_complex * pn = (float complex *)malloc(64 * sizeof(liquid_float_complex));
+    liquid_float_complex * pn = (_Fcomplex *)malloc(64 * sizeof(liquid_float_complex));
     ms                        = msequence_create(7, 0x00cb, 0x53);
     for (i = 0; i < 64; i++) {
         pn[i] = (msequence_advance(ms) ? M_SQRT1_2 : -M_SQRT1_2);
diff --git a/src/framing/src/dsssframesync.c b/src/framing/src/dsssframesync.c
index cbfeb528..9a9a60f1 100644
--- a/src/framing/src/dsssframesync.c
+++ b/src/framing/src/dsssframesync.c
@@ -308,10 +308,10 @@ void dsssframesync_execute(dsssframesync _q, liquid_float_complex * _x, unsigned
 //  _q      :   frame synchronizer object
 //  _x      :   input sample
 //  _sym    :   demodulated symbol
-void dsssframesync_execute_seekpn(dsssframesync _q, float complex _x)
+void dsssframesync_execute_seekpn(dsssframesync _q, _Fcomplex _x)
 {
     // push through pre-demod synchronizer
-    float complex * v = qdetector_cccf_execute(_q->detector, _x);
+    _Fcomplex * v = qdetector_cccf_execute(_q->detector, _x);
 
     // check if frame has been detected
     if (v == NULL)
@@ -347,10 +347,10 @@ void dsssframesync_execute_seekpn(dsssframesync _q, float complex _x)
     dsssframesync_execute(_q, v, buf_len);
 }
 
-int dsssframesync_step(dsssframesync _q, float complex _x, float complex * _y)
+int dsssframesync_step(dsssframesync _q, _Fcomplex _x, _Fcomplex * _y)
 {
     // mix sample down
-    float complex v;
+    _Fcomplex v;
     nco_crcf_mix_down(_q->mixer, _x, &v);
     nco_crcf_step(_q->mixer);
 
@@ -375,10 +375,10 @@ int dsssframesync_step(dsssframesync _q, float complex _x, float complex * _y)
     return sample_available;
 }
 
-void dsssframesync_execute_rxpreamble(dsssframesync _q, float complex _x)
+void dsssframesync_execute_rxpreamble(dsssframesync _q, _Fcomplex _x)
 {
     // step synchronizer
-    float complex mf_out           = 0.0f;
+    _Fcomplex mf_out           = 0.0f;
     int           sample_available = dsssframesync_step(_q, _x, &mf_out);
 
     // compute output if timeout
diff --git a/src/framing/src/flexframegen.c b/src/framing/src/flexframegen.c
index da22e339..f9151d02 100644
--- a/src/framing/src/flexframegen.c
+++ b/src/framing/src/flexframegen.c
@@ -39,11 +39,11 @@
 
 // reconfigure internal properties
 void          flexframegen_reconfigure      (flexframegen _q);
-float complex flexframegen_generate_symbol  (flexframegen _q);
-float complex flexframegen_generate_preamble(flexframegen _q);
-float complex flexframegen_generate_header  (flexframegen _q);
-float complex flexframegen_generate_payload (flexframegen _q);
-float complex flexframegen_generate_tail    (flexframegen _q);
+_Fcomplex flexframegen_generate_symbol  (flexframegen _q);
+_Fcomplex flexframegen_generate_preamble(flexframegen _q);
+_Fcomplex flexframegen_generate_header  (flexframegen _q);
+_Fcomplex flexframegen_generate_payload (flexframegen _q);
+_Fcomplex flexframegen_generate_tail    (flexframegen _q);
 
 // default flexframegen properties
 static flexframegenprops_s flexframegenprops_default = {
@@ -71,13 +71,13 @@ struct flexframegen_s {
     unsigned int    m;                  // interp filter delay (symbols)
     float           beta;               // excess bandwidth factor
     firinterp_crcf  interp;             // interpolator object
-    float complex   buf_interp[2];      // output interpolator buffer [size: k x 1]
+    _Fcomplex   buf_interp[2];      // output interpolator buffer [size: k x 1]
 
     flexframegenprops_s props;          // payload properties
     flexframegenprops_s header_props;   // header properties
 
     // preamble
-    float complex * preamble_pn;        // p/n sequence
+    _Fcomplex * preamble_pn;        // p/n sequence
 
     // header
     unsigned char * header;             // header data
@@ -85,16 +85,16 @@ struct flexframegen_s {
     unsigned int    header_dec_len;     // header length (decoded)
     qpacketmodem    header_encoder;     // header encoder/modulator
     unsigned int    header_mod_len;     // header length (encoded/modulated)
-    float complex * header_mod;         // header symbols (encoded/modulated)
+    _Fcomplex * header_mod;         // header symbols (encoded/modulated)
     qpilotgen       header_pilotgen;    // header pilot symbol generator
     unsigned int    header_sym_len;     // header length (pilots added)
-    float complex * header_sym;         // header symbols (pilots added)
+    _Fcomplex * header_sym;         // header symbols (pilots added)
 
     // payload
     unsigned int    payload_dec_len;    // length of decoded
     qpacketmodem    payload_encoder;    // packet encoder/modulator
     unsigned int    payload_sym_len;    // length of encoded/modulated payload
-    float complex * payload_sym;        // encoded payload symbols
+    _Fcomplex * payload_sym;        // encoded payload symbols
 
     // counters/states
     unsigned int    symbol_counter;     // output symbol number
@@ -121,7 +121,7 @@ flexframegen flexframegen_create(flexframegenprops_s * _fgprops)
     q->interp = firinterp_crcf_create_prototype(LIQUID_FIRFILT_ARKAISER,q->k,q->m,q->beta,0);
 
     // generate pn sequence
-    q->preamble_pn = (float complex *) malloc(64*sizeof(float complex));
+    q->preamble_pn = (_Fcomplex *) malloc(64*sizeof(_Fcomplex));
     msequence ms = msequence_create(7, 0x0089, 1);
     for (i=0; i<64; i++) {
         q->preamble_pn[i] = (msequence_advance(ms) ? M_SQRT1_2 : -M_SQRT1_2);
@@ -144,7 +144,7 @@ flexframegen flexframegen_create(flexframegenprops_s * _fgprops)
     q->payload_encoder = qpacketmodem_create();
     q->payload_dec_len = 64;
     q->payload_sym_len = qpacketmodem_get_frame_len(q->payload_encoder);
-    q->payload_sym     = (float complex *) malloc( q->payload_sym_len*sizeof(float complex));
+    q->payload_sym     = (_Fcomplex *) malloc( q->payload_sym_len*sizeof(_Fcomplex));
 
     // set payload properties
     flexframegen_setprops(q, _fgprops);
@@ -165,7 +165,7 @@ void flexframegen_destroy(flexframegen _q)
     // free buffers/arrays
     free(_q->preamble_pn);  // preamble symbols
     free(_q->header);       // header bytes
-    free(_q->header_mod);   // encoded/modulated header symbols 
+    free(_q->header_mod);   // encoded/modulated header symbols
     free(_q->header_sym);
     free(_q->payload_sym);  // encoded/modulated payload symbols
 
@@ -290,7 +290,7 @@ void flexframegen_set_header_len(flexframegen   _q,
                            _q->header_props.fec1,
                            _q->header_props.mod_scheme);
     _q->header_mod_len = qpacketmodem_get_frame_len(_q->header_encoder);
-    _q->header_mod     = (float complex *) realloc(_q->header_mod, _q->header_mod_len*sizeof(float complex));
+    _q->header_mod     = (_Fcomplex *) realloc(_q->header_mod, _q->header_mod_len*sizeof(_Fcomplex));
 
     // create header pilot sequence generator
     if (_q->header_pilotgen) {
@@ -298,7 +298,7 @@ void flexframegen_set_header_len(flexframegen   _q,
     }
     _q->header_pilotgen = qpilotgen_create(_q->header_mod_len, 16);
     _q->header_sym_len  = qpilotgen_get_frame_len(_q->header_pilotgen);
-    _q->header_sym      = (float complex *) realloc(_q->header_sym, _q->header_sym_len*sizeof(float complex));
+    _q->header_sym      = (_Fcomplex *) realloc(_q->header_sym, _q->header_sym_len*sizeof(_Fcomplex));
     //printf("header: %u bytes > %u mod > %u sym\n", 64, _q->header_mod_len, _q->header_sym_len);
 }
 
@@ -418,7 +418,7 @@ void flexframegen_assemble(flexframegen          _q,
 //  _buffer     :   output buffer [size: _buffer_len x 1]
 //  _buffer_len :   output buffer length
 int flexframegen_write_samples(flexframegen    _q,
-                               float complex * _buffer,
+                               _Fcomplex * _buffer,
                                unsigned int    _buffer_len)
 {
     unsigned int i;
@@ -426,15 +426,15 @@ int flexframegen_write_samples(flexframegen    _q,
         // determine if new sample needs to be written
         if (_q->sample_counter == 0) {
             // generate new symbol
-            float complex sym = flexframegen_generate_symbol(_q);
+            _Fcomplex sym = flexframegen_generate_symbol(_q);
 
             // interpolate result
             firinterp_crcf_execute(_q->interp, sym, _q->buf_interp);
         }
-        
+
         // write output sample from interpolator buffer
         _buffer[i] = _q->buf_interp[_q->sample_counter];
-            
+
         // adjust sample counter
         _q->sample_counter = (_q->sample_counter + 1) % _q->k;
     }
@@ -459,8 +459,8 @@ void flexframegen_reconfigure(flexframegen _q)
 
     // re-allocate memory for encoded message
     _q->payload_sym_len = qpacketmodem_get_frame_len(_q->payload_encoder);
-    _q->payload_sym = (float complex*) realloc(_q->payload_sym,
-                                               _q->payload_sym_len*sizeof(float complex));
+    _q->payload_sym = (_Fcomplex*) realloc(_q->payload_sym,
+                                               _q->payload_sym_len*sizeof(_Fcomplex));
 
     // ensure payload was reallocated appropriately
     if (_q->payload_sym == NULL) {
@@ -470,7 +470,7 @@ void flexframegen_reconfigure(flexframegen _q)
 }
 
 // fill interpolator buffer
-float complex flexframegen_generate_symbol(flexframegen _q)
+_Fcomplex flexframegen_generate_symbol(flexframegen _q)
 {
     // write zeros to buffer if frame is not assembled
     if (!_q->frame_assembled)
@@ -490,9 +490,9 @@ float complex flexframegen_generate_symbol(flexframegen _q)
 }
 
 // generate preamble
-float complex flexframegen_generate_preamble(flexframegen _q)
+_Fcomplex flexframegen_generate_preamble(flexframegen _q)
 {
-    float complex symbol = _q->preamble_pn[_q->symbol_counter++];
+    _Fcomplex symbol = _q->preamble_pn[_q->symbol_counter++];
 
     // check state
     if (_q->symbol_counter == 64) {
@@ -503,9 +503,9 @@ float complex flexframegen_generate_preamble(flexframegen _q)
 }
 
 // generate header
-float complex flexframegen_generate_header(flexframegen _q)
+_Fcomplex flexframegen_generate_header(flexframegen _q)
 {
-    float complex symbol = _q->header_sym[_q->symbol_counter++];
+    _Fcomplex symbol = _q->header_sym[_q->symbol_counter++];
 
     // check state
     if (_q->symbol_counter == _q->header_sym_len) {
@@ -516,9 +516,9 @@ float complex flexframegen_generate_header(flexframegen _q)
 }
 
 // generate payload
-float complex flexframegen_generate_payload(flexframegen _q)
+_Fcomplex flexframegen_generate_payload(flexframegen _q)
 {
-    float complex symbol = _q->payload_sym[_q->symbol_counter++];
+    _Fcomplex symbol = _q->payload_sym[_q->symbol_counter++];
 
     // check state
     if (_q->symbol_counter == _q->payload_sym_len) {
@@ -529,7 +529,7 @@ float complex flexframegen_generate_payload(flexframegen _q)
 }
 
 // generate tail
-float complex flexframegen_generate_tail(flexframegen _q)
+_Fcomplex flexframegen_generate_tail(flexframegen _q)
 {
     // increment symbol counter
     _q->symbol_counter++;
@@ -543,4 +543,3 @@ float complex flexframegen_generate_tail(flexframegen _q)
 
     return 0.0f;
 }
-
diff --git a/src/framing/src/flexframesync.c b/src/framing/src/flexframesync.c
index e0e45ef7..a1a810a6 100644
--- a/src/framing/src/flexframesync.c
+++ b/src/framing/src/flexframesync.c
@@ -44,30 +44,30 @@
 
 // push samples through detection stage
 void flexframesync_execute_seekpn(flexframesync _q,
-                                  float complex _x);
+                                  _Fcomplex _x);
 
 // step receiver mixer, matched filter, decimator
 //  _q      :   frame synchronizer
 //  _x      :   input sample
 //  _y      :   output symbol
 int flexframesync_step(flexframesync   _q,
-                       float complex   _x,
-                       float complex * _y);
+                       _Fcomplex   _x,
+                       _Fcomplex * _y);
 
 // push samples through synchronizer, saving received p/n symbols
 void flexframesync_execute_rxpreamble(flexframesync _q,
-                                      float complex _x);
+                                      _Fcomplex _x);
 
 // decode header and reconfigure payload
 void flexframesync_decode_header(flexframesync _q);
 
 // receive header symbols
 void flexframesync_execute_rxheader(flexframesync _q,
-                                    float complex _x);
+                                    _Fcomplex _x);
 
 // receive payload symbols
 void flexframesync_execute_rxpayload(flexframesync _q,
-                                     float complex _x);
+                                     _Fcomplex _x);
 
 static flexframegenprops_s flexframesyncprops_header_default = {
    FLEXFRAME_H_CRC,
@@ -83,7 +83,7 @@ struct flexframesync_s {
     void *              userdata;       // user-defined data structure
     framesyncstats_s    framesyncstats; // frame statistic object (synchronizer)
     framedatastats_s    framedatastats; // frame statistic object (synchronizer)
-    
+
     // synchronizer objects
     unsigned int    m;                  // filter delay (symbols)
     float           beta;               // filter excess bandwidth factor
@@ -105,15 +105,15 @@ struct flexframesync_s {
 #endif
 
     // preamble
-    float complex * preamble_pn;        // known 64-symbol p/n sequence
-    float complex * preamble_rx;        // received p/n symbols
-    
+    _Fcomplex * preamble_pn;        // known 64-symbol p/n sequence
+    _Fcomplex * preamble_rx;        // received p/n symbols
+
     // header
     int             header_soft;        // header performs soft demod
-    float complex * header_sym;         // header symbols with pilots (received)
+    _Fcomplex * header_sym;         // header symbols with pilots (received)
     unsigned int    header_sym_len;     // header symbols with pilots (length)
     qpilotsync      header_pilotsync;   // header demodulator/decoder
-    float complex * header_mod;         // header symbols (received)
+    _Fcomplex * header_mod;         // header symbols (received)
     unsigned int    header_mod_len;     // header symbols (length)
     qpacketmodem    header_decoder;     // header demodulator/decoder
     unsigned int    header_user_len;    // length of user-defined array
@@ -126,13 +126,13 @@ struct flexframesync_s {
     // payload
     int             payload_soft;       // payload performs soft demod
     modem           payload_demod;      // payload demod (for phase recovery only)
-    float complex * payload_sym;        // payload symbols (received)
+    _Fcomplex * payload_sym;        // payload symbols (received)
     unsigned int    payload_sym_len;    // payload symbols (length)
     qpacketmodem    payload_decoder;    // payload demodulator/decoder
     unsigned char * payload_dec;        // payload data (bytes)
     unsigned int    payload_dec_len;    // payload data (length)
     int             payload_valid;      // payload CRC flag
-    
+
     // status variables
     unsigned int    preamble_counter;   // counter: num of p/n syms received
     unsigned int    symbol_counter;     // counter: num of symbols received
@@ -166,8 +166,8 @@ flexframesync flexframesync_create(framesync_callback _callback,
     unsigned int i;
 
     // generate p/n sequence
-    q->preamble_pn = (float complex*) malloc(64*sizeof(float complex));
-    q->preamble_rx = (float complex*) malloc(64*sizeof(float complex));
+    q->preamble_pn = (_Fcomplex*) malloc(64*sizeof(_Fcomplex));
+    q->preamble_rx = (_Fcomplex*) malloc(64*sizeof(_Fcomplex));
     msequence ms = msequence_create(7, 0x0089, 1);
     for (i=0; i<64; i++) {
         q->preamble_pn[i] = (msequence_advance(ms) ? M_SQRT1_2 : -M_SQRT1_2);
@@ -195,7 +195,7 @@ flexframesync flexframesync_create(framesync_callback _callback,
     q->mixer = nco_crcf_create(LIQUID_NCO);
     q->pll   = nco_crcf_create(LIQUID_NCO);
     nco_crcf_pll_set_bandwidth(q->pll, 1e-4f); // very low bandwidth
-    
+
     // header demodulator/decoder
     q->header_sym = NULL;
     q->header_mod = NULL;
@@ -222,7 +222,7 @@ flexframesync flexframesync_create(framesync_callback _callback,
     q->payload_sym_len = qpacketmodem_get_frame_len(q->payload_decoder);
 
     // allocate memory for payload symbols and recovered data bytes
-    q->payload_sym = (float complex*) malloc(q->payload_sym_len*sizeof(float complex));
+    q->payload_sym = (_Fcomplex*) malloc(q->payload_sym_len*sizeof(_Fcomplex));
     q->payload_dec = (unsigned char*) malloc(q->payload_dec_len*sizeof(unsigned char));
     q->payload_soft = 0;
 
@@ -296,12 +296,12 @@ void flexframesync_reset(flexframesync _q)
 
     // reset symbol timing recovery state
     firpfb_crcf_reset(_q->mf);
-        
+
     // reset state
     _q->state           = FLEXFRAMESYNC_STATE_DETECTFRAME;
     _q->preamble_counter= 0;
     _q->symbol_counter  = 0;
-    
+
     // reset frame statistics
     _q->framesyncstats.evm = 0.0f;
 }
@@ -328,7 +328,7 @@ void flexframesync_set_header_len(flexframesync _q,
                            _q->header_props.fec1,
                            _q->header_props.mod_scheme);
     _q->header_mod_len = qpacketmodem_get_frame_len(_q->header_decoder);
-    _q->header_mod     = (float complex*) realloc(_q->header_mod, _q->header_mod_len*sizeof(float complex));
+    _q->header_mod     = (_Fcomplex*) realloc(_q->header_mod, _q->header_mod_len*sizeof(_Fcomplex));
 
     // header pilot synchronizer
     if (_q->header_pilotsync) {
@@ -336,7 +336,7 @@ void flexframesync_set_header_len(flexframesync _q,
     }
     _q->header_pilotsync = qpilotsync_create(_q->header_mod_len, 16);
     _q->header_sym_len   = qpilotsync_get_frame_len(_q->header_pilotsync);
-    _q->header_sym       = (float complex*) realloc(_q->header_sym, _q->header_sym_len*sizeof(float complex));
+    _q->header_sym       = (_Fcomplex*) realloc(_q->header_sym, _q->header_sym_len*sizeof(_Fcomplex));
 }
 
 void flexframesync_decode_header_soft(flexframesync _q,
@@ -384,7 +384,7 @@ int flexframesync_set_header_props(flexframesync          _q,
 //  _x  :   input sample array [size: _n x 1]
 //  _n  :   number of input samples
 void flexframesync_execute(flexframesync   _q,
-                           float complex * _x,
+                           _Fcomplex * _x,
                            unsigned int    _n)
 {
     unsigned int i;
@@ -419,7 +419,7 @@ void flexframesync_execute(flexframesync   _q,
     }
 }
 
-// 
+//
 // internal methods
 //
 
@@ -428,10 +428,10 @@ void flexframesync_execute(flexframesync   _q,
 //  _x      :   input sample
 //  _sym    :   demodulated symbol
 void flexframesync_execute_seekpn(flexframesync _q,
-                                  float complex _x)
+                                  _Fcomplex _x)
 {
     // push through pre-demod synchronizer
-    float complex * v = qdetector_cccf_execute(_q->detector, _x);
+    _Fcomplex * v = qdetector_cccf_execute(_q->detector, _x);
 
     // check if frame has been detected
     if (v == NULL)
@@ -456,7 +456,7 @@ void flexframesync_execute_seekpn(flexframesync _q,
         _q->pfb_index = (unsigned int)((1.0f+_q->tau_hat) * _q->npfb) % _q->npfb;
         _q->mf_counter = 1;
     }
-    
+
     // output filter scale (gain estimate, scaled by 1/2 for k=2 samples/symbol)
     firpfb_crcf_set_scale(_q->mf, 0.5f / _q->gamma_hat);
 
@@ -484,14 +484,14 @@ void flexframesync_execute_seekpn(flexframesync _q,
 //  _x      :   input sample
 //  _y      :   output symbol
 int flexframesync_step(flexframesync   _q,
-                       float complex   _x,
-                       float complex * _y)
+                       _Fcomplex   _x,
+                       _Fcomplex * _y)
 {
     // mix sample down
-    float complex v;
+    _Fcomplex v;
     nco_crcf_mix_down(_q->mixer, _x, &v);
     nco_crcf_step    (_q->mixer);
-    
+
     // push sample into filterbank
     firpfb_crcf_push   (_q->mf, v);
     firpfb_crcf_execute(_q->mf, _q->pfb_index, &v);
@@ -504,7 +504,7 @@ int flexframesync_step(flexframesync   _q,
     // increment counter to determine if sample is available
     _q->mf_counter++;
     int sample_available = (_q->mf_counter >= 1) ? 1 : 0;
-    
+
     // set output sample if available
     if (sample_available) {
 #if FLEXFRAMESYNC_ENABLE_EQ
@@ -528,10 +528,10 @@ int flexframesync_step(flexframesync   _q,
 //  _x      :   input sample
 //  _sym    :   demodulated symbol
 void flexframesync_execute_rxpreamble(flexframesync _q,
-                                      float complex _x)
+                                      _Fcomplex _x)
 {
     // step synchronizer
-    float complex mf_out = 0.0f;
+    _Fcomplex mf_out = 0.0f;
     int sample_available = flexframesync_step(_q, _x, &mf_out);
 
     // compute output if timeout
@@ -547,7 +547,7 @@ void flexframesync_execute_rxpreamble(flexframesync _q,
             unsigned int index = _q->preamble_counter-delay;
 
             _q->preamble_rx[index] = mf_out;
-        
+
 #if FLEXFRAMESYNC_ENABLE_EQ
             // train equalizer
             eqlms_cccf_step(_q->equalizer, _q->preamble_pn[index], mf_out);
@@ -568,10 +568,10 @@ void flexframesync_execute_rxpreamble(flexframesync _q,
 //  _x      :   input sample
 //  _sym    :   demodulated symbol
 void flexframesync_execute_rxheader(flexframesync _q,
-                                    float complex _x)
+                                    _Fcomplex _x)
 {
     // step synchronizer
-    float complex mf_out = 0.0f;
+    _Fcomplex mf_out = 0.0f;
     int sample_available = flexframesync_step(_q, _x, &mf_out);
 
     // compute output if timeout
@@ -710,7 +710,7 @@ void flexframesync_decode_header(flexframesync _q)
     _q->payload_sym_len = qpacketmodem_get_frame_len(_q->payload_decoder);
 
     // re-allocate buffers accordingly
-    _q->payload_sym = (float complex*) realloc(_q->payload_sym, (_q->payload_sym_len)*sizeof(float complex));
+    _q->payload_sym = (_Fcomplex*) realloc(_q->payload_sym, (_q->payload_sym_len)*sizeof(_Fcomplex));
     _q->payload_dec = (unsigned char*) realloc(_q->payload_dec, (_q->payload_dec_len)*sizeof(unsigned char));
 
     if (_q->payload_sym == NULL || _q->payload_dec == NULL) {
@@ -743,10 +743,10 @@ void flexframesync_decode_header(flexframesync _q)
 //  _x      :   input sample
 //  _sym    :   demodulated symbol
 void flexframesync_execute_rxpayload(flexframesync _q,
-                                     float complex _x)
+                                     _Fcomplex _x)
 {
     // step synchronizer
-    float complex mf_out = 0.0f;
+    _Fcomplex mf_out = 0.0f;
     int sample_available = flexframesync_step(_q, _x, &mf_out);
 
     // compute output if timeout
@@ -871,14 +871,14 @@ void flexframesync_debug_print(flexframesync _q,
         return;
     }
     unsigned int i;
-    float complex * rc;
+    _Fcomplex * rc;
     FILE* fid = fopen(_filename,"w");
     fprintf(fid,"%% %s: auto-generated file", _filename);
     fprintf(fid,"\n\n");
     fprintf(fid,"clear all;\n");
     fprintf(fid,"close all;\n\n");
     fprintf(fid,"n = %u;\n", DEBUG_BUFFER_LEN);
-    
+
     // main figure
     fprintf(fid,"figure('Color','white','position',[100 100 800 600]);\n");
 
@@ -944,4 +944,3 @@ void flexframesync_debug_print(flexframesync _q,
     fprintf(stderr,"flexframesync_debug_print(): compile-time debugging disabled\n");
 #endif
 }
-
diff --git a/src/framing/src/framegen64.c b/src/framing/src/framegen64.c
index e7a2ca50..1227a087 100644
--- a/src/framing/src/framegen64.c
+++ b/src/framing/src/framegen64.c
@@ -38,10 +38,10 @@
 struct framegen64_s {
     qpacketmodem    enc;                // packet encoder/modulator
     qpilotgen       pilotgen;           // pilot symbol generator
-    float complex   pn_sequence[64];    // 64-symbol p/n sequence
+    _Fcomplex   pn_sequence[64];    // 64-symbol p/n sequence
     unsigned char   payload_dec[150];   // 600 = 150 bytes * 8 bits/bytes / 2 bits/symbol
-    float complex   payload_sym[600];   // modulated payload symbols
-    float complex   payload_tx[630];    // modulated payload symbols with pilots
+    _Fcomplex   payload_sym[600];   // modulated payload symbols
+    _Fcomplex   payload_tx[630];    // modulated payload symbols with pilots
     unsigned int    m;                  // filter delay (symbols)
     float           beta;               // filter excess bandwidth factor
     firinterp_crcf interp;              // pulse-shaping filter
@@ -130,7 +130,7 @@ void framegen64_print(framegen64 _q)
 void framegen64_execute(framegen64      _q,
                         unsigned char * _header,
                         unsigned char * _payload,
-                        float complex * _frame)
+                        _Fcomplex * _frame)
 {
     unsigned int i;
 
@@ -169,5 +169,3 @@ void framegen64_execute(framegen64      _q,
 
     assert(n==LIQUID_FRAME64_LEN);
 }
-
-
diff --git a/src/framing/src/framesync64.c b/src/framing/src/framesync64.c
index 29ce901e..28742bd8 100644
--- a/src/framing/src/framesync64.c
+++ b/src/framing/src/framesync64.c
@@ -44,23 +44,23 @@
 
 // push samples through detection stage
 void framesync64_execute_seekpn(framesync64   _q,
-                                float complex _x);
+                                _Fcomplex _x);
 
 // step receiver mixer, matched filter, decimator
 //  _q      :   frame synchronizer
 //  _x      :   input sample
 //  _y      :   output symbol
 int framesync64_step(framesync64     _q,
-                     float complex   _x,
-                     float complex * _y);
+                     _Fcomplex   _x,
+                     _Fcomplex * _y);
 
 // push samples through synchronizer, saving received p/n symbols
 void framesync64_execute_rxpreamble(framesync64   _q,
-                                    float complex _x);
+                                    _Fcomplex _x);
 
 // receive payload symbols
 void framesync64_execute_rxpayload(framesync64   _q,
-                                   float complex _x);
+                                   _Fcomplex _x);
 
 // framesync64 object structure
 struct framesync64_s {
@@ -68,7 +68,7 @@ struct framesync64_s {
     framesync_callback  callback;   // user-defined callback function
     void *              userdata;   // user-defined data structure
     framesyncstats_s    framestats; // frame statistic object
-    
+
     // synchronizer objects
     unsigned int        m;          // filter delay (symbols)
     float               beta;       // filter excess bandwidth factor
@@ -89,17 +89,17 @@ struct framesync64_s {
 #endif
 
     // preamble
-    float complex preamble_pn[64];  // known 64-symbol p/n sequence
-    float complex preamble_rx[64];  // received p/n symbols
-    
+    _Fcomplex preamble_pn[64];  // known 64-symbol p/n sequence
+    _Fcomplex preamble_rx[64];  // received p/n symbols
+
     // payload decoder
-    float complex payload_rx [630]; // received payload symbols with pilots
-    float complex payload_sym[600]; // received payload symbols
+    _Fcomplex payload_rx [630]; // received payload symbols with pilots
+    _Fcomplex payload_sym[600]; // received payload symbols
     unsigned char payload_dec[ 72]; // decoded payload bytes
     qpacketmodem  dec;              // packet demodulator/decoder
     qpilotsync    pilotsync;        // pilot extraction, carrier recovery
     int           payload_valid;    // did payload pass crc?
-    
+
     // status variables
     enum {
         FRAMESYNC64_STATE_DETECTFRAME=0,    // detect frame (seek p/n sequence)
@@ -156,7 +156,7 @@ framesync64 framesync64_create(framesync_callback _callback,
 
     // create down-coverters for carrier phase tracking
     q->mixer = nco_crcf_create(LIQUID_NCO);
-    
+
     // create payload demodulator/decoder object
     int check      = LIQUID_CRC_24;
     int fec0       = LIQUID_FEC_NONE;
@@ -224,12 +224,12 @@ void framesync64_reset(framesync64 _q)
 
     // reset symbol timing recovery state
     firpfb_crcf_reset(_q->mf);
-        
+
     // reset state
     _q->state           = FRAMESYNC64_STATE_DETECTFRAME;
     _q->preamble_counter= 0;
     _q->payload_counter = 0;
-    
+
     // reset frame statistics
     _q->framestats.evm = 0.0f;
 }
@@ -239,7 +239,7 @@ void framesync64_reset(framesync64 _q)
 //  _x      :   input sample array [size: _n x 1]
 //  _n      :   number of input samples
 void framesync64_execute(framesync64     _q,
-                         float complex * _x,
+                         _Fcomplex * _x,
                          unsigned int    _n)
 {
     unsigned int i;
@@ -268,7 +268,7 @@ void framesync64_execute(framesync64     _q,
     }
 }
 
-// 
+//
 // internal methods
 //
 
@@ -277,10 +277,10 @@ void framesync64_execute(framesync64     _q,
 //  _x      :   input sample
 //  _sym    :   demodulated symbol
 void framesync64_execute_seekpn(framesync64   _q,
-                                float complex _x)
+                                _Fcomplex _x)
 {
     // push through pre-demod synchronizer
-    float complex * v = qdetector_cccf_execute(_q->detector, _x);
+    _Fcomplex * v = qdetector_cccf_execute(_q->detector, _x);
 
     // check if frame has been detected
     if (v != NULL) {
@@ -303,7 +303,7 @@ void framesync64_execute_seekpn(framesync64   _q,
             _q->pfb_index = (unsigned int)((1.0f+_q->tau_hat) * _q->npfb) % _q->npfb;
             _q->mf_counter = 1;
         }
-        
+
         // output filter scale
         firpfb_crcf_set_scale(_q->mf, 0.5f / _q->gamma_hat);
 
@@ -325,14 +325,14 @@ void framesync64_execute_seekpn(framesync64   _q,
 //  _x      :   input sample
 //  _y      :   output symbol
 int framesync64_step(framesync64     _q,
-                     float complex   _x,
-                     float complex * _y)
+                     _Fcomplex   _x,
+                     _Fcomplex * _y)
 {
     // mix sample down
-    float complex v;
+    _Fcomplex v;
     nco_crcf_mix_down(_q->mixer, _x, &v);
     nco_crcf_step    (_q->mixer);
-    
+
     // push sample into filterbank
     firpfb_crcf_push   (_q->mf, v);
     firpfb_crcf_execute(_q->mf, _q->pfb_index, &v);
@@ -345,7 +345,7 @@ int framesync64_step(framesync64     _q,
     // increment counter to determine if sample is available
     _q->mf_counter++;
     int sample_available = (_q->mf_counter >= 1) ? 1 : 0;
-    
+
     // set output sample if available
     if (sample_available) {
 #if FRAMESYNC64_ENABLE_EQ
@@ -369,10 +369,10 @@ int framesync64_step(framesync64     _q,
 //  _x      :   input sample
 //  _sym    :   demodulated symbol
 void framesync64_execute_rxpreamble(framesync64   _q,
-                                    float complex _x)
+                                    _Fcomplex _x)
 {
     // step synchronizer
-    float complex mf_out = 0.0f;
+    _Fcomplex mf_out = 0.0f;
     int sample_available = framesync64_step(_q, _x, &mf_out);
 
     // compute output if timeout
@@ -388,7 +388,7 @@ void framesync64_execute_rxpreamble(framesync64   _q,
             unsigned int index = _q->preamble_counter-delay;
 
             _q->preamble_rx[index] = mf_out;
-        
+
 #if FRAMESYNC64_ENABLE_EQ
             // train equalizer
             eqlms_cccf_step(_q->equalizer, _q->preamble_pn[index], mf_out);
@@ -409,10 +409,10 @@ void framesync64_execute_rxpreamble(framesync64   _q,
 //  _x      :   input sample
 //  _sym    :   demodulated symbol
 void framesync64_execute_rxpayload(framesync64   _q,
-                                   float complex _x)
+                                   _Fcomplex _x)
 {
     // step synchronizer
-    float complex mf_out = 0.0f;
+    _Fcomplex mf_out = 0.0f;
     int sample_available = framesync64_step(_q, _x, &mf_out);
 
     // compute output if timeout
@@ -503,7 +503,7 @@ void framesync64_debug_print(framesync64  _q,
         return;
     }
     unsigned int i;
-    float complex * rc;
+    _Fcomplex * rc;
     FILE* fid = fopen(_filename,"w");
     fprintf(fid,"%% %s: auto-generated file", _filename);
     fprintf(fid,"\n\n");
@@ -562,4 +562,3 @@ void framesync64_debug_print(framesync64  _q,
     fprintf(stderr,"framesync64_debug_print(): compile-time debugging disabled\n");
 #endif
 }
-
diff --git a/src/framing/src/fskframegen.c b/src/framing/src/fskframegen.c
index f77a7bb4..5b477618 100644
--- a/src/framing/src/fskframegen.c
+++ b/src/framing/src/fskframegen.c
@@ -51,7 +51,7 @@ struct fskframegen_s {
     unsigned int    M;                  // modulator constellation size, M=2^m
     fskmod          mod_header;         // modulator object for the header (BFSK)
     fskmod          mod;                // modulator object (M-FSK)
-    float complex * buf;                // modulator transmit buffer [size: k x 1]
+    _Fcomplex * buf;                // modulator transmit buffer [size: k x 1]
 
     // preamble
     unsigned int    preamble_sym_len;   // preamble symbols length
@@ -123,7 +123,7 @@ fskframegen fskframegen_create()
     // create modulators
     q->mod_header = fskmod_create(   1, q->k, q->bandwidth);
     q->mod        = fskmod_create(q->m, q->k, q->bandwidth);
-    q->buf        = (float complex*) malloc( q->k * sizeof(float complex) );
+    q->buf        = (_Fcomplex*) malloc( q->k * sizeof(_Fcomplex) );
 
     // preamble symbols (over-sampled by 2)
     msequence preamble_ms = msequence_create(6, 0x6d, 1);
@@ -303,13 +303,13 @@ void fskframegen_assemble(fskframegen     _q,
                            _q->payload_fec1,
                            LIQUID_MODEM_QPSK);
 #endif
-    
+
     // get packet length
     _q->payload_sym_len = qpacketmodem_get_frame_len(_q->payload_encoder);
 
     // re-allocate memory
     _q->payload_sym = (unsigned char*) realloc(_q->payload_sym, _q->payload_sym_len*sizeof(unsigned char));
-    
+
     // set assembled flag
     _q->frame_assembled = 1;
 
@@ -348,7 +348,7 @@ unsigned int fskframegen_getframelen(fskframegen _q)
 
 // write sample to output buffer
 int fskframegen_write_samples(fskframegen     _q,
-                              float complex * _buf,
+                              _Fcomplex * _buf,
                               unsigned int    _buf_len)
 {
     unsigned int i;
@@ -366,7 +366,7 @@ int fskframegen_write_samples(fskframegen     _q,
 }
 
 
-// 
+//
 // internal methods
 //
 
@@ -476,7 +476,7 @@ void fskframegen_generate_header(fskframegen _q)
     fskmod_modulate(_q->mod_header, s, _q->buf);
 
     _q->symbol_counter++;
-    
+
     if (_q->symbol_counter == _q->header_sym_len) {
         _q->symbol_counter = 0;
         _q->state = STATE_PAYLOAD;
@@ -490,11 +490,10 @@ void fskframegen_generate_payload(fskframegen _q)
     fskmod_modulate(_q->mod, s, _q->buf);
 
     _q->symbol_counter++;
-    
+
     if (_q->symbol_counter == _q->payload_sym_len) {
         _q->symbol_counter = 0;
         _q->frame_assembled = 0;
         _q->state = STATE_OFF;
     }
 }
-
diff --git a/src/framing/src/fskframesync.c b/src/framing/src/fskframesync.c
index 17e02a00..0c748356 100644
--- a/src/framing/src/fskframesync.c
+++ b/src/framing/src/fskframesync.c
@@ -39,9 +39,9 @@
 #define DEBUG_FSKFRAMESYNC_BUFFER_LEN  (2000)
 
 // execute stages
-void fskframesync_execute_detectframe(fskframesync _q, float complex _x);
-void fskframesync_execute_rxheader(   fskframesync _q, float complex _x);
-void fskframesync_execute_rxpayload(  fskframesync _q, float complex _x);
+void fskframesync_execute_detectframe(fskframesync _q, _Fcomplex _x);
+void fskframesync_execute_rxheader(   fskframesync _q, _Fcomplex _x);
+void fskframesync_execute_rxpayload(  fskframesync _q, _Fcomplex _x);
 
 // decode header
 void fskframesync_decode_header(fskframesync _q);
@@ -54,7 +54,7 @@ struct fskframesync_s {
     unsigned int    M;                  // demodulator constellation size, M=2^m
     fskdem          dem_header;         // demodulator object for the header (BFSK)
     fskdem          dem;                // demodulator object (M-FSK)
-    float complex * buf;                // demodulator transmit buffer [size: k x 1]
+    _Fcomplex * buf;                // demodulator transmit buffer [size: k x 1]
 
     framesync_callback  callback;       // user-defined callback function
     void *              userdata;       // user-defined data structure
@@ -136,7 +136,7 @@ fskframesync fskframesync_create(framesync_callback _callback,
                                  void *             _userdata)
 {
     fskframesync q = (fskframesync) malloc(sizeof(struct fskframesync_s));
-    
+
     // set static values
     q->callback  = _callback;
     q->userdata  = _userdata;
@@ -148,7 +148,7 @@ fskframesync fskframesync_create(framesync_callback _callback,
     // create demodulators
     q->dem_header = fskdem_create(   1, q->k, q->bandwidth);
     q->dem        = fskdem_create(q->m, q->k, q->bandwidth);
-    q->buf        = (float complex*) malloc( q->k * sizeof(float complex) );
+    q->buf        = (_Fcomplex*) malloc( q->k * sizeof(_Fcomplex) );
 
     // create polyphase filterbank for timing recovery
     q->npfb = 64;
@@ -352,7 +352,7 @@ void fskframesync_reset(fskframesync _q)
 //  _q      :   frame synchronizer object
 //  _x      :   input sample
 void fskframesync_execute(fskframesync  _q,
-                          float complex _x)
+                          _Fcomplex _x)
 {
     // push through synchronizer
 #if DEBUG_FSKFRAMESYNC
@@ -383,7 +383,7 @@ void fskframesync_execute(fskframesync  _q,
 //  _x      :   input sample array [size: _n x 1]
 //  _n      :   number of input samples
 void fskframesync_execute_block(fskframesync    _q,
-                                float complex * _x,
+                                _Fcomplex * _x,
                                 unsigned int    _n)
 {
     unsigned int i;
@@ -391,16 +391,16 @@ void fskframesync_execute_block(fskframesync    _q,
         fskframesync_execute(_q, _x[i]);
 }
 
-// 
+//
 // internal methods
 //
 
 void fskframesync_execute_detectframe(fskframesync  _q,
-                                      float complex _x)
+                                      _Fcomplex _x)
 {
 #if 0
     // push sample through timing recovery and compute output
-    float complex y;
+    _Fcomplex y;
     firpfb_crcf_push(_q->pfb, _x);
     firpfb_crcf_execute(_q->pfb, 0, &y);
 
@@ -419,7 +419,7 @@ void fskframesync_execute_detectframe(fskframesync  _q,
     _q->timer = _q->k;
 
     // run demodulator and retrieve FFT result, computing LLR sample output
-    float complex * r;
+    _Fcomplex * r;
     windowcf_read(_q->buf_rx, &r);
     fskdem_demodulate(_q->dem_header, r);
     int fft_bin_range = 2;
@@ -445,7 +445,7 @@ void fskframesync_execute_detectframe(fskframesync  _q,
     for (i=0; i<n; i++)
         g += rf[i];
     float rxy = v / ((float)n * (1e-6f + sqrtf(g/(float)n)));
-    
+
     //printf("LLR(end+1) = %12.4e; v(end+1) = %12.4e; g(end+1) = %12.4e;\n", LLR, rxy, g);
 
     // shift correlator values
@@ -490,11 +490,11 @@ void fskframesync_execute_detectframe(fskframesync  _q,
 }
 
 void fskframesync_execute_rxheader(fskframesync  _q,
-                                   float complex _x)
+                                   _Fcomplex _x)
 {
 #if 0
     // push sample through timing recovery and compute output
-    float complex y;
+    _Fcomplex y;
     firpfb_crcf_push(_q->pfb, _x);
     firpfb_crcf_execute(_q->pfb, 0, &y);
 
@@ -513,7 +513,7 @@ void fskframesync_execute_rxheader(fskframesync  _q,
     _q->timer = _q->k;
 
     // run demodulator
-    float complex * r;
+    _Fcomplex * r;
     windowcf_read(_q->buf_rx, &r);
     unsigned char sym = fskdem_demodulate(_q->dem_header, r);
 
@@ -579,11 +579,11 @@ void fskframesync_execute_rxheader(fskframesync  _q,
 }
 
 void fskframesync_execute_rxpayload(fskframesync  _q,
-                                    float complex _x)
+                                    _Fcomplex _x)
 {
 #if 0
     // push sample through timing recovery and compute output
-    float complex y;
+    _Fcomplex y;
     firpfb_crcf_push(_q->pfb, _x);
     firpfb_crcf_execute(_q->pfb, 0, &y);
 
@@ -602,7 +602,7 @@ void fskframesync_execute_rxpayload(fskframesync  _q,
     _q->timer = _q->k;
 
     // run demodulator
-    float complex * r;
+    _Fcomplex * r;
     windowcf_read(_q->buf_rx, &r);
     unsigned char sym = fskdem_demodulate(_q->dem, r);
 
@@ -623,7 +623,7 @@ void fskframesync_execute_rxpayload(fskframesync  _q,
                                                      _q->payload_sym,
                                                      _q->payload_dec);
         printf("payload: %s\n", payload_valid ? "valid" : "INVALID");
-        
+
         // invoke callback
         if (_q->callback != NULL) {
             // set framestats internals
@@ -666,7 +666,7 @@ void fskframesync_debug_enable(fskframesync _q)
     if (!_q->debug_objects_created) {
         _q->debug_x  = windowcf_create(DEBUG_FSKFRAMESYNC_BUFFER_LEN);
     }
-    
+
     // set debugging flags
     _q->debug_enabled = 1;
     _q->debug_objects_created = 1;
@@ -706,7 +706,7 @@ void fskframesync_debug_export(fskframesync _q,
     fprintf(fid,"num_samples = %u;\n", DEBUG_FSKFRAMESYNC_BUFFER_LEN);
     fprintf(fid,"t = 0:(num_samples-1);\n");
     unsigned int i;
-    float complex * rc;
+    _Fcomplex * rc;
 
     // write x
     fprintf(fid,"x = zeros(1,num_samples);\n");
@@ -725,4 +725,3 @@ void fskframesync_debug_export(fskframesync _q,
     fprintf(stderr,"fskframesync_debug_print(): compile-time debugging disabled\n");
 #endif
 }
-
diff --git a/src/framing/src/gmskframegen.c b/src/framing/src/gmskframegen.c
index 5ff3f5d0..7e760f8d 100644
--- a/src/framing/src/gmskframegen.c
+++ b/src/framing/src/gmskframegen.c
@@ -37,10 +37,10 @@
 
 // gmskframegen
 void gmskframegen_encode_header( gmskframegen _q, const unsigned char * _header);
-void gmskframegen_write_preamble(gmskframegen _q, float complex * _y);
-void gmskframegen_write_header(  gmskframegen _q, float complex * _y);
-void gmskframegen_write_payload( gmskframegen _q, float complex * _y);
-void gmskframegen_write_tail(    gmskframegen _q, float complex * _y);
+void gmskframegen_write_preamble(gmskframegen _q, _Fcomplex * _y);
+void gmskframegen_write_header(  gmskframegen _q, _Fcomplex * _y);
+void gmskframegen_write_payload( gmskframegen _q, _Fcomplex * _y);
+void gmskframegen_write_tail(    gmskframegen _q, _Fcomplex * _y);
 
 
 // gmskframe object structure
@@ -72,8 +72,8 @@ struct gmskframegen_s {
     crc_scheme check;           // CRC
     fec_scheme fec0;            // inner forward error correction
     fec_scheme fec1;            // outer forward error correction
-    unsigned int dec_msg_len;   // 
-    unsigned int enc_msg_len;   // 
+    unsigned int dec_msg_len;   //
+    unsigned int enc_msg_len;   //
     unsigned char * payload_enc;// encoded payload
 
     // framing state
@@ -256,7 +256,7 @@ void gmskframegen_assemble(gmskframegen          _q,
 
         // re-create payload packetizer
         _q->p_payload = packetizer_recreate(_q->p_payload, _q->dec_msg_len, _q->check, _q->fec0, _q->fec1);
-        
+
         // get packet length
         _q->enc_msg_len = packetizer_get_enc_msg_len(_q->p_payload);
         _q->payload_len = 8*_q->enc_msg_len;
@@ -264,7 +264,7 @@ void gmskframegen_assemble(gmskframegen          _q,
         // re-allocate memory
         _q->payload_enc = (unsigned char*) realloc(_q->payload_enc, _q->enc_msg_len*sizeof(unsigned char));
     }
-    
+
     // set assembled flag
     _q->frame_assembled = 1;
 
@@ -294,7 +294,7 @@ unsigned int gmskframegen_getframelen(gmskframegen _q)
 
 // write sample to output buffer
 int gmskframegen_write_samples(gmskframegen _q,
-                               float complex * _y)
+                               _Fcomplex * _y)
 {
     switch (_q->state) {
     case STATE_PREAMBLE:
@@ -335,7 +335,7 @@ int gmskframegen_write_samples(gmskframegen _q,
 }
 
 
-// 
+//
 // internal methods
 //
 
@@ -376,7 +376,7 @@ void gmskframegen_encode_header(gmskframegen          _q,
 }
 
 void gmskframegen_write_preamble(gmskframegen    _q,
-                                 float complex * _y)
+                                 _Fcomplex * _y)
 {
     unsigned char bit = msequence_advance(_q->ms_preamble);
     gmskmod_modulate(_q->mod, bit, _y);
@@ -398,7 +398,7 @@ void gmskframegen_write_preamble(gmskframegen    _q,
 }
 
 void gmskframegen_write_header(gmskframegen    _q,
-                               float complex * _y)
+                               _Fcomplex * _y)
 {
     div_t d = div(_q->symbol_counter, 8);
     unsigned int byte_index = d.quot;
@@ -409,7 +409,7 @@ void gmskframegen_write_header(gmskframegen    _q,
     gmskmod_modulate(_q->mod, bit, _y);
 
     _q->symbol_counter++;
-    
+
     if (_q->symbol_counter == _q->header_len) {
         _q->symbol_counter = 0;
         _q->state = STATE_PAYLOAD;
@@ -417,7 +417,7 @@ void gmskframegen_write_header(gmskframegen    _q,
 }
 
 void gmskframegen_write_payload(gmskframegen    _q,
-                                float complex * _y)
+                                _Fcomplex * _y)
 {
     div_t d = div(_q->symbol_counter, 8);
     unsigned int byte_index = d.quot;
@@ -428,7 +428,7 @@ void gmskframegen_write_payload(gmskframegen    _q,
     gmskmod_modulate(_q->mod, bit, _y);
 
     _q->symbol_counter++;
-    
+
     if (_q->symbol_counter == _q->payload_len) {
         _q->symbol_counter = 0;
         _q->state = STATE_TAIL;
@@ -436,7 +436,7 @@ void gmskframegen_write_payload(gmskframegen    _q,
 }
 
 void gmskframegen_write_tail(gmskframegen    _q,
-                             float complex * _y)
+                             _Fcomplex * _y)
 {
     unsigned char bit = rand() % 2;
     gmskmod_modulate(_q->mod, bit, _y);
@@ -455,4 +455,3 @@ void gmskframegen_write_tail(gmskframegen    _q,
         _q->frame_complete = 1;
     }
 }
-
diff --git a/src/framing/src/gmskframesync.c b/src/framing/src/gmskframesync.c
index b153955c..0b0b2ea4 100644
--- a/src/framing/src/gmskframesync.c
+++ b/src/framing/src/gmskframesync.c
@@ -43,7 +43,7 @@
 
 // execute a single, post-filtered sample
 void gmskframesync_execute_sample(gmskframesync _q,
-                                  float complex _x);
+                                  _Fcomplex _x);
 
 // push buffered p/n sequence through synchronizer
 void gmskframesync_pushpn(gmskframesync _q);
@@ -53,7 +53,7 @@ void gmskframesync_syncpn(gmskframesync _q);
 
 // update instantaneous frequency estimate
 void gmskframesync_update_fi(gmskframesync _q,
-                             float complex _x);
+                             _Fcomplex _x);
 
 // update symbol synchronizer internal state (filtered error, index, etc.)
 //  _q      :   frame synchronizer
@@ -64,10 +64,10 @@ int gmskframesync_update_symsync(gmskframesync _q,
                                  float *       _y);
 
 // execute stages
-void gmskframesync_execute_detectframe(gmskframesync _q, float complex _x);
-void gmskframesync_execute_rxpreamble( gmskframesync _q, float complex _x);
-void gmskframesync_execute_rxheader(   gmskframesync _q, float complex _x);
-void gmskframesync_execute_rxpayload(  gmskframesync _q, float complex _x);
+void gmskframesync_execute_detectframe(gmskframesync _q, _Fcomplex _x);
+void gmskframesync_execute_rxpreamble( gmskframesync _q, _Fcomplex _x);
+void gmskframesync_execute_rxheader(   gmskframesync _q, _Fcomplex _x);
+void gmskframesync_execute_rxpayload(  gmskframesync _q, _Fcomplex _x);
 
 // decode header
 void gmskframesync_decode_header(gmskframesync _q);
@@ -83,11 +83,11 @@ struct gmskframesync_s {
     framesync_callback callback;    // user-defined callback function
     void * userdata;                // user-defined data structure
     framesyncstats_s framestats;    // frame statistic object
-    
+
     //
-    float complex x_prime;          // received sample state
+    _Fcomplex x_prime;          // received sample state
     float fi_hat;                   // instantaneous frequency estimate
-    
+
     // timing recovery objects, states
     firpfb_rrrf mf;                 // matched filter decimator
     firpfb_rrrf dmf;                // derivative matched filter decimator
@@ -105,7 +105,7 @@ struct gmskframesync_s {
     float gamma_hat;                // channel gain estimate
     windowcf buffer;                // pre-demod buffered samples, size: k*(pn_len+m)
     nco_crcf nco_coarse;            // coarse carrier frequency recovery
-    
+
     // preamble
     unsigned int preamble_len;      // number of symbols in preamble
     float * preamble_pn;            // preamble p/n sequence (known)
@@ -132,7 +132,7 @@ struct gmskframesync_s {
     unsigned char * payload_dec;    // payload data (encoded bytes)
     packetizer p_payload;           // payload packetizer
     int payload_valid;              // did payload pass crc?
-    
+
     // status variables
     enum {
         STATE_DETECTFRAME=0,        // detect frame (seek p/n sequence)
@@ -178,7 +178,7 @@ gmskframesync gmskframesync_create(framesync_callback _callback,
     q->preamble_len = 63;
     q->preamble_pn = (float*)malloc(q->preamble_len*sizeof(float));
     q->preamble_rx = (float*)malloc(q->preamble_len*sizeof(float));
-    float complex preamble_samples[q->preamble_len*q->k];
+    _Fcomplex preamble_samples[q->preamble_len*q->k];
     msequence ms = msequence_create(6, 0x6d, 1);
     gmskmod mod = gmskmod_create(q->k, q->m, q->BT);
 
@@ -188,7 +188,7 @@ gmskframesync gmskframesync_create(framesync_callback _callback,
         // save p/n sequence
         if (i < q->preamble_len)
             q->preamble_pn[i] = bit ? 1.0f : -1.0f;
-        
+
         // modulate/interpolate
         if (i < q->m) gmskmod_modulate(mod, bit, &preamble_samples[0]);
         else          gmskmod_modulate(mod, bit, &preamble_samples[(i-q->m)*q->k]);
@@ -280,7 +280,7 @@ void gmskframesync_destroy(gmskframesync _q)
     windowcf_destroy(_q->buffer);
     free(_q->preamble_pn);
     free(_q->preamble_rx);
-    
+
     // header
     packetizer_destroy(_q->p_header);
     free(_q->header_mod);
@@ -334,25 +334,25 @@ void gmskframesync_reset(gmskframesync _q)
     _q->preamble_counter = 0;
     _q->header_counter   = 0;
     _q->payload_counter  = 0;
-    
+
     // clear pre-demod buffer
     windowcf_reset(_q->buffer);
 
     // reset internal objects
     detector_cccf_reset(_q->frame_detector);
-    
+
     // reset carrier recovery objects
     nco_crcf_reset(_q->nco_coarse);
 
     // reset sample state
     _q->x_prime = 0.0f;
     _q->fi_hat  = 0.0f;
-    
+
     // reset symbol timing recovery state
     firpfb_rrrf_reset(_q->mf);
     firpfb_rrrf_reset(_q->dmf);
     _q->pfb_q = 0.0f;   // filtered error signal
-        
+
 }
 
 int gmskframesync_is_frame_open(gmskframesync _q)
@@ -361,7 +361,7 @@ int gmskframesync_is_frame_open(gmskframesync _q)
 }
 
 void gmskframesync_execute_sample(gmskframesync _q,
-                                  float complex _x)
+                                  _Fcomplex _x)
 {
     switch (_q->state) {
     case STATE_DETECTFRAME:
@@ -391,13 +391,13 @@ void gmskframesync_execute_sample(gmskframesync _q,
 //  _x      :   input sample array [size: _n x 1]
 //  _n      :   number of input samples
 void gmskframesync_execute(gmskframesync   _q,
-                           float complex * _x,
+                           _Fcomplex * _x,
                            unsigned int    _n)
 {
     // push through synchronizer
     unsigned int i;
     for (i=0; i<_n; i++) {
-        float complex xf;   // input sample
+        _Fcomplex xf;   // input sample
 #if GMSKFRAMESYNC_PREFILTER
         iirfilt_crcf_execute(_q->prefilter, _x[i], &xf);
 #else
@@ -414,7 +414,7 @@ void gmskframesync_execute(gmskframesync   _q,
     }
 }
 
-// 
+//
 // internal methods
 //
 
@@ -489,7 +489,7 @@ int gmskframesync_update_symsync(gmskframesync _q,
 
     // set output and return
     *_y = mf_out / (float)(_q->k);
-    
+
     return sample_available;
 }
 
@@ -503,7 +503,7 @@ void gmskframesync_pushpn(gmskframesync _q)
     firpfb_rrrf_reset(_q->dmf);
 
     // read buffer
-    float complex * rc;
+    _Fcomplex * rc;
     windowcf_read(_q->buffer, &rc);
 
     // compute delay and filterbank index
@@ -522,10 +522,10 @@ void gmskframesync_pushpn(gmskframesync _q)
 
     // set coarse carrier frequency offset
     nco_crcf_set_frequency(_q->nco_coarse, _q->dphi_hat);
-    
+
     unsigned int buffer_len = (_q->preamble_len + _q->m) * _q->k;
     for (i=0; i<delay; i++) {
-        float complex y;
+        _Fcomplex y;
         nco_crcf_mix_down(_q->nco_coarse, rc[i], &y);
         nco_crcf_step(_q->nco_coarse);
 
@@ -548,7 +548,7 @@ void gmskframesync_pushpn(gmskframesync _q)
 
 }
 
-// 
+//
 void gmskframesync_syncpn(gmskframesync _q)
 {
 #if 0
@@ -561,7 +561,7 @@ void gmskframesync_syncpn(gmskframesync _q)
 
 // update instantaneous frequency estimate
 void gmskframesync_update_fi(gmskframesync _q,
-                             float complex _x)
+                             _Fcomplex _x)
 {
     // compute differential phase
     _q->fi_hat = cargf(conjf(_q->x_prime)*_x) * _q->k;
@@ -571,7 +571,7 @@ void gmskframesync_update_fi(gmskframesync _q,
 }
 
 void gmskframesync_execute_detectframe(gmskframesync _q,
-                                       float complex _x)
+                                       _Fcomplex _x)
 {
     // push sample into pre-demod p/n sequence buffer
     windowcf_push(_q->buffer, _x);
@@ -595,7 +595,7 @@ void gmskframesync_execute_detectframe(gmskframesync _q,
 }
 
 void gmskframesync_execute_rxpreamble(gmskframesync _q,
-                                      float complex _x)
+                                      _Fcomplex _x)
 {
     // validate input
     if (_q->preamble_counter == _q->preamble_len) {
@@ -604,7 +604,7 @@ void gmskframesync_execute_rxpreamble(gmskframesync _q,
     }
 
     // mix signal down
-    float complex y;
+    _Fcomplex y;
     nco_crcf_mix_down(_q->nco_coarse, _x, &y);
     nco_crcf_step(_q->nco_coarse);
 
@@ -631,10 +631,10 @@ void gmskframesync_execute_rxpreamble(gmskframesync _q,
 }
 
 void gmskframesync_execute_rxheader(gmskframesync _q,
-                                    float complex _x)
+                                    _Fcomplex _x)
 {
     // mix signal down
-    float complex y;
+    _Fcomplex y;
     nco_crcf_mix_down(_q->nco_coarse, _x, &y);
     nco_crcf_step(_q->nco_coarse);
 
@@ -699,10 +699,10 @@ void gmskframesync_execute_rxheader(gmskframesync _q,
 }
 
 void gmskframesync_execute_rxpayload(gmskframesync _q,
-                                     float complex _x)
+                                     _Fcomplex _x)
 {
     // mix signal down
-    float complex y;
+    _Fcomplex y;
     nco_crcf_mix_down(_q->nco_coarse, _x, &y);
     nco_crcf_step(_q->nco_coarse);
 
@@ -839,7 +839,7 @@ void gmskframesync_decode_header(gmskframesync _q)
         _q->check           = check;
         _q->fec0            = fec0;
         _q->fec1            = fec1;
-        
+
         // recreate packetizer object
         _q->p_payload = packetizer_recreate(_q->p_payload,
                                             _q->payload_dec_len,
@@ -871,7 +871,7 @@ void gmskframesync_debug_enable(gmskframesync _q)
         _q->debug_mf = windowf_create(DEBUG_GMSKFRAMESYNC_BUFFER_LEN);
         _q->debug_framesyms  = windowf_create(DEBUG_GMSKFRAMESYNC_BUFFER_LEN);
     }
-    
+
     // set debugging flags
     _q->debug_enabled = 1;
     _q->debug_objects_created = 1;
@@ -911,7 +911,7 @@ void gmskframesync_debug_print(gmskframesync _q,
     fprintf(fid,"num_samples = %u;\n", DEBUG_GMSKFRAMESYNC_BUFFER_LEN);
     fprintf(fid,"t = 0:(num_samples-1);\n");
     unsigned int i;
-    float complex * rc;
+    _Fcomplex * rc;
 
     // write x
     fprintf(fid,"x = zeros(1,num_samples);\n");
diff --git a/src/framing/src/msource.c b/src/framing/src/msource.c
index 4914333e..d2c65204 100644
--- a/src/framing/src/msource.c
+++ b/src/framing/src/msource.c
@@ -44,8 +44,8 @@ struct MSOURCE(_s)
     firpfbch2_crcf  ch;             // analysis channelizer object
 
     // buffers
-    float complex * buf_freq;       // [size: M   x 1]
-    float complex * buf_time;       // [size: M/2 x 1]
+    _Fcomplex * buf_freq;       // [size: M   x 1]
+    _Fcomplex * buf_time;       // [size: M/2 x 1]
     unsigned int    read_index;     // output buffer read index
     unsigned int    num_blocks;     // output buffer read index
 
@@ -83,8 +83,8 @@ MSOURCE() MSOURCE(_create)(unsigned int _M,
 
     q->ch = firpfbch2_crcf_create_kaiser(LIQUID_SYNTHESIZER, q->M, q->m, q->As);
 
-    q->buf_freq = (float complex*) malloc(q->M   * sizeof(float complex)); 
-    q->buf_time = (float complex*) malloc(q->M/2 * sizeof(float complex)); 
+    q->buf_freq = (_Fcomplex*) malloc(q->M   * sizeof(_Fcomplex));
+    q->buf_time = (_Fcomplex*) malloc(q->M/2 * sizeof(_Fcomplex));
 
     q->read_index = q->M/2; // indicate buffer is empty
     q->num_blocks = 0;
@@ -364,7 +364,7 @@ int MSOURCE(_set_frequency)(MSOURCE() _q,
         fprintf(stderr,"error: qsource%s_set_frequency(), signal id (%d) out of range (%u)\n",
                 EXTENSION, _id, _q->num_sources);
         return -1;
-    
+
     }
     // set source frequency
     QSOURCE(_set_frequency)(_q->sources[_id], _dphi);
@@ -386,7 +386,7 @@ int MSOURCE(_get_frequency)(MSOURCE() _q,
         fprintf(stderr,"error: qsource%s_get_frequency(), signal id (%d) out of range (%u)\n",
                 EXTENSION, _id, _q->num_sources);
         return -1;
-    
+
     }
     // set source frequency
     *_dphi = QSOURCE(_get_frequency)(_q->sources[_id]);
@@ -465,7 +465,7 @@ QSOURCE() MSOURCE(_get_source)(MSOURCE() _q,
 void MSOURCE(_generate)(MSOURCE() _q)
 {
     // clear buffer
-    memset(_q->buf_freq, 0, _q->M*sizeof(float complex));
+    memset(_q->buf_freq, 0, _q->M*sizeof(_Fcomplex));
 
     // add sources into main frequency buffer
     unsigned int i;
@@ -480,5 +480,3 @@ void MSOURCE(_generate)(MSOURCE() _q)
     _q->num_blocks++;
     _q->num_samples += _q->M / 2;
 }
-
-
diff --git a/src/framing/src/msourcecf.c b/src/framing/src/msourcecf.c
index 7dbee5cf..00b3a12d 100644
--- a/src/framing/src/msourcecf.c
+++ b/src/framing/src/msourcecf.c
@@ -29,7 +29,7 @@
 // naming extensions (useful for print statements)
 #define EXTENSION           "cf"
 
-#define TO                  float complex   // output type
+#define TO                  _Fcomplex   // output type
 #define T                   float           // primitive type
 
 #define TO_COMPLEX          1
@@ -46,4 +46,3 @@
 // source files
 #include "msource.c"
 #include "qsource.c"
-
diff --git a/src/framing/src/ofdmflexframegen.c b/src/framing/src/ofdmflexframegen.c
index 9e8773bc..a5afd32a 100644
--- a/src/framing/src/ofdmflexframegen.c
+++ b/src/framing/src/ofdmflexframegen.c
@@ -91,8 +91,8 @@ struct ofdmflexframegen_s {
     unsigned int frame_len; // frame length (M + cp_len)
 
     // buffers
-    float complex * X;          // frequency-domain buffer
-    float complex * buf_tx;     // transmit buffer
+    _Fcomplex * X;          // frequency-domain buffer
+    _Fcomplex * buf_tx;     // transmit buffer
     unsigned int    buf_index;  // buffer index
 
     // internal low-level objects
@@ -171,8 +171,8 @@ ofdmflexframegen ofdmflexframegen_create(unsigned int              _M,
 
     // allocate memory for transform buffers
     q->frame_len = q->M + q->cp_len;    // frame length
-    q->X         = (float complex*) malloc((q->M        )*sizeof(float complex));
-    q->buf_tx    = (float complex*) malloc((q->frame_len)*sizeof(float complex));
+    q->X         = (_Fcomplex*) malloc((q->M        )*sizeof(_Fcomplex));
+    q->buf_tx    = (_Fcomplex*) malloc((q->frame_len)*sizeof(_Fcomplex));
     q->buf_index = q->frame_len;
 
     // allocate memory for subcarrier allocation IDs
@@ -453,7 +453,7 @@ void ofdmflexframegen_assemble(ofdmflexframegen      _q,
     // encode payload
     packetizer_encode(_q->p_payload, _payload, _q->payload_enc);
 
-    // 
+    //
     // pack modem symbols
     //
 
@@ -476,7 +476,7 @@ void ofdmflexframegen_assemble(ofdmflexframegen      _q,
 //  _buf            :   output buffer [size: _buf_len x 1]
 //  _buf_len        :   output buffer length
 int ofdmflexframegen_write(ofdmflexframegen _q,
-                           float complex *  _buf,
+                           _Fcomplex *  _buf,
                            unsigned int     _buf_len)
 {
     unsigned int i;
@@ -665,7 +665,7 @@ void ofdmflexframegen_gen_header(ofdmflexframegen _q)
         //
         sctype = _q->p[i];
 
-        // 
+        //
         if (sctype == OFDMFRAME_SCTYPE_DATA) {
             // load...
             if (_q->header_symbol_index < _q->header_sym_len) {
@@ -708,7 +708,7 @@ void ofdmflexframegen_gen_payload(ofdmflexframegen _q)
         //
         sctype = _q->p[i];
 
-        // 
+        //
         if (sctype == OFDMFRAME_SCTYPE_DATA) {
             // load...
             if (_q->payload_symbol_index < _q->payload_mod_len) {
@@ -764,4 +764,3 @@ void ofdmflexframegen_gen_zeros(ofdmflexframegen _q)
     for (i=0; i<_q->frame_len; i++)
         _q->buf_tx[i] = 0.0f;
 }
-
diff --git a/src/framing/src/ofdmflexframesync.c b/src/framing/src/ofdmflexframesync.c
index 0aed2777..c00a48eb 100644
--- a/src/framing/src/ofdmflexframesync.c
+++ b/src/framing/src/ofdmflexframesync.c
@@ -38,26 +38,26 @@
 
 #define OFDMFLEXFRAME_P_SOFT (1)
 
-// 
+//
 // ofdmflexframesync
 //
 
 // internal callback
-int ofdmflexframesync_internal_callback(float complex * _X,
+int ofdmflexframesync_internal_callback(_Fcomplex * _X,
                                         unsigned char * _p,
                                         unsigned int    _M,
                                         void * _userdata);
 
 // receive header data
 void ofdmflexframesync_rxheader(ofdmflexframesync _q,
-                                float complex * _X);
+                                _Fcomplex * _X);
 
 // decode header
 void ofdmflexframesync_decode_header(ofdmflexframesync _q);
 
 // receive payload data
 void ofdmflexframesync_rxpayload(ofdmflexframesync _q,
-                                float complex * _X);
+                                _Fcomplex * _X);
 
 static ofdmflexframegenprops_s ofdmflexframesyncprops_header_default = {
     OFDMFLEXFRAME_H_CRC,
@@ -111,7 +111,7 @@ struct ofdmflexframesync_s {
     unsigned int payload_enc_len;       // length of encoded payload
     unsigned int payload_mod_len;       // number of payload modem symbols
     int payload_valid;                  // valid payload flag
-    float complex * payload_syms;       // received payload symbols
+    _Fcomplex * payload_syms;       // received payload symbols
 
     // callback
     framesync_callback callback;        // user-defined callback function
@@ -209,7 +209,7 @@ ofdmflexframesync ofdmflexframesync_create(unsigned int       _M,
     q->payload_enc_len = packetizer_get_enc_msg_len(q->p_payload);
     q->payload_enc = (unsigned char*) malloc(q->payload_enc_len*sizeof(unsigned char));
     q->payload_dec = (unsigned char*) malloc(q->payload_len*sizeof(unsigned char));
-    q->payload_syms = (float complex *) malloc(q->payload_len*sizeof(float complex));
+    q->payload_syms = (_Fcomplex *) malloc(q->payload_len*sizeof(_Fcomplex));
     q->payload_mod_len = 0;
 
     // reset state
@@ -333,7 +333,7 @@ void ofdmflexframesync_reset(ofdmflexframesync _q)
     _q->header_symbol_index=0;
     _q->payload_symbol_index=0;
     _q->payload_buffer_index=0;
-    
+
     // reset error vector magnitude estimate
     _q->evm_hat = 1e-12f;   // slight offset to ensure no log(0)
 
@@ -351,14 +351,14 @@ int ofdmflexframesync_is_frame_open(ofdmflexframesync _q)
 
 // execute synchronizer object on buffer of samples
 void ofdmflexframesync_execute(ofdmflexframesync _q,
-                               float complex * _x,
+                               _Fcomplex * _x,
                                unsigned int _n)
 {
     // push samples through ofdmframesync object
     ofdmframesync_execute(_q->fs, _x, _n);
 }
 
-// 
+//
 // query methods
 //
 
@@ -384,7 +384,7 @@ void ofdmflexframesync_set_cfo(ofdmflexframesync _q, float _cfo)
     return ofdmframesync_set_cfo(_q->fs, _cfo);
 }
 
-// 
+//
 // debugging methods
 //
 
@@ -416,7 +416,7 @@ void ofdmflexframesync_debug_print(ofdmflexframesync _q,
 //  _p          :   subcarrier allocation
 //  _M          :   number of subcarriers
 //  _userdata   :   user-defined data structure
-int ofdmflexframesync_internal_callback(float complex * _X,
+int ofdmflexframesync_internal_callback(_Fcomplex * _X,
                                         unsigned char * _p,
                                         unsigned int    _M,
                                         void * _userdata)
@@ -452,7 +452,7 @@ int ofdmflexframesync_internal_callback(float complex * _X,
 
 // receive header data
 void ofdmflexframesync_rxheader(ofdmflexframesync _q,
-                                float complex * _X)
+                                _Fcomplex * _X)
 {
 #if DEBUG_OFDMFLEXFRAMESYNC
     printf("  ofdmflexframesync extracting header...\n");
@@ -488,7 +488,7 @@ void ofdmflexframesync_rxheader(ofdmflexframesync _q,
             if (_q->header_symbol_index == _q->header_sym_len) {
                 // decode header
                 ofdmflexframesync_decode_header(_q);
-            
+
                 // compute error vector magnitude estimate
                 _q->framestats.evm = 10*log10f( _q->evm_hat/_q->header_sym_len );
 
@@ -644,7 +644,7 @@ void ofdmflexframesync_decode_header(ofdmflexframesync _q)
         _q->check       = check;
         _q->fec0        = fec0;
         _q->fec1        = fec1;
-        
+
         // recreate packetizer object
         _q->p_payload = packetizer_recreate(_q->p_payload,
                                             _q->payload_len,
@@ -672,7 +672,7 @@ void ofdmflexframesync_decode_header(ofdmflexframesync _q)
         // re-allocate buffers accordingly
         _q->payload_enc = (unsigned char*) realloc(_q->payload_enc, _q->payload_enc_len*sizeof(unsigned char));
         _q->payload_dec = (unsigned char*) realloc(_q->payload_dec, _q->payload_len*sizeof(unsigned char));
-        _q->payload_syms = (float complex*) realloc(_q->payload_syms, _q->payload_mod_len*sizeof(float complex));
+        _q->payload_syms = (_Fcomplex*) realloc(_q->payload_syms, _q->payload_mod_len*sizeof(_Fcomplex));
 #if DEBUG_OFDMFLEXFRAMESYNC
         printf("      * payload mod syms:   %u symbols\n", _q->payload_mod_len);
 #endif
@@ -681,7 +681,7 @@ void ofdmflexframesync_decode_header(ofdmflexframesync _q)
 
 // receive payload data
 void ofdmflexframesync_rxpayload(ofdmflexframesync _q,
-                                 float complex * _X)
+                                 _Fcomplex * _X)
 {
     // demodulate paylod symbols
     unsigned int i;
@@ -762,6 +762,3 @@ void ofdmflexframesync_rxpayload(ofdmflexframesync _q,
         }
     }
 }
-
-
-
diff --git a/src/framing/src/presync.c b/src/framing/src/presync.c
index 9ee26f63..b1475f25 100644
--- a/src/framing/src/presync.c
+++ b/src/framing/src/presync.c
@@ -34,10 +34,10 @@
 struct PRESYNC(_s) {
     unsigned int n;     // sequence length
     unsigned int m;     // number of binary synchronizers
-    
+
     WINDOW() rx_i;      // received pattern (in-phase)
     WINDOW() rx_q;      // received pattern (quadrature)
-    
+
     float * dphi;       // array of frequency offsets [size: m x 1]
     DOTPROD() * sync_i; // synchronization pattern (in-phase)
     DOTPROD() * sync_q; // synchronization pattern (quadrature)
@@ -54,8 +54,8 @@ struct PRESYNC(_s) {
 //  _rxy1   : negative frequency correlation output (conjugated)
 void PRESYNC(_correlate)(PRESYNC()       _q,
                          unsigned int    _id,
-                         float complex * _rxy0,
-                         float complex * _rxy1);
+                         _Fcomplex * _rxy0,
+                         _Fcomplex * _rxy1);
 
 /* create binary pre-demod synchronizer                     */
 /*  _v          :   baseband sequence                       */
@@ -179,10 +179,10 @@ void PRESYNC(_execute)(PRESYNC() _q,
                        float *   _dphi_hat)
 {
     unsigned int i;
-    float complex rxy_max = 0;  // maximum cross-correlation
+    _Fcomplex rxy_max = 0;  // maximum cross-correlation
     float abs_rxy_max = 0;      // absolute value of rxy_max
-    float complex rxy0;
-    float complex rxy1;
+    _Fcomplex rxy0;
+    _Fcomplex rxy1;
     float dphi_hat = 0.0f;
     for (i=0; i<_q->m; i++)  {
 
@@ -218,8 +218,8 @@ void PRESYNC(_execute)(PRESYNC() _q,
 //  _rxy1   : negative frequency correlation output (conjugated)
 void PRESYNC(_correlate)(PRESYNC()       _q,
                          unsigned int    _id,
-                         float complex * _rxy0,
-                         float complex * _rxy1)
+                         _Fcomplex * _rxy0,
+                         _Fcomplex * _rxy1)
 {
     // validate input...
     if (_id >= _q->m) {
@@ -249,4 +249,3 @@ void PRESYNC(_correlate)(PRESYNC()       _q,
     T rxy_q1 = rxy_iq - rxy_qi;
     *_rxy1 = (rxy_i1 + rxy_q1 * _Complex_I) * _q->n_inv;
 }
-
diff --git a/src/framing/src/presync_cccf.c b/src/framing/src/presync_cccf.c
index 347321b9..e6ec3c77 100644
--- a/src/framing/src/presync_cccf.c
+++ b/src/framing/src/presync_cccf.c
@@ -26,7 +26,7 @@
 
 #include "liquid.internal.h"
 
-// 
+//
 #define PRESYNC(name)       LIQUID_CONCAT(presync_cccf,name)
 
 // print and naming extensions
@@ -35,9 +35,9 @@
 #define EXTENSION_FULL      "cccf"
 
 #define T                   float           // primitive type
-#define TO                  float complex   // output type
-#define TC                  float complex   // coefficient type
-#define TI                  float complex   // input type
+#define TO                  _Fcomplex   // output type
+#define TC                  _Fcomplex   // coefficient type
+#define TI                  _Fcomplex   // input type
 
 #define ABS(X)              cabsf(X)
 #define REAL(X)             crealf(X)
@@ -53,4 +53,3 @@
 
 // source files
 #include "presync.c"
-
diff --git a/src/framing/src/qdetector_cccf.c b/src/framing/src/qdetector_cccf.c
index 2e670ac2..2156c692 100644
--- a/src/framing/src/qdetector_cccf.c
+++ b/src/framing/src/qdetector_cccf.c
@@ -38,23 +38,23 @@
 
 // seek signal (initial detection)
 void qdetector_cccf_execute_seek(qdetector_cccf _q,
-                                 float complex  _x);
+                                 _Fcomplex  _x);
 
 // align signal in time, compute offset estimates
 void qdetector_cccf_execute_align(qdetector_cccf _q,
-                                  float complex  _x);
+                                  _Fcomplex  _x);
 
 // main object definition
 struct qdetector_cccf_s {
     unsigned int    s_len;          // template (time) length: k * (sequence_len + 2*m)
-    float complex * s;              // template (time), [size: s_len x 1]
-    float complex * S;              // template (freq), [size: nfft x 1]
+    _Fcomplex * s;              // template (time), [size: s_len x 1]
+    _Fcomplex * S;              // template (freq), [size: nfft x 1]
     float           s2_sum;         // sum{ s^2 }
 
-    float complex * buf_time_0;     // time-domain buffer (FFT)
-    float complex * buf_freq_0;     // frequence-domain buffer (FFT)
-    float complex * buf_freq_1;     // frequence-domain buffer (IFFT)
-    float complex * buf_time_1;     // time-domain buffer (IFFT)
+    _Fcomplex * buf_time_0;     // time-domain buffer (FFT)
+    _Fcomplex * buf_freq_0;     // frequence-domain buffer (FFT)
+    _Fcomplex * buf_freq_1;     // frequence-domain buffer (IFFT)
+    _Fcomplex * buf_time_1;     // time-domain buffer (IFFT)
     unsigned int    nfft;           // fft size
     fftplan         fft;            // FFT object:  buf_time_0 > buf_freq_0
     fftplan         ifft;           // IFFT object: buf_freq_1 > buf_freq_1
@@ -84,7 +84,7 @@ struct qdetector_cccf_s {
 // create detector with generic sequence
 //  _s      :   sample sequence
 //  _s_len  :   length of sample sequence
-qdetector_cccf qdetector_cccf_create(float complex * _s,
+qdetector_cccf qdetector_cccf_create(_Fcomplex * _s,
                                      unsigned int    _s_len)
 {
     // validate input
@@ -92,32 +92,32 @@ qdetector_cccf qdetector_cccf_create(float complex * _s,
         fprintf(stderr,"error: qdetector_cccf_create(), sequence length cannot be zero\n");
         exit(1);
     }
-    
+
     // allocate memory for main object and set internal properties
     qdetector_cccf q = (qdetector_cccf) malloc(sizeof(struct qdetector_cccf_s));
     q->s_len = _s_len;
 
     // allocate memory and copy sequence
-    q->s = (float complex*) malloc(q->s_len * sizeof(float complex));
-    memmove(q->s, _s, q->s_len*sizeof(float complex));
+    q->s = (_Fcomplex*) malloc(q->s_len * sizeof(_Fcomplex));
+    memmove(q->s, _s, q->s_len*sizeof(_Fcomplex));
     q->s2_sum = liquid_sumsqcf(q->s, q->s_len); // compute sum{ s^2 }
 
     // prepare transforms
     q->nfft       = 1 << liquid_nextpow2( (unsigned int)( 2 * q->s_len ) ); // NOTE: must be even
-    q->buf_time_0 = (float complex*) malloc(q->nfft * sizeof(float complex));
-    q->buf_freq_0 = (float complex*) malloc(q->nfft * sizeof(float complex));
-    q->buf_freq_1 = (float complex*) malloc(q->nfft * sizeof(float complex));
-    q->buf_time_1 = (float complex*) malloc(q->nfft * sizeof(float complex));
+    q->buf_time_0 = (_Fcomplex*) malloc(q->nfft * sizeof(_Fcomplex));
+    q->buf_freq_0 = (_Fcomplex*) malloc(q->nfft * sizeof(_Fcomplex));
+    q->buf_freq_1 = (_Fcomplex*) malloc(q->nfft * sizeof(_Fcomplex));
+    q->buf_time_1 = (_Fcomplex*) malloc(q->nfft * sizeof(_Fcomplex));
 
     q->fft  = fft_create_plan(q->nfft, q->buf_time_0, q->buf_freq_0, LIQUID_FFT_FORWARD,  0);
     q->ifft = fft_create_plan(q->nfft, q->buf_freq_1, q->buf_time_1, LIQUID_FFT_BACKWARD, 0);
 
     // create frequency-domain template by taking nfft-point transform on 's', storing in 'S'
-    q->S = (float complex*) malloc(q->nfft * sizeof(float complex));
-    memset(q->buf_time_0, 0x00, q->nfft*sizeof(float complex));
-    memmove(q->buf_time_0, q->s, q->s_len*sizeof(float complex));
+    q->S = (_Fcomplex*) malloc(q->nfft * sizeof(_Fcomplex));
+    memset(q->buf_time_0, 0x00, q->nfft*sizeof(_Fcomplex));
+    memmove(q->buf_time_0, q->s, q->s_len*sizeof(_Fcomplex));
     fft_execute(q->fft);
-    memmove(q->S, q->buf_freq_0, q->nfft*sizeof(float complex));
+    memmove(q->S, q->buf_freq_0, q->nfft*sizeof(_Fcomplex));
 
     // reset state variables
     q->counter        = q->nfft/2;
@@ -126,8 +126,8 @@ qdetector_cccf qdetector_cccf_create(float complex * _s,
     q->x2_sum_1       = 0.0f;
     q->state          = QDETECTOR_STATE_SEEK;
     q->frame_detected = 0;
-    memset(q->buf_time_0, 0x00, q->nfft*sizeof(float complex));
-    
+    memset(q->buf_time_0, 0x00, q->nfft*sizeof(_Fcomplex));
+
     // reset estimates
     q->rxy       = 0.0f;
     q->tau_hat   = 0.0f;
@@ -150,7 +150,7 @@ qdetector_cccf qdetector_cccf_create(float complex * _s,
 //  _k              :   samples/symbol
 //  _m              :   filter delay
 //  _beta           :   excess bandwidth factor
-qdetector_cccf qdetector_cccf_create_linear(float complex * _sequence,
+qdetector_cccf qdetector_cccf_create_linear(_Fcomplex * _sequence,
                                             unsigned int    _sequence_len,
                                             int             _ftype,
                                             unsigned int    _k,
@@ -171,10 +171,10 @@ qdetector_cccf qdetector_cccf_create_linear(float complex * _sequence,
         fprintf(stderr,"error: qdetector_cccf_create_linear(), excess bandwidth factor must be in [0,1]\n");
         exit(1);
     }
-    
+
     // create time-domain template
     unsigned int    s_len = _k * (_sequence_len + 2*_m);
-    float complex * s     = (float complex*) malloc(s_len * sizeof(float complex));
+    _Fcomplex * s     = (_Fcomplex*) malloc(s_len * sizeof(_Fcomplex));
     firinterp_crcf interp = firinterp_crcf_create_prototype(_ftype, _k, _m, _beta, 0);
     unsigned int i;
     for (i=0; i<_sequence_len + 2*_m; i++)
@@ -217,10 +217,10 @@ qdetector_cccf qdetector_cccf_create_gmsk(unsigned char * _sequence,
         fprintf(stderr,"error: qdetector_cccf_create_gmsk(), excess bandwidth factor must be in [0,1]\n");
         exit(1);
     }
-    
+
     // create time-domain template using GMSK modem
     unsigned int    s_len = _k * (_sequence_len + 2*_m);
-    float complex * s     = (float complex*) malloc(s_len * sizeof(float complex));
+    _Fcomplex * s     = (_Fcomplex*) malloc(s_len * sizeof(_Fcomplex));
     gmskmod mod = gmskmod_create(_k, _m, _beta);
     unsigned int i;
     for (i=0; i<_sequence_len + 2*_m; i++)
@@ -272,7 +272,7 @@ qdetector_cccf qdetector_cccf_create_cpfsk(unsigned char * _sequence,
 
     // create time-domain template using GMSK modem
     unsigned int    s_len = _k * (_sequence_len + 2*_m);
-    float complex * s     = (float complex*) malloc(s_len * sizeof(float complex));
+    _Fcomplex * s     = (_Fcomplex*) malloc(s_len * sizeof(_Fcomplex));
     cpfskmod mod = cpfskmod_create(_bps, _h, _k, _m, _beta, _type);
     unsigned int i;
     for (i=0; i<_sequence_len + 2*_m; i++)
@@ -322,7 +322,7 @@ void qdetector_cccf_reset(qdetector_cccf _q)
 }
 
 void * qdetector_cccf_execute(qdetector_cccf _q,
-                              float complex  _x)
+                              _Fcomplex  _x)
 {
     switch (_q->state) {
     case QDETECTOR_STATE_SEEK:
@@ -432,7 +432,7 @@ float qdetector_cccf_get_phi(qdetector_cccf _q)
 
 // seek signal (initial detection)
 void qdetector_cccf_execute_seek(qdetector_cccf _q,
-                                 float complex  _x)
+                                 _Fcomplex  _x)
 {
     // write sample to buffer and increment counter
     _q->buf_time_0[_q->counter++] = _x;
@@ -442,7 +442,7 @@ void qdetector_cccf_execute_seek(qdetector_cccf _q,
 
     if (_q->counter < _q->nfft)
         return;
-    
+
     // reset counter (last half of time buffer)
     _q->counter = _q->nfft/2;
 
@@ -467,7 +467,7 @@ void qdetector_cccf_execute_seek(qdetector_cccf _q,
         return;
     }
     float g = 1.0f / ((float)(_q->nfft) * g0 * sqrtf(_q->s2_sum));
-    
+
     // sweep over carrier frequency offset range
     int offset;
     unsigned int i;
@@ -487,7 +487,7 @@ void qdetector_cccf_execute_seek(qdetector_cccf _q,
 
         // run inverse transform
         fft_execute(_q->ifft);
-        
+
         // scale output appropriately
         liquid_vectorcf_mulscalar(_q->buf_time_1, _q->nfft, g, _q->buf_time_1);
 
@@ -536,7 +536,7 @@ void qdetector_cccf_execute_seek(qdetector_cccf _q,
         // TODO: check for edge case where rxy_index is zero (signal already aligned)
 
         // copy last part of fft input buffer to front
-        memmove(_q->buf_time_0, _q->buf_time_0 + rxy_index, (_q->nfft - rxy_index)*sizeof(float complex));
+        memmove(_q->buf_time_0, _q->buf_time_0 + rxy_index, (_q->nfft - rxy_index)*sizeof(_Fcomplex));
         _q->counter = _q->nfft - rxy_index;
 
         return;
@@ -544,9 +544,9 @@ void qdetector_cccf_execute_seek(qdetector_cccf _q,
 #if DEBUG_QDETECTOR_PRINT
     printf(" no detect, rxy = %12.8f, time index=%u, freq. offset=%d\n", rxy_peak, rxy_index, rxy_offset);
 #endif
-    
+
     // copy last half of fft input buffer to front
-    memmove(_q->buf_time_0, _q->buf_time_0 + _q->nfft/2, (_q->nfft/2)*sizeof(float complex));
+    memmove(_q->buf_time_0, _q->buf_time_0 + _q->nfft/2, (_q->nfft/2)*sizeof(_Fcomplex));
 
     // swap accumulated signal levels
     _q->x2_sum_0 = _q->x2_sum_1;
@@ -555,7 +555,7 @@ void qdetector_cccf_execute_seek(qdetector_cccf _q,
 
 // align signal in time, compute offset estimates
 void qdetector_cccf_execute_align(qdetector_cccf _q,
-                                  float complex  _x)
+                                  _Fcomplex  _x)
 {
     // write sample to buffer and increment counter
     _q->buf_time_0[_q->counter++] = _x;
@@ -592,7 +592,7 @@ void qdetector_cccf_execute_align(qdetector_cccf _q,
     // TODO: revise estimate of rxy here
 
     // copy buffer to preserve data integrity
-    memmove(_q->buf_time_1, _q->buf_time_0, _q->nfft*sizeof(float complex));
+    memmove(_q->buf_time_1, _q->buf_time_0, _q->nfft*sizeof(_Fcomplex));
 
     // estimate carrier frequency offset
     for (i=0; i<_q->nfft; i++)
@@ -651,7 +651,7 @@ void qdetector_cccf_execute_align(qdetector_cccf _q,
     // METHOD 2: compute metric by de-rotating signal and measuring resulting phase
     // NOTE: this is possibly more accurate than the above method but might also
     //       be more computationally complex
-    float complex metric = 0;
+    _Fcomplex metric = 0;
     for (i=0; i<_q->s_len; i++)
         metric += _q->buf_time_0[i] * cexpf(-_Complex_I*_q->dphi_hat*i);
     //printf("metric : %12.8f <%12.8f>\n", cabsf(metric), cargf(metric));
@@ -677,10 +677,9 @@ void qdetector_cccf_execute_align(qdetector_cccf _q,
 
     // reset state
     // copy saved buffer state (last half of buf_time_1 to front half of buf_time_0)
-    memmove(_q->buf_time_0, _q->buf_time_1 + _q->nfft/2, (_q->nfft/2)*sizeof(float complex));
+    memmove(_q->buf_time_0, _q->buf_time_1 + _q->nfft/2, (_q->nfft/2)*sizeof(_Fcomplex));
     _q->state = QDETECTOR_STATE_SEEK;
     _q->x2_sum_0 = liquid_sumsqcf(_q->buf_time_0, _q->nfft/2);
     _q->x2_sum_1 = 0;
     _q->counter = _q->nfft/2;
 }
-
diff --git a/src/framing/src/qpacketmodem.c b/src/framing/src/qpacketmodem.c
index 1ea283b5..e1223d51 100644
--- a/src/framing/src/qpacketmodem.c
+++ b/src/framing/src/qpacketmodem.c
@@ -58,7 +58,7 @@ qpacketmodem qpacketmodem_create()
     // create payload modem (initially QPSK, overridden by properties)
     q->mod_payload = modem_create(LIQUID_MODEM_QPSK);
     q->bits_per_symbol = 2;
-    
+
     // initial memory allocation for payload
     q->payload_dec_len = 1;
     q->p = packetizer_create(q->payload_dec_len,
@@ -68,7 +68,7 @@ qpacketmodem qpacketmodem_create()
 
     // number of bytes in encoded payload
     q->payload_enc_len = packetizer_get_enc_msg_len(q->p);
-    
+
     // number of bits in encoded payload
     q->payload_bit_len = 8*q->payload_enc_len;
 
@@ -267,7 +267,7 @@ int qpacketmodem_decode_bits(qpacketmodem    _q,
 //  _frame      :   encoded/modulated payload symbols
 void qpacketmodem_encode(qpacketmodem          _q,
                          const unsigned char * _payload,
-                         float complex *       _frame)
+                         _Fcomplex *       _frame)
 {
     // encode payload symbols into internal buffer
     qpacketmodem_encode_syms(_q, _payload, _q->payload_mod);
@@ -283,7 +283,7 @@ void qpacketmodem_encode(qpacketmodem          _q,
 //  _frame      :   encoded/modulated payload symbols
 //  _payload    :   recovered decoded payload bytes
 int qpacketmodem_decode(qpacketmodem    _q,
-                        float complex * _frame,
+                        _Fcomplex * _frame,
                         unsigned char * _payload)
 {
     unsigned int i;
@@ -312,7 +312,7 @@ int qpacketmodem_decode(qpacketmodem    _q,
 //  _frame      :   encoded/modulated payload symbols
 //  _payload    :   recovered decoded payload bytes
 int qpacketmodem_decode_soft(qpacketmodem    _q,
-                             float complex * _frame,
+                             _Fcomplex * _frame,
                              unsigned char * _payload)
 {
     unsigned int i;
@@ -337,7 +337,7 @@ int qpacketmodem_decode_soft(qpacketmodem    _q,
 //  _q          :   qpacketmodem object
 //  _frame      :   encoded/modulated symbol
 int qpacketmodem_decode_soft_sym(qpacketmodem  _q,
-                                 float complex _symbol)
+                                 _Fcomplex _symbol)
 {
     unsigned int sym;
     modem_demodulate_soft(_q->mod_payload, _symbol, &sym, _q->payload_enc + _q->n);
diff --git a/src/framing/src/qpilotgen.c b/src/framing/src/qpilotgen.c
index fd59c54e..8d4549f0 100644
--- a/src/framing/src/qpilotgen.c
+++ b/src/framing/src/qpilotgen.c
@@ -59,7 +59,7 @@ struct qpilotgen_s {
     unsigned int    pilot_spacing;  // spacing between pilot symbols
     unsigned int    num_pilots;     // total number of pilot symbols
     unsigned int    frame_len;      // total number of frame symbols
-    float complex * pilots;         // pilot sequence
+    _Fcomplex * pilots;         // pilot sequence
 };
 
 // create packet encoder
@@ -88,7 +88,7 @@ qpilotgen qpilotgen_create(unsigned int _payload_len,
     q->frame_len  = q->payload_len + q->num_pilots;
 
     // allocate memory for pilots
-    q->pilots = (float complex*) malloc(q->num_pilots*sizeof(float complex));
+    q->pilots = (_Fcomplex*) malloc(q->num_pilots*sizeof(_Fcomplex));
 
     // find appropriate sequence size
     unsigned int m = liquid_nextpow2(q->num_pilots);
@@ -128,7 +128,7 @@ void qpilotgen_destroy(qpilotgen _q)
 {
     // free arrays
     free(_q->pilots);
-    
+
     // free main object memory
     free(_q);
 }
@@ -156,8 +156,8 @@ unsigned int qpilotgen_get_frame_len(qpilotgen _q)
 // TODO: include method with just symbol indices? would be useful for
 //       non-linear modulation types
 void qpilotgen_execute(qpilotgen       _q,
-                       float complex * _payload,
-                       float complex * _frame)
+                       _Fcomplex * _payload,
+                       _Fcomplex * _frame)
 {
     unsigned int i;
     unsigned int n = 0;
@@ -173,4 +173,3 @@ void qpilotgen_execute(qpilotgen       _q,
     assert(n == _q->payload_len);
     assert(p == _q->num_pilots);
 }
-
diff --git a/src/framing/src/qpilotsync.c b/src/framing/src/qpilotsync.c
index cdb56939..ac52d2d1 100644
--- a/src/framing/src/qpilotsync.c
+++ b/src/framing/src/qpilotsync.c
@@ -44,11 +44,11 @@ struct qpilotsync_s {
     unsigned int    pilot_spacing;  // spacing between pilot symbols
     unsigned int    num_pilots;     // total number of pilot symbols
     unsigned int    frame_len;      // total number of frame symbols
-    float complex * pilots;         // pilot sequence
+    _Fcomplex * pilots;         // pilot sequence
 
     unsigned int    nfft;           // FFT size
-    float complex * buf_time;       // FFT time buffer
-    float complex * buf_freq;       // FFT freq buffer
+    _Fcomplex * buf_time;       // FFT time buffer
+    _Fcomplex * buf_freq;       // FFT freq buffer
     fftplan         fft;            // transform object
 
     float           dphi_hat;       // carrier frequency offset estimate
@@ -83,7 +83,7 @@ qpilotsync qpilotsync_create(unsigned int _payload_len,
 
 
     // allocate memory for pilots
-    q->pilots = (float complex*) malloc(q->num_pilots*sizeof(float complex));
+    q->pilots = (_Fcomplex*) malloc(q->num_pilots*sizeof(_Fcomplex));
 
     // find appropriate sequence size
     unsigned int m = liquid_nextpow2(q->num_pilots);
@@ -102,8 +102,8 @@ qpilotsync qpilotsync_create(unsigned int _payload_len,
 
     // compute fft size and create transform objects
     q->nfft = 1 << liquid_nextpow2(q->num_pilots + (q->num_pilots>>1));
-    q->buf_time = (float complex*) malloc(q->nfft*sizeof(float complex));
-    q->buf_freq = (float complex*) malloc(q->nfft*sizeof(float complex));
+    q->buf_time = (_Fcomplex*) malloc(q->nfft*sizeof(_Fcomplex));
+    q->buf_freq = (_Fcomplex*) malloc(q->nfft*sizeof(_Fcomplex));
     q->fft      = fft_create_plan(q->nfft, q->buf_time, q->buf_freq, LIQUID_FFT_FORWARD, 0);
 
     // reset and return pointer to main object
@@ -135,7 +135,7 @@ void qpilotsync_destroy(qpilotsync _q)
 
     // destroy objects
     fft_destroy_plan(_q->fft);
-    
+
     // free main object memory
     free(_q);
 }
@@ -146,7 +146,7 @@ void qpilotsync_reset(qpilotsync _q)
     unsigned int i;
     for (i=0; i<_q->nfft; i++)
         _q->buf_time[i] = 0.0f;
-    
+
     // reset estimates
     _q->dphi_hat = 0.0f;
     _q->phi_hat  = 0.0f;
@@ -173,8 +173,8 @@ unsigned int qpilotsync_get_frame_len(qpilotsync _q)
 // TODO: include method with just symbol indices? would be useful for
 //       non-linear modulation types
 void qpilotsync_execute(qpilotsync      _q,
-                        float complex * _frame,
-                        float complex * _payload)
+                        _Fcomplex * _frame,
+                        _Fcomplex * _payload)
 {
     unsigned int i;
     unsigned int n = 0;
@@ -247,7 +247,7 @@ void qpilotsync_execute(qpilotsync      _q,
     // METHOD 2: compute metric by de-rotating pilots and measuring resulting phase
     // NOTE: this is possibly more accurate than the above method but might also
     //       be more computationally complex
-    float complex metric = 0;
+    _Fcomplex metric = 0;
     for (i=0; i<_q->num_pilots; i++)
         metric += _q->buf_time[i] * cexpf(-_Complex_I*_q->dphi_hat*i*(float)(_q->pilot_spacing));
     //printf("metric : %12.8f <%12.8f>\n", cabsf(metric), cargf(metric));
@@ -295,5 +295,3 @@ float qpilotsync_get_gain(qpilotsync _q)
 {
     return _q->g_hat;
 }
-
-
diff --git a/src/framing/src/qsource.c b/src/framing/src/qsource.c
index f32504d9..991fc4b2 100644
--- a/src/framing/src/qsource.c
+++ b/src/framing/src/qsource.c
@@ -49,9 +49,9 @@ struct QSOURCE(_s)
     float           gain;       // signal gain (user defined)
     float           gain_ch;    // channelizer gain
     unsigned int    buf_len;    // temporary buffer for resampler output
-    float complex * buf;        // sample buffer (resamp output), [size: buf_len x 1]
-    float complex * buf_time;   // channelizer input buffer, [size: P/2 x 1]
-    float complex * buf_freq;   // channelizer input buffer, [size: P   x 1]
+    _Fcomplex * buf;        // sample buffer (resamp output), [size: buf_len x 1]
+    _Fcomplex * buf_time;   // channelizer input buffer, [size: P/2 x 1]
+    _Fcomplex * buf_freq;   // channelizer input buffer, [size: P   x 1]
     firpfbch2_crcf  ch;         // analysis channelizer
     int             enabled;    // signal enabled?
     uint64_t        num_samples;// total number of output samples generated
@@ -75,8 +75,8 @@ struct QSOURCE(_s)
         struct { NCO() nco; float df; int negate, single; uint64_t num, timer; } chirp;
         struct { } noise;
         struct { SYMSTREAM() symstream; } linmod;
-        struct { fskmod mod; float complex * buf; unsigned int len, index, mask; } fsk;
-        struct { gmskmod mod; float complex buf[2]; int index; } gmsk;
+        struct { fskmod mod; _Fcomplex * buf; unsigned int len, index, mask; } fsk;
+        struct { gmskmod mod; _Fcomplex buf[2]; int index; } gmsk;
     } source;
 };
 
@@ -138,9 +138,9 @@ QSOURCE() QSOURCE(_create)(unsigned int _M,
 
     // create buffers
     q->buf_len  = 64;
-    q->buf      = (float complex*) malloc(q->buf_len * sizeof(float complex));
-    q->buf_time = (float complex*) malloc(q->P/2     * sizeof(float complex));
-    q->buf_freq = (float complex*) malloc(q->P       * sizeof(float complex));
+    q->buf      = (_Fcomplex*) malloc(q->buf_len * sizeof(_Fcomplex));
+    q->buf_time = (_Fcomplex*) malloc(q->P/2     * sizeof(_Fcomplex));
+    q->buf_freq = (_Fcomplex*) malloc(q->P       * sizeof(_Fcomplex));
 
     // create channelizer
     q->ch = firpfbch2_crcf_create_kaiser(LIQUID_ANALYZER, q->P, q->m, q->As);
@@ -254,7 +254,7 @@ void QSOURCE(_init_fsk)(QSOURCE()    _q,
     _q->type            = QSOURCE_FSK;
     _q->source.fsk.mod  = fskmod_create(_m, _k, 0.25f);
     _q->source.fsk.len  = _k;   // buffer length
-    _q->source.fsk.buf  = (float complex*)malloc(_k*sizeof(float complex));
+    _q->source.fsk.buf  = (_Fcomplex*)malloc(_k*sizeof(_Fcomplex));
     _q->source.fsk.mask = (1 << _m) - 1;
     _q->source.fsk.index= 0;
 }
@@ -412,7 +412,7 @@ void QSOURCE(_generate)(QSOURCE() _q,
         fprintf(stderr,"error: qsource%s_generate(), internal logic error\n", EXTENSION);
         exit(1);
     }
-    
+
     if (!_q->enabled)
         sample = 0.0f;
 
@@ -456,7 +456,6 @@ void QSOURCE(_generate_into)(QSOURCE() _q,
     base_index -= P2;
     for (i=0; i<P2; i++)
         _buf[ (base_index+i) % _q->M ] += _q->buf_freq[i+P2] * g;
-    
+
     _q->num_samples += P2;
 }
-
diff --git a/src/framing/src/symstreamcf.c b/src/framing/src/symstreamcf.c
index 81ddc1f2..6ebf0d01 100644
--- a/src/framing/src/symstreamcf.c
+++ b/src/framing/src/symstreamcf.c
@@ -29,7 +29,7 @@
 // naming extensions (useful for print statements)
 #define EXTENSION           "cf"
 
-#define TO                  float complex   // output type
+#define TO                  _Fcomplex   // output type
 #define T                   float           // primitive type
 
 #define TO_COMPLEX          1
@@ -42,4 +42,3 @@
 
 // source files
 #include "symstream.c"
-
diff --git a/src/framing/src/symtrack_cccf.c b/src/framing/src/symtrack_cccf.c
index c5480a6f..cc5239c8 100644
--- a/src/framing/src/symtrack_cccf.c
+++ b/src/framing/src/symtrack_cccf.c
@@ -33,9 +33,9 @@
 #define PRINTVAL(x)         printf("%12.4e + j%12.4e", crealf(x), cimagf(x))
 
 #define T                   float
-#define TO                  float complex
-#define TC                  float complex
-#define TI                  float complex
+#define TO                  _Fcomplex
+#define TC                  _Fcomplex
+#define TI                  _Fcomplex
 #define ABS(X)              cabsf(X)
 
 // object references
@@ -52,4 +52,3 @@
 
 // source files
 #include "symtrack.c"
-
diff --git a/src/framing/tests/bsync_autotest.c b/src/framing/tests/bsync_autotest.c
index bf24462c..7c3526b8 100644
--- a/src/framing/tests/bsync_autotest.c
+++ b/src/framing/tests/bsync_autotest.c
@@ -23,16 +23,16 @@
 #include "autotest/autotest.h"
 #include "liquid.h"
 
-// 
+//
 // AUTOTEST: bsync_rrrf/simple correlation
 //
 void autotest_bsync_rrrf_15()
 {
     // generate sequence (15-bit msequence)
     float h[15] = {
-         1.0,  1.0,  1.0,  1.0, 
-        -1.0,  1.0, -1.0,  1.0, 
-         1.0, -1.0, -1.0,  1.0, 
+         1.0,  1.0,  1.0,  1.0,
+        -1.0,  1.0, -1.0,  1.0,
+         1.0, -1.0, -1.0,  1.0,
         -1.0, -1.0, -1.0
     };
     float tol = 1e-3f;
@@ -40,7 +40,7 @@ void autotest_bsync_rrrf_15()
     // generate synchronizer
     bsync_rrrf fs = bsync_rrrf_create(15,h);
 
-    // 
+    //
     // run tests
     //
     unsigned int i;
@@ -64,16 +64,16 @@ void autotest_bsync_rrrf_15()
 }
 
 
-// 
+//
 // AUTOTEST: bsync_crcf/simple correlation
 //
 void autotest_bsync_crcf_15()
 {
     // generate sequence (15-bit msequence)
     float h[15] = {
-         1.0,  1.0,  1.0,  1.0, 
-        -1.0,  1.0, -1.0,  1.0, 
-         1.0, -1.0, -1.0,  1.0, 
+         1.0,  1.0,  1.0,  1.0,
+        -1.0,  1.0, -1.0,  1.0,
+         1.0, -1.0, -1.0,  1.0,
         -1.0, -1.0, -1.0
     };
     float tol = 1e-3f;
@@ -81,11 +81,11 @@ void autotest_bsync_crcf_15()
     // generate synchronizer
     bsync_crcf fs = bsync_crcf_create(15,h);
 
-    // 
+    //
     // run tests
     //
     unsigned int i;
-    float complex rxy;
+    _Fcomplex rxy;
 
     // fill buffer with sequence
     for (i=0; i<15; i++)
@@ -106,7 +106,7 @@ void autotest_bsync_crcf_15()
     bsync_crcf_destroy(fs);
 }
 
-// 
+//
 // AUTOTEST: bsync_crcf/simple correlation with phase
 //           offset
 //
@@ -114,9 +114,9 @@ void xautotest_bsync_crcf_phase_15()
 {
     // generate sequence (15-bit msequence)
     float h[15] = {
-         1.0,  1.0,  1.0,  1.0, 
-        -1.0,  1.0, -1.0,  1.0, 
-         1.0, -1.0, -1.0,  1.0, 
+         1.0,  1.0,  1.0,  1.0,
+        -1.0,  1.0, -1.0,  1.0,
+         1.0, -1.0, -1.0,  1.0,
         -1.0, -1.0, -1.0
     };
     float tol = 1e-3f;
@@ -125,11 +125,11 @@ void xautotest_bsync_crcf_phase_15()
     // generate synchronizer
     bsync_crcf fs = bsync_crcf_create(15,h);
 
-    // 
+    //
     // run tests
     //
     unsigned int i;
-    float complex rxy;
+    _Fcomplex rxy;
 
     // fill buffer with sequence
     for (i=0; i<15; i++)
@@ -149,4 +149,3 @@ void xautotest_bsync_crcf_phase_15()
     // clean it up
     bsync_crcf_destroy(fs);
 }
-
diff --git a/src/framing/tests/detector_autotest.c b/src/framing/tests/detector_autotest.c
index 319c518b..bd855867 100644
--- a/src/framing/tests/detector_autotest.c
+++ b/src/framing/tests/detector_autotest.c
@@ -76,14 +76,14 @@ void detector_cccf_runtest(unsigned int _n,
     float delay = (float)(_n + m) + _dt;    // expected delay
 
     // arrays
-    float complex s[_n];            // synchronization pattern (samples)
-    float complex x[num_samples];   // resampled signal with noise and offsets
+    _Fcomplex s[_n];            // synchronization pattern (samples)
+    _Fcomplex x[num_samples];   // resampled signal with noise and offsets
 
     // generate synchronization pattern (two samples per symbol)
     unsigned int n2 = (_n - (_n%2)) / 2;    // n2 = floor(n/2)
     unsigned int mm = liquid_nextpow2(n2);  // mm = ceil( log2(n2) )
     msequence ms = msequence_create_default(mm);
-    float complex v = 0.0f;
+    _Fcomplex v = 0.0f;
     for (i=0; i<_n; i++) {
         if ( (i%2)==0 )
             v = msequence_advance(ms) ? 1.0f : -1.0f;
@@ -112,13 +112,13 @@ void detector_cccf_runtest(unsigned int _n,
         // add noise
         x[i] += nstd * ( randnf() + _Complex_I*randnf() ) * M_SQRT1_2;
     }
-    
+
     // destroy fractional sample interpolator
     firfilt_crcf_destroy(finterp);
 
     // create detector
     detector_cccf sync = detector_cccf_create(s, _n, threshold, 2*_dphi);
-    
+
     // push signal through detector
     float tau_hat   = 0.0f;     // fractional sample offset estimate
     float dphi_hat  = 0.0f;     // carrier offset estimate
@@ -126,7 +126,7 @@ void detector_cccf_runtest(unsigned int _n,
     float delay_hat = 0.0f;     // total delay offset estimate
     int signal_detected = 0;    // signal detected flag
     for (i=0; i<num_samples; i++) {
-        
+
         // correlate
         int detected = detector_cccf_correlate(sync, x[i], &tau_hat, &dphi_hat, &gamma_hat);
 
@@ -139,14 +139,14 @@ void detector_cccf_runtest(unsigned int _n,
             }
         }
     }
-    
+
     // destroy objects
     detector_cccf_destroy(sync);
 
-    // 
+    //
     // run tests
     //
-    
+
     // convert to dB
     gamma     = 20*log10f(gamma);
     gamma_hat = 20*log10f(gamma_hat);
@@ -163,12 +163,10 @@ void detector_cccf_runtest(unsigned int _n,
 
     // check carrier offset estimate
     CONTEND_DELTA( dphi_hat, _dphi, 0.01f );
-    
+
     // check delay estimate
     CONTEND_DELTA( delay_hat, delay, 0.2f );
-    
+
     // check signal level estimate
     CONTEND_DELTA( gamma_hat, gamma, 2.0f );
 }
-
-
diff --git a/src/framing/tests/flexframesync_autotest.c b/src/framing/tests/flexframesync_autotest.c
index 588915ae..3ec1e251 100644
--- a/src/framing/tests/flexframesync_autotest.c
+++ b/src/framing/tests/flexframesync_autotest.c
@@ -26,7 +26,7 @@
 #include "autotest/autotest.h"
 #include "liquid.h"
 
-// 
+//
 // AUTOTEST : test simple recovery of frame in noise
 //
 void autotest_flexframesync()
@@ -50,13 +50,13 @@ void autotest_flexframesync()
 
     // create flexframesync object
     flexframesync fs = flexframesync_create(NULL,NULL);
-    
+
     // initialize header and payload
     unsigned char header[14] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};
     unsigned char payload[_payload_len];
     for (i=0; i<_payload_len; i++)
         payload[i] = rand() & 0xff;
-    
+
     // assemble the frame
     flexframegen_assemble(fg, header, payload, _payload_len);
     if (liquid_autotest_verbose)
@@ -64,7 +64,7 @@ void autotest_flexframesync()
 
     // generate the frame
     int frame_complete = 0;
-    float complex buf[2];
+    _Fcomplex buf[2];
     while (!frame_complete) {
         // write samples to buffer
         frame_complete = flexframegen_write_samples(fg, buf, 2);
@@ -88,4 +88,3 @@ void autotest_flexframesync()
     flexframegen_destroy(fg);
     flexframesync_destroy(fs);
 }
-
diff --git a/src/framing/tests/framesync64_autotest.c b/src/framing/tests/framesync64_autotest.c
index f5e79167..79e76f5e 100644
--- a/src/framing/tests/framesync64_autotest.c
+++ b/src/framing/tests/framesync64_autotest.c
@@ -41,11 +41,11 @@ static int callback(unsigned char *  _header,
         *frame_recovered = 1;
     else
         *frame_recovered = 0;
-    
+
     return 0;
 }
 
-// 
+//
 // AUTOTEST : test simple recovery of frame in noise
 //
 void autotest_framesync64()
@@ -60,11 +60,11 @@ void autotest_framesync64()
     // initialize payload
     for (i=0; i<64; i++)
         payload[i] = rand() & 0xff;
-    
+
     // create framesync64 object
     int frame_recovered = 0;
     framesync64 fs = framesync64_create(callback,(void*)&frame_recovered);
-    
+
     if (liquid_autotest_verbose) {
         framesync64_print(fs);
         framegen64_print(fg);
@@ -72,7 +72,7 @@ void autotest_framesync64()
 
     // generate the frame
     unsigned int frame_len = LIQUID_FRAME64_LEN;
-    float complex frame[frame_len];
+    _Fcomplex frame[frame_len];
     framegen64_execute(fg, header, payload, frame);
 
     // add some noise
@@ -89,4 +89,3 @@ void autotest_framesync64()
     framegen64_destroy(fg);
     framesync64_destroy(fs);
 }
-
diff --git a/src/framing/tests/qdetector_cccf_autotest.c b/src/framing/tests/qdetector_cccf_autotest.c
index 02da2dab..769732fa 100644
--- a/src/framing/tests/qdetector_cccf_autotest.c
+++ b/src/framing/tests/qdetector_cccf_autotest.c
@@ -78,11 +78,11 @@ void qdetector_cccf_runtest_linear(unsigned int _sequence_len)
     unsigned int num_samples = k * num_symbols;
 
     // arrays
-    float complex x[num_samples];   // transmitted signal
-    float complex y[num_samples];   // received signal
+    _Fcomplex x[num_samples];   // transmitted signal
+    _Fcomplex y[num_samples];   // received signal
 
     // generate synchronization sequence (QPSK symbols)
-    float complex sequence[_sequence_len];
+    _Fcomplex sequence[_sequence_len];
     for (i=0; i<_sequence_len; i++) {
         sequence[i] = (rand() % 2 ? 1.0f : -1.0f) * M_SQRT1_2 +
                       (rand() % 2 ? 1.0f : -1.0f) * M_SQRT1_2 * _Complex_I;
@@ -93,7 +93,7 @@ void qdetector_cccf_runtest_linear(unsigned int _sequence_len)
     unsigned int n = 0;
     for (i=0; i<num_symbols; i++) {
         // original sequence, then random symbols
-        float complex sym = i < _sequence_len ? sequence[i] : sequence[rand()%_sequence_len];
+        _Fcomplex sym = i < _sequence_len ? sequence[i] : sequence[rand()%_sequence_len];
 
         // interpolate
         firinterp_crcf_execute(interp, sym, &x[n]);
@@ -128,7 +128,7 @@ void qdetector_cccf_runtest_linear(unsigned int _sequence_len)
     unsigned int buf_len = qdetector_cccf_get_buf_len(q);
 
     // try to detect frame
-    float complex * v = NULL;
+    _Fcomplex * v = NULL;
     for (i=0; i<num_samples; i++) {
         if (frame_detected)
             break;
@@ -202,8 +202,8 @@ void qdetector_cccf_runtest_gmsk(unsigned int _sequence_len)
     unsigned int num_samples = k * num_symbols;
 
     // arrays
-    float complex x[num_samples];   // transmitted signal
-    float complex y[num_samples];   // received signal
+    _Fcomplex x[num_samples];   // transmitted signal
+    _Fcomplex y[num_samples];   // received signal
 
     // generate synchronization sequence (QPSK symbols)
     unsigned char sequence[_sequence_len];
@@ -250,7 +250,7 @@ void qdetector_cccf_runtest_gmsk(unsigned int _sequence_len)
     unsigned int buf_len = qdetector_cccf_get_buf_len(q);
 
     // try to detect frame
-    float complex * v = NULL;
+    _Fcomplex * v = NULL;
     for (i=0; i<num_samples; i++) {
         if (frame_detected)
             break;
@@ -304,5 +304,3 @@ void qdetector_cccf_runtest_gmsk(unsigned int _sequence_len)
         CONTEND_DELTA( phi_hat, phi, 0.1f );
     }
 }
-
-
diff --git a/src/framing/tests/qpacketmodem_autotest.c b/src/framing/tests/qpacketmodem_autotest.c
index be78a63a..411c35ca 100644
--- a/src/framing/tests/qpacketmodem_autotest.c
+++ b/src/framing/tests/qpacketmodem_autotest.c
@@ -26,7 +26,7 @@
 #include "autotest/autotest.h"
 #include "liquid.h"
 
-// 
+//
 // AUTOTEST : test simple recovery of frame
 //
 void qpacketmodem_modulated(unsigned int _payload_len,
@@ -58,7 +58,7 @@ void qpacketmodem_modulated(unsigned int _payload_len,
     unsigned int frame_len = qpacketmodem_get_frame_len(q);
 
     // allocate memory for frame samples
-    float complex frame[frame_len];
+    _Fcomplex frame[frame_len];
 
     // encode frame
     qpacketmodem_encode(q, payload_tx, frame);
@@ -83,7 +83,7 @@ void autotest_qpacketmodem_qam64()  { qpacketmodem_modulated(400,LIQUID_CRC_32,L
 void autotest_qpacketmodem_sqam128(){ qpacketmodem_modulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_SQAM128); }
 void autotest_qpacketmodem_qam256() { qpacketmodem_modulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_QAM256);  }
 
-// 
+//
 // AUTOTEST : test un-modulated frame symbols (hard-decision demod)
 //
 void qpacketmodem_unmodulated(unsigned int _payload_len,
@@ -139,4 +139,3 @@ void autotest_qpacketmodem_unmod_sqam32() { qpacketmodem_unmodulated(400,LIQUID_
 void autotest_qpacketmodem_unmod_qam64()  { qpacketmodem_unmodulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_QAM64);   }
 void autotest_qpacketmodem_unmod_sqam128(){ qpacketmodem_unmodulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_SQAM128); }
 void autotest_qpacketmodem_unmod_qam256() { qpacketmodem_unmodulated(400,LIQUID_CRC_32,LIQUID_FEC_NONE,LIQUID_FEC_NONE, LIQUID_MODEM_QAM256);  }
-
diff --git a/src/framing/tests/qpilotsync_autotest.c b/src/framing/tests/qpilotsync_autotest.c
index 10d52b7a..5e20e115 100644
--- a/src/framing/tests/qpilotsync_autotest.c
+++ b/src/framing/tests/qpilotsync_autotest.c
@@ -28,7 +28,7 @@
 
 #define DEBUG_QPILOTSYNC_AUTOTEST 0
 
-// 
+//
 // AUTOTEST : test simple recovery of frame in noise
 //
 //  _ms             :   modulation scheme (e.g. LIQUID_MODEM_QPSK)
@@ -59,10 +59,10 @@ void qpilotsync_test(modulation_scheme _ms,
 
     // allocate arrays
     unsigned char payload_sym_tx[_payload_len]; // transmitted payload symbols
-    float complex payload_tx    [_payload_len]; // transmitted payload samples
-    float complex frame_tx      [frame_len];    // transmitted frame samples
-    float complex frame_rx      [frame_len];    // received frame samples
-    float complex payload_rx    [_payload_len]; // received payload samples
+    _Fcomplex payload_tx    [_payload_len]; // transmitted payload samples
+    _Fcomplex frame_tx      [frame_len];    // transmitted frame samples
+    _Fcomplex frame_rx      [frame_len];    // received frame samples
+    _Fcomplex payload_rx    [_payload_len]; // received payload samples
     unsigned char payload_sym_rx[_payload_len]; // received payload symbols
 
     // create modem objects for payload
@@ -120,13 +120,13 @@ void qpilotsync_test(modulation_scheme _ms,
         printf("  phi  (carrier phase): %12.8ff (expected %12.8f, error=%12.8f)\n",  phi_hat,  _phi, _phi-phi_hat);
         printf("  gamma (channel gain): %12.8ff (expected %12.8f, error=%12.8f)\n", gamma_hat, _gamma, _gamma-gamma_hat);
     }
-    
+
     // check to see that frame was recovered
     CONTEND_DELTA   (   dphi_hat,  _dphi, 0.010f );
     CONTEND_DELTA   (    phi_hat,   _phi, 0.087f );  // 0.087 radians is about 5 degrees
     CONTEND_DELTA   (  gamma_hat, _gamma, 0.010f );
     CONTEND_EQUALITY( bit_errors, 0 );
-    
+
     // destroy allocated objects
     qpilotgen_destroy(pg);
     qpilotsync_destroy(ps);
@@ -181,4 +181,3 @@ void autotest_qpilotsync_200_20() { qpilotsync_test(LIQUID_MODEM_QPSK, 200, 20,
 void autotest_qpilotsync_300_24() { qpilotsync_test(LIQUID_MODEM_QPSK, 300, 24, 0.07f, 1.2f, 0.7f, 40.0f); }
 void autotest_qpilotsync_400_28() { qpilotsync_test(LIQUID_MODEM_QPSK, 400, 28, 0.07f, 1.2f, 0.7f, 40.0f); }
 void autotest_qpilotsync_500_32() { qpilotsync_test(LIQUID_MODEM_QPSK, 500, 32, 0.07f, 1.2f, 0.7f, 40.0f); }
-
diff --git a/src/math/src/math.complex.c b/src/math/src/math.complex.c
index fc4aecf0..9dda1443 100644
--- a/src/math/src/math.complex.c
+++ b/src/math/src/math.complex.c
@@ -31,7 +31,7 @@
 #include "liquid.internal.h"
 
 // complex square root
-float complex liquid_csqrtf(float complex _z)
+_Fcomplex liquid_csqrtf(_Fcomplex _z)
 {
     float r = cabsf(_z);            // magnitude of _z
     float a = crealf(_z);           // real component of _z
@@ -45,7 +45,7 @@ float complex liquid_csqrtf(float complex _z)
 }
 
 // complex exponent
-float complex liquid_cexpf(float complex _z)
+_Fcomplex liquid_cexpf(_Fcomplex _z)
 {
     float r = expf( crealf(_z) );
     float re = cosf( cimagf(_z) );
@@ -55,19 +55,19 @@ float complex liquid_cexpf(float complex _z)
 }
 
 // complex logarithm
-float complex liquid_clogf(float complex _z)
+_Fcomplex liquid_clogf(_Fcomplex _z)
 {
     return logf(cabsf(_z)) + _Complex_I*cargf(_z);
 }
 
 // complex arcsin
-float complex liquid_casinf(float complex _z)
+_Fcomplex liquid_casinf(_Fcomplex _z)
 {
     return 0.5f*M_PI - liquid_cacosf(_z);
 }
 
 // complex arccos
-float complex liquid_cacosf(float complex _z)
+_Fcomplex liquid_cacosf(_Fcomplex _z)
 {
     // return based on quadrant
     int sign_i = crealf(_z) > 0;
@@ -84,16 +84,16 @@ float complex liquid_cacosf(float complex _z)
 }
 
 // complex arctan
-float complex liquid_catanf(float complex _z)
+_Fcomplex liquid_catanf(_Fcomplex _z)
 {
-    float complex t0 = 1.0f - _Complex_I*_z;
-    float complex t1 = 1.0f + _Complex_I*_z;
+    _Fcomplex t0 = 1.0f - _Complex_I*_z;
+    _Fcomplex t1 = 1.0f + _Complex_I*_z;
 
     return 0.5f*_Complex_I*liquid_clogf( t0 / t1 );
 }
 
 // approximation to cargf() but faster
-float liquid_cargf_approx(float complex _x)
+float liquid_cargf_approx(_Fcomplex _x)
 {
     float theta;
     float xi = crealf(_x);
@@ -113,4 +113,3 @@ float liquid_cargf_approx(float complex _x)
         theta = -M_PI_2;
     return theta;
 }
-
diff --git a/src/math/src/poly.c b/src/math/src/poly.c
index dce4038f..ce1910a0 100644
--- a/src/math/src/poly.c
+++ b/src/math/src/poly.c
@@ -22,7 +22,7 @@
 
 //
 // Floating-point polynomials (double precision)
-// 
+//
 
 #include "liquid.internal.h"
 
@@ -30,7 +30,7 @@
 #define POLY(name)      LIQUID_CONCAT(poly,   name)
 #define POLY_NAME       "poly"
 #define T               double
-#define TC              double complex
+#define TC              _Dcomplex
 
 #define T_COMPLEX       1
 #define TI_COMPLEX      1
@@ -42,4 +42,3 @@
 #include "poly.expand.c"
 #include "poly.findroots.c"
 #include "poly.lagrange.c"
-
diff --git a/src/math/src/polyc.c b/src/math/src/polyc.c
index 4a7f48db..1f4103f0 100644
--- a/src/math/src/polyc.c
+++ b/src/math/src/polyc.c
@@ -22,15 +22,15 @@
 
 //
 // Complex floating-point polynomials (double precision)
-// 
+//
 
 #include "liquid.internal.h"
 
 #define MATRIX(name)    LIQUID_CONCAT(matrixc, name)
 #define POLY(name)      LIQUID_CONCAT(polyc,   name)
 #define POLY_NAME       "polyc"
-#define T               double complex
-#define TC              double complex
+#define T               _Dcomplex
+#define TC              _Dcomplex
 
 #define T_COMPLEX       1
 #define TI_COMPLEX      1
@@ -42,4 +42,3 @@
 #include "poly.expand.c"
 #include "poly.findroots.c"
 #include "poly.lagrange.c"
-
diff --git a/src/math/src/polycf.c b/src/math/src/polycf.c
index f866ab50..8b4fb92f 100644
--- a/src/math/src/polycf.c
+++ b/src/math/src/polycf.c
@@ -22,15 +22,15 @@
 
 //
 // Complex floating-point polynomials (single precision)
-// 
+//
 
 #include "liquid.internal.h"
 
 #define MATRIX(name)    LIQUID_CONCAT(matrixcf, name)
 #define POLY(name)      LIQUID_CONCAT(polycf,   name)
 #define POLY_NAME       "polycf"
-#define T               float complex
-#define TC              float complex
+#define T               _Fcomplex
+#define TC              _Fcomplex
 
 #define T_COMPLEX       1
 #define TI_COMPLEX      1
@@ -42,4 +42,3 @@
 #include "poly.expand.c"
 #include "poly.findroots.c"
 #include "poly.lagrange.c"
-
diff --git a/src/math/src/polyf.c b/src/math/src/polyf.c
index 61affa31..86bc597d 100644
--- a/src/math/src/polyf.c
+++ b/src/math/src/polyf.c
@@ -22,7 +22,7 @@
 
 //
 // Floating-point polynomials (single precision)
-// 
+//
 
 #include "liquid.internal.h"
 
@@ -30,7 +30,7 @@
 #define POLY(name)      LIQUID_CONCAT(polyf,   name)
 #define POLY_NAME       "polyf"
 #define T               float
-#define TC              float complex
+#define TC              _Fcomplex
 
 #define T_COMPLEX       1
 #define TI_COMPLEX      1
@@ -42,4 +42,3 @@
 #include "poly.expand.c"
 #include "poly.findroots.c"
 #include "poly.lagrange.c"
-
diff --git a/src/math/tests/math_complex_autotest.c b/src/math/tests/math_complex_autotest.c
index fab623f9..4c90e573 100644
--- a/src/math/tests/math_complex_autotest.c
+++ b/src/math/tests/math_complex_autotest.c
@@ -23,7 +23,7 @@
 #include "autotest/autotest.h"
 #include "liquid.internal.h"
 
-// 
+//
 // AUTOTEST: cexpf
 //
 void autotest_cexpf()
@@ -31,7 +31,7 @@ void autotest_cexpf()
     float tol = 1e-3f;
 
     unsigned int n = 32;
-    float complex z[32] = {
+    _Fcomplex z[32] = {
         2.721502e+00+_Complex_I* -8.449366e-01,   2.264794e+00+_Complex_I*  2.387520e+00,
         3.293179e+00+_Complex_I* -2.419589e+00,  -1.318218e+00+_Complex_I*  2.145837e+00,
        -1.777802e+00+_Complex_I*  4.317598e-01,  -1.808236e-01+_Complex_I*  1.030967e+00,
@@ -49,7 +49,7 @@ void autotest_cexpf()
        -3.486629e+00+_Complex_I* -3.839816e+00,  -3.383861e-01+_Complex_I* -3.495233e+00,
        -2.093760e+00+_Complex_I*  3.765073e+00,   3.217665e+00+_Complex_I*  2.807358e+00 };
 
-    float complex test[32] = {
+    _Fcomplex test[32] = {
         1.009152e+01+_Complex_I* -1.137087e+01,  -7.018747e+00+_Complex_I*  6.592232e+00,
        -2.020926e+01+_Complex_I* -1.779666e+01,  -1.455457e-01+_Complex_I*  2.245718e-01,
         1.534993e-01+_Complex_I*  7.072523e-02,   4.289666e-01+_Complex_I*  7.159020e-01,
@@ -69,7 +69,7 @@ void autotest_cexpf()
 
     unsigned int i;
     for (i=0; i<n; i++) {
-        float complex t = liquid_cexpf(z[i]);
+        _Fcomplex t = liquid_cexpf(z[i]);
 
         CONTEND_DELTA(crealf(t), crealf(test[i]), tol);
         CONTEND_DELTA(cimagf(t), cimagf(test[i]), tol);
@@ -77,7 +77,7 @@ void autotest_cexpf()
 }
 
 
-// 
+//
 // AUTOTEST: clogf
 //
 void autotest_clogf()
@@ -85,7 +85,7 @@ void autotest_clogf()
     float tol = 1e-3f;
 
     unsigned int n = 32;
-    float complex z[32] = {
+    _Fcomplex z[32] = {
         2.7215e+00+_Complex_I* -8.4494e-01,   2.2648e+00+_Complex_I*  2.3875e+00,
         3.2932e+00+_Complex_I* -2.4196e+00,  -1.3182e+00+_Complex_I*  2.1458e+00,
        -1.7778e+00+_Complex_I*  4.3176e-01,  -1.8082e-01+_Complex_I*  1.0310e+00,
@@ -103,7 +103,7 @@ void autotest_clogf()
        -3.4866e+00+_Complex_I* -3.8398e+00,  -3.3839e-01+_Complex_I* -3.4952e+00,
        -2.0938e+00+_Complex_I*  3.7651e+00,   3.2177e+00+_Complex_I*  2.8074e+00};
 
-    float complex test[32] = {
+    _Fcomplex test[32] = {
         1.0472e+00+_Complex_I* -3.0103e-01,   1.1911e+00+_Complex_I*  8.1177e-01,
         1.4077e+00+_Complex_I* -6.3365e-01,   9.2362e-01+_Complex_I*  2.1217e+00,
         6.0403e-01+_Complex_I*  2.9033e+00,   4.5647e-02+_Complex_I*  1.7444e+00,
@@ -123,14 +123,14 @@ void autotest_clogf()
 
     unsigned int i;
     for (i=0; i<n; i++) {
-        float complex t = liquid_clogf(z[i]);
+        _Fcomplex t = liquid_clogf(z[i]);
 
         CONTEND_DELTA(crealf(t), crealf(test[i]), tol);
         CONTEND_DELTA(cimagf(t), cimagf(test[i]), tol);
     }
 }
 
-// 
+//
 // AUTOTEST: csqrtf
 //
 void autotest_csqrtf()
@@ -138,7 +138,7 @@ void autotest_csqrtf()
     float tol = 1e-3f;
 
     unsigned int n = 32;
-    float complex z[32] = {
+    _Fcomplex z[32] = {
         1.3608e+00+_Complex_I* -4.2247e-01,   1.1324e+00+_Complex_I*  1.1938e+00,
         1.6466e+00+_Complex_I* -1.2098e+00,  -6.5911e-01+_Complex_I*  1.0729e+00,
        -8.8890e-01+_Complex_I*  2.1588e-01,  -9.0412e-02+_Complex_I*  5.1548e-01,
@@ -156,7 +156,7 @@ void autotest_csqrtf()
        -1.7433e+00+_Complex_I* -1.9199e+00,  -1.6919e-01+_Complex_I* -1.7476e+00,
        -1.0469e+00+_Complex_I*  1.8825e+00,   1.6088e+00+_Complex_I*  1.4037e+00};
 
-    float complex test[32] = {
+    _Fcomplex test[32] = {
         1.1802e+00+_Complex_I* -1.7899e-01,   1.1785e+00+_Complex_I*  5.0647e-01,
         1.3583e+00+_Complex_I* -4.4534e-01,   5.4776e-01+_Complex_I*  9.7936e-01,
         1.1366e-01+_Complex_I*  9.4964e-01,   4.6526e-01+_Complex_I*  5.5397e-01,
@@ -176,14 +176,14 @@ void autotest_csqrtf()
 
     unsigned int i;
     for (i=0; i<n; i++) {
-        float complex t = liquid_csqrtf(z[i]);
+        _Fcomplex t = liquid_csqrtf(z[i]);
 
         CONTEND_DELTA(crealf(t), crealf(test[i]), tol);
         CONTEND_DELTA(cimagf(t), cimagf(test[i]), tol);
     }
 }
 
-// 
+//
 // AUTOTEST: casinf
 //
 void autotest_casinf()
@@ -192,7 +192,7 @@ void autotest_casinf()
 
     unsigned int n = 32;
 
-    float complex z[32] = {
+    _Fcomplex z[32] = {
         1.3608e+00+_Complex_I* -4.2247e-01,   1.1324e+00+_Complex_I*  1.1938e+00,
         1.6466e+00+_Complex_I* -1.2098e+00,  -6.5911e-01+_Complex_I*  1.0729e+00,
        -8.8890e-01+_Complex_I*  2.1588e-01,  -9.0412e-02+_Complex_I*  5.1548e-01,
@@ -210,7 +210,7 @@ void autotest_casinf()
        -1.7433e+00+_Complex_I* -1.9199e+00,  -1.6919e-01+_Complex_I* -1.7476e+00,
        -1.0469e+00+_Complex_I*  1.8825e+00,   1.6088e+00+_Complex_I*  1.4037e+00 };
 
-    float complex test[32] = {
+    _Fcomplex test[32] = {
         1.1716e+00+_Complex_I* -9.4147e-01,   6.7048e-01+_Complex_I*  1.2078e+00,
         8.7747e-01+_Complex_I* -1.3947e+00,  -4.3898e-01+_Complex_I*  1.0065e+00,
        -9.7768e-01+_Complex_I*  3.7722e-01,  -8.0395e-02+_Complex_I*  4.9650e-01,
@@ -230,14 +230,14 @@ void autotest_casinf()
 
     unsigned int i;
     for (i=0; i<n; i++) {
-        float complex t = liquid_casinf(z[i]);
+        _Fcomplex t = liquid_casinf(z[i]);
 
         CONTEND_DELTA(crealf(t), crealf(test[i]), tol);
         CONTEND_DELTA(cimagf(t), cimagf(test[i]), tol);
     }
 }
 
-// 
+//
 // AUTOTEST: cacosf
 //
 void autotest_cacosf()
@@ -246,7 +246,7 @@ void autotest_cacosf()
 
     unsigned int n = 32;
 
-    float complex z[32] = {
+    _Fcomplex z[32] = {
         1.3608e+00+_Complex_I* -4.2247e-01,   1.1324e+00+_Complex_I*  1.1938e+00,
         1.6466e+00+_Complex_I* -1.2098e+00,  -6.5911e-01+_Complex_I*  1.0729e+00,
        -8.8890e-01+_Complex_I*  2.1588e-01,  -9.0412e-02+_Complex_I*  5.1548e-01,
@@ -265,7 +265,7 @@ void autotest_cacosf()
        -1.0469e+00+_Complex_I*  1.8825e+00,   1.6088e+00+_Complex_I*  1.4037e+00,
       };
 
-    float complex test[32] = {
+    _Fcomplex test[32] = {
         3.9923e-01+_Complex_I*  9.4147e-01,   9.0032e-01+_Complex_I* -1.2078e+00,
         6.9333e-01+_Complex_I*  1.3947e+00,   2.0098e+00+_Complex_I* -1.0065e+00,
         2.5485e+00+_Complex_I* -3.7722e-01,   1.6512e+00+_Complex_I* -4.9650e-01,
@@ -285,14 +285,14 @@ void autotest_cacosf()
 
     unsigned int i;
     for (i=0; i<n; i++) {
-        float complex t = liquid_cacosf(z[i]);
+        _Fcomplex t = liquid_cacosf(z[i]);
 
         CONTEND_DELTA(crealf(t), crealf(test[i]), tol);
         CONTEND_DELTA(cimagf(t), cimagf(test[i]), tol);
     }
 }
 
-// 
+//
 // AUTOTEST: catanf
 //
 void autotest_catanf()
@@ -301,7 +301,7 @@ void autotest_catanf()
 
     unsigned int n = 32;
 
-    float complex z[32] = {
+    _Fcomplex z[32] = {
         1.3608e+00+_Complex_I* -4.2247e-01,   1.1324e+00+_Complex_I*  1.1938e+00,
         1.6466e+00+_Complex_I* -1.2098e+00,  -6.5911e-01+_Complex_I*  1.0729e+00,
        -8.8890e-01+_Complex_I*  2.1588e-01,  -9.0412e-02+_Complex_I*  5.1548e-01,
@@ -319,7 +319,7 @@ void autotest_catanf()
        -1.7433e+00+_Complex_I* -1.9199e+00,  -1.6919e-01+_Complex_I* -1.7476e+00,
        -1.0469e+00+_Complex_I*  1.8825e+00,   1.6088e+00+_Complex_I*  1.4037e+00 };
 
-    float complex test[32] = {
+    _Fcomplex test[32] = {
         9.6632e-01+_Complex_I* -1.4321e-01,   1.1084e+00+_Complex_I*  3.8248e-01,
         1.1690e+00+_Complex_I* -2.5348e-01,  -9.9442e-01+_Complex_I*  5.9395e-01,
        -7.3961e-01+_Complex_I*  1.1977e-01,  -1.2203e-01+_Complex_I*  5.6250e-01,
@@ -339,7 +339,7 @@ void autotest_catanf()
 
     unsigned int i;
     for (i=0; i<n; i++) {
-        float complex t = liquid_catanf(z[i]);
+        _Fcomplex t = liquid_catanf(z[i]);
 
         CONTEND_DELTA(crealf(t), crealf(test[i]), tol);
         CONTEND_DELTA(cimagf(t), cimagf(test[i]), tol);
diff --git a/src/math/tests/polynomial_autotest.c b/src/math/tests/polynomial_autotest.c
index f2564bcf..0f14ae97 100644
--- a/src/math/tests/polynomial_autotest.c
+++ b/src/math/tests/polynomial_autotest.c
@@ -25,7 +25,7 @@
 #include "autotest/autotest.h"
 #include "liquid.h"
 
-// 
+//
 // AUTOTEST: poly_fit 3rd order polynomial, critically sampled
 //
 void autotest_polyf_fit_q3n3()
@@ -49,7 +49,7 @@ void autotest_polyf_fit_q3n3()
         for (i=0; i<3; i++)
             printf("p[%3u] = %12.8f\n", i, p[i]);
     }
-    
+
     CONTEND_DELTA(p[0], p_test[0], tol);
     CONTEND_DELTA(p[1], p_test[1], tol);
     CONTEND_DELTA(p[2], p_test[2], tol);
@@ -57,7 +57,7 @@ void autotest_polyf_fit_q3n3()
 }
 
 #if 0
-// 
+//
 // AUTOTEST: poly_expandbinomial
 //
 void xautotest_polyf_expandbinomial_4()
@@ -76,7 +76,7 @@ void xautotest_polyf_expandbinomial_4()
             printf("%8.2f", c[i]);
         printf("\n");
     }
-    
+
     CONTEND_DELTA(c[0], c_test[0], tol);
     CONTEND_DELTA(c[1], c_test[1], tol);
     CONTEND_DELTA(c[2], c_test[2], tol);
@@ -85,7 +85,7 @@ void xautotest_polyf_expandbinomial_4()
 }
 #endif
 
-// 
+//
 // AUTOTEST: poly_expandroots
 //
 void autotest_polyf_expandroots_4()
@@ -104,7 +104,7 @@ void autotest_polyf_expandroots_4()
             printf("%8.2f", c[i]);
         printf("\n");
     }
-    
+
     CONTEND_DELTA(c[0], c_test[0], tol);
     CONTEND_DELTA(c[1], c_test[1], tol);
     CONTEND_DELTA(c[2], c_test[2], tol);
@@ -114,7 +114,7 @@ void autotest_polyf_expandroots_4()
 }
 
 
-// 
+//
 // AUTOTEST: poly_expandroots
 //
 void autotest_polyf_expandroots_11()
@@ -146,16 +146,16 @@ void autotest_polyf_expandroots_11()
     }
 }
 
-// 
+//
 // AUTOTEST: polycf_expandroots
 //
 void autotest_polycf_expandroots_4()
 {
     // expand complex roots on conjugate pair
     float theta = 1.7f;
-    float complex a[2] = { -cexpf(_Complex_I*theta), -cexpf(-_Complex_I*theta) };
-    float complex c[3];
-    float complex c_test[3] = { 1, 2*cosf(theta), 1 };
+    _Fcomplex a[2] = { -cexpf(_Complex_I*theta), -cexpf(-_Complex_I*theta) };
+    _Fcomplex c[3];
+    _Fcomplex c_test[3] = { 1, 2*cosf(theta), 1 };
     float tol = 1e-3f;
 
     polycf_expandroots(a,2,c);
@@ -165,7 +165,7 @@ void autotest_polycf_expandroots_4()
         for (i=0; i<3; i++)
             printf("c[%3u] = %12.8f + j*%12.8f\n", i, crealf(c[i]), cimagf(c[i]));
     }
-    
+
     CONTEND_DELTA(crealf(c[0]), crealf(c_test[0]), tol);
     CONTEND_DELTA(cimagf(c[0]), cimagf(c_test[0]), tol);
 
@@ -177,7 +177,7 @@ void autotest_polycf_expandroots_4()
 
 }
 
-// 
+//
 // AUTOTEST: poly_expandroots2
 //
 // expand (2*x-5)*(3*x+2)*(-1*x+3)
@@ -200,7 +200,7 @@ void autotest_polyf_expandroots2_3()
             printf("%8.2f", c[i]);
         printf("\n");
     }
-    
+
     CONTEND_DELTA(c[0], c_test[0], tol);
     CONTEND_DELTA(c[1], c_test[1], tol);
     CONTEND_DELTA(c[2], c_test[2], tol);
@@ -208,7 +208,7 @@ void autotest_polyf_expandroots2_3()
 }
 
 
-// 
+//
 // AUTOTEST: polyf_mul
 //
 void autotest_polyf_mul_2_3()
@@ -228,7 +228,7 @@ void autotest_polyf_mul_2_3()
             printf("%8.2f", c[i]);
         printf("\n");
     }
-    
+
     CONTEND_DELTA(c[0], c_test[0], tol);
     CONTEND_DELTA(c[1], c_test[1], tol);
     CONTEND_DELTA(c[2], c_test[2], tol);
@@ -237,7 +237,7 @@ void autotest_polyf_mul_2_3()
     CONTEND_DELTA(c[5], c_test[5], tol);
 }
 
-// 
+//
 // AUTOTEST: poly_expandbinomial
 //
 void autotest_poly_expandbinomial_n6()
@@ -255,12 +255,12 @@ void autotest_poly_expandbinomial_n6()
             printf("%6.1f", c[i]);
         printf("\n");
     }
-    
+
     CONTEND_SAME_DATA(c,c_test,sizeof(c));
 }
 
 
-// 
+//
 // AUTOTEST: poly_binomial_expand_pm
 //
 void autotest_poly_binomial_expand_pm_m6_k1()
@@ -285,7 +285,7 @@ void autotest_poly_binomial_expand_pm_m6_k1()
         CONTEND_DELTA(c[i], c_test[i], 1e-3f);
 }
 
-// 
+//
 // AUTOTEST: poly_expandbinomial_pm
 //
 void autotest_poly_expandbinomial_pm_m5_k2()
@@ -310,5 +310,3 @@ void autotest_poly_expandbinomial_pm_m5_k2()
     for (i=0; i<=n; i++)
         CONTEND_DELTA(c[i], c_test[i], 1e-3f);
 }
-
-
diff --git a/src/math/tests/polynomial_findroots_autotest.c b/src/math/tests/polynomial_findroots_autotest.c
index d0ab71e2..db5fede9 100644
--- a/src/math/tests/polynomial_findroots_autotest.c
+++ b/src/math/tests/polynomial_findroots_autotest.c
@@ -25,7 +25,7 @@
 #include "autotest/autotest.h"
 #include "liquid.h"
 
-// 
+//
 // AUTOTEST: polyf_findroots
 //
 
@@ -33,11 +33,11 @@
 //  _r      : roots (sorted), [size: _order   x 1]
 //  _ordre  : polynomial order
 void polyf_findroots_testbench(float *         _p,
-                               float complex * _r,
+                               _Fcomplex * _r,
                                unsigned int    _order,
                                float           _tol)
 {
-    float complex roots[_order];
+    _Fcomplex roots[_order];
     polyf_findroots(_p,_order+1,roots);
 
     unsigned int i;
@@ -66,7 +66,7 @@ void autotest_polyf_findroots_real()
 {
     // basic roots, no complex values
     float         p[6] = {6,11,-33,-33,11,6};
-    float complex r[5] = {-3, -1, -1./3., 0.5, 2.};
+    _Fcomplex r[5] = {-3, -1, -1./3., 0.5, 2.};
     polyf_findroots_testbench(p, r, 5, 1e-6f);
 }
 
@@ -75,7 +75,7 @@ void autotest_polyf_findroots_complex()
 
     // complex roots
     float         p[3] = {3,2,1};
-    float complex r[2] = {-1 + _Complex_I*M_SQRT2,
+    _Fcomplex r[2] = {-1 + _Complex_I*M_SQRT2,
                           -1 - _Complex_I*M_SQRT2};
     polyf_findroots_testbench(p, r, 2, 1e-6f);
 }
@@ -85,7 +85,7 @@ void autotest_polyf_findroots_mix()
 
     // complex roots
     float         p[7] = {-1,6,5,4,3,2,1};
-    float complex r[6] = {
+    _Fcomplex r[6] = {
 		-1.544928106217380,
 		-0.8438580445415772 + 1.251293921227189*_Complex_I,
 		-0.8438580445415772 - 1.251293921227189*_Complex_I,
@@ -111,7 +111,7 @@ void autotest_polyf_findroots_mix2()
          1.3681684434413909912109375000e-01,
          1.0689756833016872406005859375e-02,};
 
-    float complex r[10] = {
+    _Fcomplex r[10] = {
        -17.67808709752869,
         -0.7645511425850682 + 0.4932343666704793*_Complex_I,
         -0.7645511425850682 - 0.4932343666704793*_Complex_I,
@@ -126,7 +126,7 @@ void autotest_polyf_findroots_mix2()
     polyf_findroots_testbench(p, r, 10, 4e-6f);
 }
 
-// 
+//
 // AUTOTEST: polycf_findroots (random roots)
 //
 void xautotest_polycf_findroots_rand()
@@ -134,10 +134,10 @@ void xautotest_polycf_findroots_rand()
     unsigned int n=5;
     float tol=1e-4f;
 
-    float complex p[n];
-    float complex roots[n-1];
+    _Fcomplex p[n];
+    _Fcomplex roots[n-1];
 
-    float complex p_hat[n];
+    _Fcomplex p_hat[n];
 
     unsigned int i;
     for (i=0; i<n; i++)
@@ -145,7 +145,7 @@ void xautotest_polycf_findroots_rand()
 
     polycf_findroots(p,n,roots);
 
-    float complex roots_hat[n-1];
+    _Fcomplex roots_hat[n-1];
     // convert form...
     for (i=0; i<n-1; i++)
         roots_hat[i] = -roots[i];
@@ -171,4 +171,3 @@ void xautotest_polycf_findroots_rand()
         CONTEND_DELTA(cimagf(p[i]), cimagf(p_hat[i]), tol);
     }
 }
-
diff --git a/src/matrix/src/matrixc.c b/src/matrix/src/matrixc.c
index 6cf50af8..08dc55b2 100644
--- a/src/matrix/src/matrixc.c
+++ b/src/matrix/src/matrixc.c
@@ -22,14 +22,14 @@
 
 //
 // Complex floating-point matrix (double precision)
-// 
+//
 
 #include "liquid.internal.h"
 
 #define MATRIX(name)    LIQUID_CONCAT(matrixc, name)
 #define MATRIX_NAME     "matrixc"
 
-#define T               double complex  // general type
+#define T               _Dcomplex  // general type
 #define TP              double          // primitive type
 #define T_COMPLEX       1               // is type complex?
 
@@ -50,4 +50,3 @@
 #include "matrix.ludecomp.c"
 #include "matrix.qrdecomp.c"
 #include "matrix.math.c"
-
diff --git a/src/matrix/src/matrixcf.c b/src/matrix/src/matrixcf.c
index 74ad430d..83ef4b26 100644
--- a/src/matrix/src/matrixcf.c
+++ b/src/matrix/src/matrixcf.c
@@ -22,14 +22,14 @@
 
 //
 // Complex floating-point matrix (single precision)
-// 
+//
 
 #include "liquid.internal.h"
 
 #define MATRIX(name)    LIQUID_CONCAT(matrixcf, name)
 #define MATRIX_NAME     "matrixcf"
 
-#define T               float complex   // general type
+#define T               _Fcomplex   // general type
 #define TP              float           // primitive type
 #define T_COMPLEX       1               // is type complex?
 
@@ -50,4 +50,3 @@
 #include "matrix.ludecomp.c"
 #include "matrix.qrdecomp.c"
 #include "matrix.math.c"
-
diff --git a/src/matrix/tests/data/matrixcf_data_add.c b/src/matrix/tests/data/matrixcf_data_add.c
index e9f6e267..76f3ec40 100644
--- a/src/matrix/tests/data/matrixcf_data_add.c
+++ b/src/matrix/tests/data/matrixcf_data_add.c
@@ -27,7 +27,7 @@
 #include <complex.h>
 
 // matrixcf_data_add_x [size: 5 x 4]
-float complex matrixcf_data_add_x[] = {
+_Fcomplex matrixcf_data_add_x[] = {
     1.366575479507 +  -1.463535666466*_Complex_I /* ( 0, 0) */,
     1.982354640961 +   0.090445250273*_Complex_I /* ( 0, 1) */,
     0.913504719734 +  -0.689249753952*_Complex_I /* ( 0, 2) */,
@@ -50,7 +50,7 @@ float complex matrixcf_data_add_x[] = {
    -0.176615595818 +  -0.414863616228*_Complex_I /* ( 4, 3) */};
 
 // matrixcf_data_add_y [size: 5 x 4]
-float complex matrixcf_data_add_y[] = {
+_Fcomplex matrixcf_data_add_y[] = {
    -0.345586329699 +   0.240964725614*_Complex_I /* ( 0, 0) */,
    -0.025732314214 +   1.212726473808*_Complex_I /* ( 0, 1) */,
     0.907316803932 +   1.614625453949*_Complex_I /* ( 0, 2) */,
@@ -73,7 +73,7 @@ float complex matrixcf_data_add_y[] = {
    -0.290932357311 +   0.302335798740*_Complex_I /* ( 4, 3) */};
 
 // matrixcf_data_add_z [size: 5 x 4]
-float complex matrixcf_data_add_z[] = {
+_Fcomplex matrixcf_data_add_z[] = {
     1.020989149809 +  -1.222570940852*_Complex_I /* ( 0, 0) */,
     1.956622326747 +   1.303171724081*_Complex_I /* ( 0, 1) */,
     1.820821523666 +   0.925375699997*_Complex_I /* ( 0, 2) */,
@@ -94,4 +94,3 @@ float complex matrixcf_data_add_z[] = {
     0.504008874297 +  -0.954922614619*_Complex_I /* ( 4, 1) */,
    -1.156464576721 +  -1.144047161564*_Complex_I /* ( 4, 2) */,
    -0.467547953129 +  -0.112527817488*_Complex_I /* ( 4, 3) */};
-
diff --git a/src/matrix/tests/data/matrixcf_data_aug.c b/src/matrix/tests/data/matrixcf_data_aug.c
index 7abfc4d3..b26374fd 100644
--- a/src/matrix/tests/data/matrixcf_data_aug.c
+++ b/src/matrix/tests/data/matrixcf_data_aug.c
@@ -27,7 +27,7 @@
 #include <complex.h>
 
 // matrixcf_data_aug_x [size: 5 x 4]
-float complex matrixcf_data_aug_x[] = {
+_Fcomplex matrixcf_data_aug_x[] = {
    -1.383545994759 +   0.803655147552*_Complex_I /* ( 0, 0) */,
    -0.918114125729 +  -1.194809913635*_Complex_I /* ( 0, 1) */,
     0.090901032090 +   0.484884619713*_Complex_I /* ( 0, 2) */,
@@ -50,7 +50,7 @@ float complex matrixcf_data_aug_x[] = {
     1.450994849205 +  -0.595933079720*_Complex_I /* ( 4, 3) */};
 
 // matrixcf_data_aug_y [size: 5 x 3]
-float complex matrixcf_data_aug_y[] = {
+_Fcomplex matrixcf_data_aug_y[] = {
     0.301848381758 +   0.353115469217*_Complex_I /* ( 0, 0) */,
     0.703616917133 +   0.044240720570*_Complex_I /* ( 0, 1) */,
     0.268176555634 +   1.071476221085*_Complex_I /* ( 0, 2) */,
@@ -68,7 +68,7 @@ float complex matrixcf_data_aug_y[] = {
     0.204153224826 +  -0.616621196270*_Complex_I /* ( 4, 2) */};
 
 // matrixcf_data_aug_z [size: 5 x 7]
-float complex matrixcf_data_aug_z[] = {
+_Fcomplex matrixcf_data_aug_z[] = {
    -1.383545994759 +   0.803655147552*_Complex_I /* ( 0, 0) */,
    -0.918114125729 +  -1.194809913635*_Complex_I /* ( 0, 1) */,
     0.090901032090 +   0.484884619713*_Complex_I /* ( 0, 2) */,
@@ -104,4 +104,3 @@ float complex matrixcf_data_aug_z[] = {
    -0.314995974302 +  -0.811702668667*_Complex_I /* ( 4, 4) */,
     0.912520587444 +  -2.686280250549*_Complex_I /* ( 4, 5) */,
     0.204153224826 +  -0.616621196270*_Complex_I /* ( 4, 6) */};
-
diff --git a/src/matrix/tests/data/matrixcf_data_chol.c b/src/matrix/tests/data/matrixcf_data_chol.c
index 5617a30c..8ad52564 100644
--- a/src/matrix/tests/data/matrixcf_data_chol.c
+++ b/src/matrix/tests/data/matrixcf_data_chol.c
@@ -27,7 +27,7 @@
 #include <complex.h>
 
 // matrixcf_data_chol_L [size: 4 x 4]
-float complex matrixcf_data_chol_L[] = {
+_Fcomplex matrixcf_data_chol_L[] = {
     1.010000000000 +   0.000000000000*_Complex_I /* ( 0, 0) */,
     0.000000000000 +   0.000000000000*_Complex_I /* ( 0, 1) */,
     0.000000000000 +   0.000000000000*_Complex_I /* ( 0, 2) */,
@@ -46,7 +46,7 @@ float complex matrixcf_data_chol_L[] = {
     1.070000000000 +   0.000000000000*_Complex_I /* ( 3, 3) */};
 
 // matrixcf_data_chol_A [size: 4 x 4]
-float complex matrixcf_data_chol_A[] = {
+_Fcomplex matrixcf_data_chol_A[] = {
     1.020100000000 +   0.000000000000*_Complex_I /* ( 0, 0) */,
    -1.434200000000 +  -0.252500000000*_Complex_I /* ( 0, 1) */,
     0.323200000000 +   1.242300000000*_Complex_I /* ( 0, 2) */,
@@ -63,4 +63,3 @@ float complex matrixcf_data_chol_A[] = {
     1.543400000000 +  -1.208400000000*_Complex_I /* ( 3, 1) */,
    -2.742600000000 +  -0.135900000000*_Complex_I /* ( 3, 2) */,
    10.091600000000 +   0.000000000000*_Complex_I /* ( 3, 3) */};
-
diff --git a/src/matrix/tests/data/matrixcf_data_inv.c b/src/matrix/tests/data/matrixcf_data_inv.c
index 5b01826a..a82d4db3 100644
--- a/src/matrix/tests/data/matrixcf_data_inv.c
+++ b/src/matrix/tests/data/matrixcf_data_inv.c
@@ -27,7 +27,7 @@
 #include <complex.h>
 
 // matrixcf_data_inv_x [size: 5 x 5]
-float complex matrixcf_data_inv_x[] = {
+_Fcomplex matrixcf_data_inv_x[] = {
    -0.911099433899 +  -0.436777323484*_Complex_I /* ( 0, 0) */,
     0.598295390606 +  -0.283340752125*_Complex_I /* ( 0, 1) */,
    -0.264758616686 +  -0.421906232834*_Complex_I /* ( 0, 2) */,
@@ -55,7 +55,7 @@ float complex matrixcf_data_inv_x[] = {
     0.200873896480 +  -0.036809749901*_Complex_I /* ( 4, 4) */};
 
 // matrixcf_data_inv_y [size: 5 x 5]
-float complex matrixcf_data_inv_y[] = {
+_Fcomplex matrixcf_data_inv_y[] = {
    -0.127852678827 +  -0.009178191835*_Complex_I /* ( 0, 0) */,
    -0.199905444866 +   0.033789259175*_Complex_I /* ( 0, 1) */,
     0.168465876479 +  -0.059607902071*_Complex_I /* ( 0, 2) */,
@@ -81,4 +81,3 @@ float complex matrixcf_data_inv_y[] = {
     0.111730542618 +  -0.221903756183*_Complex_I /* ( 4, 2) */,
     0.303835472120 +  -0.022543572811*_Complex_I /* ( 4, 3) */,
    -0.167008031325 +   0.051911194273*_Complex_I /* ( 4, 4) */};
-
diff --git a/src/matrix/tests/data/matrixcf_data_linsolve.c b/src/matrix/tests/data/matrixcf_data_linsolve.c
index b8fa723e..1856a937 100644
--- a/src/matrix/tests/data/matrixcf_data_linsolve.c
+++ b/src/matrix/tests/data/matrixcf_data_linsolve.c
@@ -27,7 +27,7 @@
 #include <complex.h>
 
 // matrixcf_data_linsolve_A [size: 5 x 5]
-float complex matrixcf_data_linsolve_A[] = {
+_Fcomplex matrixcf_data_linsolve_A[] = {
    -0.482884645462 +  -0.221723198891*_Complex_I /* ( 0, 0) */,
    -0.387645065784 +   0.086682170630*_Complex_I /* ( 0, 1) */,
     1.580931067467 +   0.883717715740*_Complex_I /* ( 0, 2) */,
@@ -55,7 +55,7 @@ float complex matrixcf_data_linsolve_A[] = {
    -0.241452947259 +   1.540177464485*_Complex_I /* ( 4, 4) */};
 
 // matrixcf_data_linsolve_x [size: 5 x 1]
-float complex matrixcf_data_linsolve_x[] = {
+_Fcomplex matrixcf_data_linsolve_x[] = {
    -0.686784207821 +   0.516409814358*_Complex_I /* ( 0, 0) */,
     0.725918948650 +  -0.725804686546*_Complex_I /* ( 1, 0) */,
     0.048043362796 +   1.415739893913*_Complex_I /* ( 2, 0) */,
@@ -63,10 +63,9 @@ float complex matrixcf_data_linsolve_x[] = {
     1.000079274178 +   0.117630988359*_Complex_I /* ( 4, 0) */};
 
 // matrixcf_data_linsolve_b [size: 5 x 1]
-float complex matrixcf_data_linsolve_b[] = {
+_Fcomplex matrixcf_data_linsolve_b[] = {
     1.889372086452 +   2.079795053851*_Complex_I /* ( 0, 0) */,
     4.099006087145 +   0.093571115573*_Complex_I /* ( 1, 0) */,
    -0.465385431770 +  -0.201195243205*_Complex_I /* ( 2, 0) */,
    -2.502649126311 +  -1.292489487343*_Complex_I /* ( 3, 0) */,
     0.307098947642 +   0.568345470088*_Complex_I /* ( 4, 0) */};
-
diff --git a/src/matrix/tests/data/matrixcf_data_ludecomp.c b/src/matrix/tests/data/matrixcf_data_ludecomp.c
index eec99151..ed5ec88d 100644
--- a/src/matrix/tests/data/matrixcf_data_ludecomp.c
+++ b/src/matrix/tests/data/matrixcf_data_ludecomp.c
@@ -27,7 +27,7 @@
 #include <complex.h>
 
 // matrixcf_data_ludecomp_A [size: 8 x 8]
-float complex matrixcf_data_ludecomp_A[] = {
+_Fcomplex matrixcf_data_ludecomp_A[] = {
     0.455808967352 +   0.239869371057*_Complex_I /* ( 0, 0) */,
     1.076113820076 +   0.303303003311*_Complex_I /* ( 0, 1) */,
    -1.174549579620 +  -1.593330740929*_Complex_I /* ( 0, 2) */,
@@ -92,4 +92,3 @@ float complex matrixcf_data_ludecomp_A[] = {
     1.409144878387 +   0.992799341679*_Complex_I /* ( 7, 5) */,
     0.387732833624 +  -1.445696353912*_Complex_I /* ( 7, 6) */,
    -0.528750956059 +  -1.205648779869*_Complex_I /* ( 7, 7) */};
-
diff --git a/src/matrix/tests/data/matrixcf_data_mul.c b/src/matrix/tests/data/matrixcf_data_mul.c
index 9ecc45e4..fde9f8e7 100644
--- a/src/matrix/tests/data/matrixcf_data_mul.c
+++ b/src/matrix/tests/data/matrixcf_data_mul.c
@@ -27,7 +27,7 @@
 #include <complex.h>
 
 // matrixcf_data_mul_x [size: 5 x 4]
-float complex matrixcf_data_mul_x[] = {
+_Fcomplex matrixcf_data_mul_x[] = {
     1.131277322769 +  -2.908640623093*_Complex_I /* ( 0, 0) */,
     0.847201466560 +  -1.637244105339*_Complex_I /* ( 0, 1) */,
    -2.173580169678 +   0.096817605197*_Complex_I /* ( 0, 2) */,
@@ -50,7 +50,7 @@ float complex matrixcf_data_mul_x[] = {
     2.234328985214 +   0.855401337147*_Complex_I /* ( 4, 3) */};
 
 // matrixcf_data_mul_y [size: 4 x 3]
-float complex matrixcf_data_mul_y[] = {
+_Fcomplex matrixcf_data_mul_y[] = {
     0.122429788113 +  -1.041572093964*_Complex_I /* ( 0, 0) */,
    -1.123313307762 +  -1.396123170853*_Complex_I /* ( 0, 1) */,
    -0.318034142256 +  -0.537796914577*_Complex_I /* ( 0, 2) */,
@@ -65,7 +65,7 @@ float complex matrixcf_data_mul_y[] = {
     0.562124013901 +   0.047597970814*_Complex_I /* ( 3, 2) */};
 
 // matrixcf_data_mul_z [size: 5 x 3]
-float complex matrixcf_data_mul_z[] = {
+_Fcomplex matrixcf_data_mul_z[] = {
    -3.015598273252 +  -3.823225604286*_Complex_I /* ( 0, 0) */,
    -6.503138041472 +   2.522251659946*_Complex_I /* ( 0, 1) */,
    -3.033435877267 +  -2.533375977709*_Complex_I /* ( 0, 2) */,
@@ -81,4 +81,3 @@ float complex matrixcf_data_mul_z[] = {
     2.461434774758 +   3.932854324787*_Complex_I /* ( 4, 0) */,
     1.845966920717 +   2.370697350446*_Complex_I /* ( 4, 1) */,
     5.477082880684 +   3.294354034834*_Complex_I /* ( 4, 2) */};
-
diff --git a/src/matrix/tests/data/matrixcf_data_qrdecomp.c b/src/matrix/tests/data/matrixcf_data_qrdecomp.c
index f7c98745..4133fa08 100644
--- a/src/matrix/tests/data/matrixcf_data_qrdecomp.c
+++ b/src/matrix/tests/data/matrixcf_data_qrdecomp.c
@@ -27,7 +27,7 @@
 #include <complex.h>
 
 // matrixcf_data_qrdecomp_A [size: 4 x 4]
-float complex matrixcf_data_qrdecomp_A[] = {
+_Fcomplex matrixcf_data_qrdecomp_A[] = {
     2.114020000000 +  -0.576040000000*_Complex_I /* ( 0, 0) */,
     0.417500000000 +   1.008330000000*_Complex_I /* ( 0, 1) */,
    -0.962640000000 +  -3.621960000000*_Complex_I /* ( 0, 2) */,
@@ -46,7 +46,7 @@ float complex matrixcf_data_qrdecomp_A[] = {
    -0.127670000000 +  -0.539970000000*_Complex_I /* ( 3, 3) */};
 
 // matrixcf_data_qrdecomp_Q [size: 4 x 4]
-float complex matrixcf_data_qrdecomp_Q[] = {
+_Fcomplex matrixcf_data_qrdecomp_Q[] = {
     0.491706158979 +  -0.133982845866*_Complex_I /* ( 0, 0) */,
     0.429660711419 +   0.559833033911*_Complex_I /* ( 0, 1) */,
    -0.309333641162 +  -0.278321211351*_Complex_I /* ( 0, 2) */,
@@ -65,7 +65,7 @@ float complex matrixcf_data_qrdecomp_Q[] = {
    -0.173581995183 +  -0.293616086507*_Complex_I /* ( 3, 3) */};
 
 // matrixcf_data_qrdecomp_R [size: 4 x 4]
-float complex matrixcf_data_qrdecomp_R[] = {
+_Fcomplex matrixcf_data_qrdecomp_R[] = {
     4.299356356224 +   0.000000000000*_Complex_I /* ( 0, 0) */,
    -0.922616273377 +  -0.789487259898*_Complex_I /* ( 0, 1) */,
    -1.025768821795 +  -1.040664085433*_Complex_I /* ( 0, 2) */,
@@ -82,4 +82,3 @@ float complex matrixcf_data_qrdecomp_R[] = {
     0.000000000000 +   0.000000000000*_Complex_I /* ( 3, 1) */,
     0.000000000000 +   0.000000000000*_Complex_I /* ( 3, 2) */,
     2.392371328442 +   0.000000000000*_Complex_I /* ( 3, 3) */};
-
diff --git a/src/matrix/tests/data/matrixcf_data_transmul.c b/src/matrix/tests/data/matrixcf_data_transmul.c
index 95fc080e..182dc876 100644
--- a/src/matrix/tests/data/matrixcf_data_transmul.c
+++ b/src/matrix/tests/data/matrixcf_data_transmul.c
@@ -27,7 +27,7 @@
 #include <complex.h>
 
 // matrixcf_data_transmul_x [size: 5 x 4]
-float complex matrixcf_data_transmul_x[] = {
+_Fcomplex matrixcf_data_transmul_x[] = {
     0.897770464420 +  -1.137341141701*_Complex_I /* ( 0, 0) */,
     0.816529691219 +  -0.575469911098*_Complex_I /* ( 0, 1) */,
     2.407611131668 +   0.901603281498*_Complex_I /* ( 0, 2) */,
@@ -50,7 +50,7 @@ float complex matrixcf_data_transmul_x[] = {
     0.089408367872 +  -1.864659070969*_Complex_I /* ( 4, 3) */};
 
 // matrixcf_data_transmul_xxT [size: 5 x 5]
-float complex matrixcf_data_transmul_xxT[] = {
+_Fcomplex matrixcf_data_transmul_xxT[] = {
    13.946043026996 +   0.000000000000*_Complex_I /* ( 0, 0) */,
     1.715635857916 +   6.831514803023*_Complex_I /* ( 0, 1) */,
    -0.628286275869 +   0.653261344190*_Complex_I /* ( 0, 2) */,
@@ -78,7 +78,7 @@ float complex matrixcf_data_transmul_xxT[] = {
     5.591988375464 +   0.000000000000*_Complex_I /* ( 4, 4) */};
 
 // matrixcf_data_transmul_xxH [size: 5 x 5]
-float complex matrixcf_data_transmul_xxH[] = {
+_Fcomplex matrixcf_data_transmul_xxH[] = {
     2.693069394806 +   5.019630491560*_Complex_I /* ( 0, 0) */,
     1.208446246635 +  -4.757020341403*_Complex_I /* ( 0, 1) */,
     2.656451825557 +   2.224444954914*_Complex_I /* ( 0, 2) */,
@@ -106,7 +106,7 @@ float complex matrixcf_data_transmul_xxH[] = {
    -3.106642538055 +   1.664057265760*_Complex_I /* ( 4, 4) */};
 
 // matrixcf_data_transmul_xTx [size: 4 x 4]
-float complex matrixcf_data_transmul_xTx[] = {
+_Fcomplex matrixcf_data_transmul_xTx[] = {
     9.323024431917 +   0.000000000000*_Complex_I /* ( 0, 0) */,
     0.563876592623 +   2.570030362211*_Complex_I /* ( 0, 1) */,
     3.226123027525 +   2.636644463529*_Complex_I /* ( 0, 2) */,
@@ -125,7 +125,7 @@ float complex matrixcf_data_transmul_xTx[] = {
    10.759653720678 +   0.000000000000*_Complex_I /* ( 3, 3) */};
 
 // matrixcf_data_transmul_xHx [size: 4 x 4]
-float complex matrixcf_data_transmul_xHx[] = {
+_Fcomplex matrixcf_data_transmul_xHx[] = {
    -1.137085237839 +  -2.939337742229*_Complex_I /* ( 0, 0) */,
    -1.429264118470 +  -4.526184217761*_Complex_I /* ( 0, 1) */,
    -1.049795781222 +  -9.317515018345*_Complex_I /* ( 0, 2) */,
@@ -142,4 +142,3 @@ float complex matrixcf_data_transmul_xHx[] = {
    -1.585896210450 +   0.361787209777*_Complex_I /* ( 3, 1) */,
    -2.591648390404 +  -1.678750072577*_Complex_I /* ( 3, 2) */,
    -4.641352652692 +   5.522450469852*_Complex_I /* ( 3, 3) */};
-
diff --git a/src/matrix/tests/matrix_data.h b/src/matrix/tests/matrix_data.h
index b17593e8..45cd5aa5 100644
--- a/src/matrix/tests/matrix_data.h
+++ b/src/matrix/tests/matrix_data.h
@@ -27,7 +27,7 @@
 #ifndef __LIQUID_MATRIX_DATA_H__
 #define __LIQUID_MATRIX_DATA_H__
 
-// 
+//
 // single-precision real floating-point data
 //
 
@@ -85,52 +85,51 @@ extern float matrixf_data_transmul_xTx[];
 extern float matrixf_data_transmul_xHx[];
 
 
-// 
+//
 // single-precision complex floating-point data
 //
 
 // add
-extern float complex matrixcf_data_add_x[];
-extern float complex matrixcf_data_add_y[];
-extern float complex matrixcf_data_add_z[];
+extern _Fcomplex matrixcf_data_add_x[];
+extern _Fcomplex matrixcf_data_add_y[];
+extern _Fcomplex matrixcf_data_add_z[];
 
 // aug
-extern float complex matrixcf_data_aug_x[];
-extern float complex matrixcf_data_aug_y[];
-extern float complex matrixcf_data_aug_z[];
+extern _Fcomplex matrixcf_data_aug_x[];
+extern _Fcomplex matrixcf_data_aug_y[];
+extern _Fcomplex matrixcf_data_aug_z[];
 
 // chol
-extern float complex matrixcf_data_chol_A[];
-extern float complex matrixcf_data_chol_L[];
+extern _Fcomplex matrixcf_data_chol_A[];
+extern _Fcomplex matrixcf_data_chol_L[];
 
 // inv
-extern float complex matrixcf_data_inv_x[];
-extern float complex matrixcf_data_inv_y[];
+extern _Fcomplex matrixcf_data_inv_x[];
+extern _Fcomplex matrixcf_data_inv_y[];
 
 // linsolve
-extern float complex matrixcf_data_linsolve_A[];
-extern float complex matrixcf_data_linsolve_x[];
-extern float complex matrixcf_data_linsolve_b[];
+extern _Fcomplex matrixcf_data_linsolve_A[];
+extern _Fcomplex matrixcf_data_linsolve_x[];
+extern _Fcomplex matrixcf_data_linsolve_b[];
 
 // ludecomp
-extern float complex matrixcf_data_ludecomp_A[];
+extern _Fcomplex matrixcf_data_ludecomp_A[];
 
 // mul
-extern float complex matrixcf_data_mul_x[];
-extern float complex matrixcf_data_mul_y[];
-extern float complex matrixcf_data_mul_z[];
+extern _Fcomplex matrixcf_data_mul_x[];
+extern _Fcomplex matrixcf_data_mul_y[];
+extern _Fcomplex matrixcf_data_mul_z[];
 
 // qrdecomp
-extern float complex matrixcf_data_qrdecomp_A[];
-extern float complex matrixcf_data_qrdecomp_Q[];
-extern float complex matrixcf_data_qrdecomp_R[];
+extern _Fcomplex matrixcf_data_qrdecomp_A[];
+extern _Fcomplex matrixcf_data_qrdecomp_Q[];
+extern _Fcomplex matrixcf_data_qrdecomp_R[];
 
 // transmul
-extern float complex matrixcf_data_transmul_x[];
-extern float complex matrixcf_data_transmul_xxT[];
-extern float complex matrixcf_data_transmul_xxH[];
-extern float complex matrixcf_data_transmul_xTx[];
-extern float complex matrixcf_data_transmul_xHx[];
+extern _Fcomplex matrixcf_data_transmul_x[];
+extern _Fcomplex matrixcf_data_transmul_xxT[];
+extern _Fcomplex matrixcf_data_transmul_xxH[];
+extern _Fcomplex matrixcf_data_transmul_xTx[];
+extern _Fcomplex matrixcf_data_transmul_xHx[];
 
 #endif // __LIQUID_MATRIX_DATA_H__
-
diff --git a/src/matrix/tests/matrixcf_autotest.c b/src/matrix/tests/matrixcf_autotest.c
index 0df3a700..d6add0fb 100644
--- a/src/matrix/tests/matrixcf_autotest.c
+++ b/src/matrix/tests/matrixcf_autotest.c
@@ -36,7 +36,7 @@ void autotest_matrixcf_add()
     // x [size: 5 x 4]
     // y [size: 5 x 4]
     // z [size: 5 x 4]
-    float complex z[20];
+    _Fcomplex z[20];
     matrixcf_add(matrixcf_data_add_x,
                  matrixcf_data_add_y,
                  z,
@@ -57,11 +57,11 @@ void autotest_matrixcf_aug()
     // x [size: 5 x 4]
     // y [size: 5 x 3]
     // z [size: 5 x 7]
-    float complex z[35];
+    _Fcomplex z[35];
     matrixcf_aug(matrixcf_data_aug_x, 5, 4,
                  matrixcf_data_aug_y, 5, 3,
                  z,                  5, 7);
-    
+
     // print result
     if (liquid_autotest_verbose) {
         printf("augment:\n");
@@ -85,7 +85,7 @@ void autotest_matrixcf_chol()
 
     // A [size: 4 x 4]
     // L [size: 4 x 4]
-    float complex L[16];
+    _Fcomplex L[16];
 
     // run decomposition
     matrixcf_chol(matrixcf_data_chol_A, 4, L);
@@ -111,8 +111,8 @@ void autotest_matrixcf_inv()
 
     // x [size: 5 x 5]
     // y [size: 5 x 5]
-    float complex y[25];
-    memmove(y, matrixcf_data_inv_x, 5*5*sizeof(float complex));
+    _Fcomplex y[25];
+    memmove(y, matrixcf_data_inv_x, 5*5*sizeof(_Fcomplex));
     matrixcf_inv(y, 5, 5);
 
     if (liquid_autotest_verbose) {
@@ -137,8 +137,8 @@ void autotest_matrixcf_linsolve()
     // A [size: 5 x 5]
     // x [size: 5 x 1]
     // b [size: 5 x 1]
-    float complex x[5];
-    
+    _Fcomplex x[5];
+
     // run solver
     matrixcf_linsolve(matrixcf_data_linsolve_A, 5,
                       matrixcf_data_linsolve_b,
@@ -164,11 +164,11 @@ void autotest_matrixcf_ludecomp_crout()
 {
     float tol = 1e-5f;  // error tolerance
 
-    float complex L[64];
-    float complex U[64];
-    float complex P[64];
+    _Fcomplex L[64];
+    _Fcomplex U[64];
+    _Fcomplex P[64];
 
-    float complex LU_test[64];
+    _Fcomplex LU_test[64];
 
     // run decomposition
     matrixcf_ludecomp_crout(matrixcf_data_ludecomp_A, 8, 8, L, U, P);
@@ -214,11 +214,11 @@ void autotest_matrixcf_ludecomp_doolittle()
 {
     float tol = 1e-5f;  // error tolerance
 
-    float complex L[64];
-    float complex U[64];
-    float complex P[64];
+    _Fcomplex L[64];
+    _Fcomplex U[64];
+    _Fcomplex P[64];
 
-    float complex LU_test[64];
+    _Fcomplex LU_test[64];
 
     // run decomposition
     matrixcf_ludecomp_doolittle(matrixcf_data_ludecomp_A, 8, 8, L, U, P);
@@ -267,7 +267,7 @@ void autotest_matrixcf_mul()
     // x [size: 5 x 4]
     // y [size: 4 x 3]
     // z [size: 5 x 3]
-    float complex z[35];
+    _Fcomplex z[35];
     matrixcf_mul(matrixcf_data_mul_x, 5, 4,
                  matrixcf_data_mul_y, 4, 3,
                  z,                   5, 3);
@@ -293,11 +293,11 @@ void autotest_matrixcf_qrdecomp()
 {
     float tol = 1e-4f;  // error tolerance
 
-    float complex Q[16];
-    float complex R[16];
+    _Fcomplex Q[16];
+    _Fcomplex R[16];
 
-    float complex QR_test[16];  // Q*R
-    float complex QQT_test[16]; // Q*Q^T
+    _Fcomplex QR_test[16];  // Q*R
+    _Fcomplex QQT_test[16]; // Q*Q^T
 
     // run decomposition
     matrixcf_qrdecomp_gramschmidt(matrixcf_data_qrdecomp_A, 4, 4, Q, R);
@@ -330,7 +330,7 @@ void autotest_matrixcf_qrdecomp()
     }
 
     // ensure Q*Q^T = I(4)
-    float complex I4[16];
+    _Fcomplex I4[16];
     matrixcf_eye(I4,4);
     for (i=0; i<16; i++)
         CONTEND_DELTA( QQT_test[i], I4[i], tol );
@@ -350,10 +350,10 @@ void autotest_matrixcf_transmul()
 {
     float tol = 1e-4f;  // error tolerance
 
-    float complex xxT[25];  // [size: 5 x 5]
-    float complex xxH[25];  // [size: 5 x 5]
-    float complex xTx[16];  // [size: 4 x 4]
-    float complex xHx[16];  // [size: 4 x 4]
+    _Fcomplex xxT[25];  // [size: 5 x 5]
+    _Fcomplex xxH[25];  // [size: 5 x 5]
+    _Fcomplex xTx[16];  // [size: 4 x 4]
+    _Fcomplex xHx[16];  // [size: 4 x 4]
 
     // run matrix multiplications
     matrixcf_mul_transpose(matrixcf_data_transmul_x, 5, 4, xxT);
@@ -402,6 +402,3 @@ void autotest_matrixcf_transmul()
         CONTEND_DELTA( cimagf(matrixcf_data_transmul_xHx[i]), cimagf(xHx[i]), tol);
     }
 }
-
-
-
diff --git a/src/modem/bench/freqdem_benchmark.c b/src/modem/bench/freqdem_benchmark.c
index 11c2d543..8ae02eb8 100644
--- a/src/modem/bench/freqdem_benchmark.c
+++ b/src/modem/bench/freqdem_benchmark.c
@@ -35,7 +35,7 @@ void benchmark_freqdem(struct rusage *     _start,
     float   kf  = 0.05f; // modulation index
     freqdem dem = freqdem_create(kf);
 
-    float complex r[20];    // modulated signal
+    _Fcomplex r[20];    // modulated signal
     float         m[20];    // message signal
 
     unsigned long int i;
@@ -74,5 +74,3 @@ void benchmark_freqdem(struct rusage *     _start,
     // destroy demodulator
     freqdem_destroy(dem);
 }
-
-
diff --git a/src/modem/bench/freqmod_benchmark.c b/src/modem/bench/freqmod_benchmark.c
index a0eb3763..bae62ef5 100644
--- a/src/modem/bench/freqmod_benchmark.c
+++ b/src/modem/bench/freqmod_benchmark.c
@@ -36,7 +36,7 @@ void benchmark_freqmod(struct rusage *     _start,
     freqmod mod = freqmod_create(kf);
 
     float         m[20];    // message signal
-    float complex r[20];    // modulated signal
+    _Fcomplex r[20];    // modulated signal
 
     unsigned long int i;
 
@@ -77,5 +77,3 @@ void benchmark_freqmod(struct rusage *     _start,
     // destroy modulator
     freqmod_destroy(mod);
 }
-
-
diff --git a/src/modem/bench/fskdem_benchmark.c b/src/modem/bench/fskdem_benchmark.c
index 50e9ea82..4dd63263 100644
--- a/src/modem/bench/fskdem_benchmark.c
+++ b/src/modem/bench/fskdem_benchmark.c
@@ -49,11 +49,11 @@ void fskdem_bench(struct rusage *     _start,
     fskdem dem = fskdem_create(_m,_k,_bandwidth);
 
     //unsigned int M = 1 << _m;   // constellation size
-    
+
     unsigned long int i;
 
     // generate input vector to demodulate (spiral)
-    float complex buf[_k+10];
+    _Fcomplex buf[_k+10];
     for (i=0; i<_k+10; i++)
         buf[i] = 0.07 * i * cexpf(_Complex_I*2*M_PI*0.1*i);
 
@@ -100,4 +100,3 @@ void benchmark_fskdem_misc_M128    FSKDEM_BENCH_API( 7,  200, 0.3721451)
 void benchmark_fskdem_misc_M256    FSKDEM_BENCH_API( 8,  500, 0.3721451)
 void benchmark_fskdem_misc_M512    FSKDEM_BENCH_API( 9, 1000, 0.3721451)
 void benchmark_fskdem_misc_M1024   FSKDEM_BENCH_API(10, 2000, 0.3721451)
-
diff --git a/src/modem/bench/fskmod_benchmark.c b/src/modem/bench/fskmod_benchmark.c
index 58184d28..e228adba 100644
--- a/src/modem/bench/fskmod_benchmark.c
+++ b/src/modem/bench/fskmod_benchmark.c
@@ -49,8 +49,8 @@ void fskmod_bench(struct rusage *     _start,
     fskmod mod = fskmod_create(_m,_k,_bandwidth);
 
     unsigned int M = 1 << _m;   // constellation size
-    float complex buf[_k];      // transmit buffer
-    
+    _Fcomplex buf[_k];      // transmit buffer
+
     unsigned long int i;
 
     // start trials
@@ -96,4 +96,3 @@ void benchmark_fskmod_misc_M128    FSKMOD_BENCH_API( 7,  200, 0.3721451)
 void benchmark_fskmod_misc_M256    FSKMOD_BENCH_API( 8,  500, 0.3721451)
 void benchmark_fskmod_misc_M512    FSKMOD_BENCH_API( 9, 1000, 0.3721451)
 void benchmark_fskmod_misc_M1024   FSKMOD_BENCH_API(10, 2000, 0.3721451)
-
diff --git a/src/modem/bench/gmskmodem_benchmark.c b/src/modem/bench/gmskmodem_benchmark.c
index 55f15274..e7801b9f 100644
--- a/src/modem/bench/gmskmodem_benchmark.c
+++ b/src/modem/bench/gmskmodem_benchmark.c
@@ -26,7 +26,7 @@
 #include <sys/resource.h>
 #include "liquid.h"
 
-// 
+//
 void benchmark_gmskmodem_modulate(struct rusage *_start,
                                   struct rusage *_finish,
                                   unsigned long int *_num_iterations)
@@ -39,9 +39,9 @@ void benchmark_gmskmodem_modulate(struct rusage *_start,
     // create modem object
     gmskmod mod   = gmskmod_create(k, m, BT);
 
-    float complex x[k];
+    _Fcomplex x[k];
     unsigned int symbol_in = 0;
-    
+
     unsigned long int i;
     // start trials
     getrusage(RUSAGE_SELF, _start);
@@ -58,7 +58,7 @@ void benchmark_gmskmodem_modulate(struct rusage *_start,
     gmskmod_destroy(mod);
 }
 
-// 
+//
 void benchmark_gmskmodem_demodulate(struct rusage *_start,
                                     struct rusage *_finish,
                                     unsigned long int *_num_iterations)
@@ -71,9 +71,9 @@ void benchmark_gmskmodem_demodulate(struct rusage *_start,
     // create modem object
     gmskdem demod = gmskdem_create(k, m, BT);
 
-    float complex x[k];
+    _Fcomplex x[k];
     unsigned int symbol_out = 0;
-    
+
     unsigned long int i;
     for (i=0; i<k; i++)
         x[i] = randnf()*cexpf(_Complex_I*2*M_PI*randf());
@@ -92,4 +92,3 @@ void benchmark_gmskmodem_demodulate(struct rusage *_start,
     // destroy modem objects
     gmskdem_destroy(demod);
 }
-
diff --git a/src/modem/bench/modem_demodsoft_benchmark.c b/src/modem/bench/modem_demodsoft_benchmark.c
index bd4043d1..3250b864 100644
--- a/src/modem/bench/modem_demodsoft_benchmark.c
+++ b/src/modem/bench/modem_demodsoft_benchmark.c
@@ -66,7 +66,7 @@ void modem_demodulate_soft_bench(struct rusage *_start,
     unsigned long int i;
 
     // generate input vector to demodulate (spiral)
-    float complex x[20];
+    _Fcomplex x[20];
     for (i=0; i<20; i++)
         x[i] = 0.07 * i * cexpf(_Complex_I*2*M_PI*0.1*i);
 
@@ -158,4 +158,3 @@ void benchmark_demodsoft_arb64opt  MODEM_DEMODSOFT_BENCH_API(LIQUID_MODEM_ARB64O
 void benchmark_demodsoft_arb128opt MODEM_DEMODSOFT_BENCH_API(LIQUID_MODEM_ARB128OPT)
 void benchmark_demodsoft_arb256opt MODEM_DEMODSOFT_BENCH_API(LIQUID_MODEM_ARB256OPT)
 void benchmark_demodsoft_arb64vt   MODEM_DEMODSOFT_BENCH_API(LIQUID_MODEM_ARB64VT)
-
diff --git a/src/modem/bench/modem_demodulate_benchmark.c b/src/modem/bench/modem_demodulate_benchmark.c
index 4897dc76..2771b427 100644
--- a/src/modem/bench/modem_demodulate_benchmark.c
+++ b/src/modem/bench/modem_demodulate_benchmark.c
@@ -68,7 +68,7 @@ void modem_demodulate_bench(struct rusage *_start,
     unsigned long int i;
 
     // generate input vector to demodulate (spiral)
-    float complex x[20];
+    _Fcomplex x[20];
     for (i=0; i<20; i++)
         x[i] = 0.07 * i * cexpf(_Complex_I*2*M_PI*0.1*i);
 
@@ -159,4 +159,3 @@ void benchmark_demodulate_arb64opt  MODEM_DEMODULATE_BENCH_API(LIQUID_MODEM_ARB6
 void benchmark_demodulate_arb128opt MODEM_DEMODULATE_BENCH_API(LIQUID_MODEM_ARB128OPT)
 void benchmark_demodulate_arb256opt MODEM_DEMODULATE_BENCH_API(LIQUID_MODEM_ARB256OPT)
 void benchmark_demodulate_arb64vt   MODEM_DEMODULATE_BENCH_API(LIQUID_MODEM_ARB64VT)
-
diff --git a/src/modem/bench/modem_modulate_benchmark.c b/src/modem/bench/modem_modulate_benchmark.c
index a8577f4e..133d7b9f 100644
--- a/src/modem/bench/modem_modulate_benchmark.c
+++ b/src/modem/bench/modem_modulate_benchmark.c
@@ -64,9 +64,9 @@ void modem_modulate_bench(struct rusage *_start,
     // initialize modulator
     modem mod = modem_create(_ms);
 
-    float complex x;
+    _Fcomplex x;
     unsigned int symbol_in = 0;
-    
+
     unsigned long int i;
 
     // start trials
@@ -138,4 +138,3 @@ void benchmark_modulate_arb64opt  MODEM_MODULATE_BENCH_API(LIQUID_MODEM_ARB64OPT
 void benchmark_modulate_arb128opt MODEM_MODULATE_BENCH_API(LIQUID_MODEM_ARB128OPT)
 void benchmark_modulate_arb256opt MODEM_MODULATE_BENCH_API(LIQUID_MODEM_ARB256OPT)
 void benchmark_modulate_arb64vt   MODEM_MODULATE_BENCH_API(LIQUID_MODEM_ARB64VT)
-
diff --git a/src/modem/src/ampmodem.c b/src/modem/src/ampmodem.c
index a17ecfa6..8951f63a 100644
--- a/src/modem/src/ampmodem.c
+++ b/src/modem/src/ampmodem.c
@@ -31,11 +31,11 @@
 #include "liquid.internal.h"
 
 // internal methods for specific demodulation methods
-void ampmodem_demod_dsb_peak_detect(ampmodem _q, float complex _x, float * _m);
-void ampmodem_demod_dsb_pll_carrier(ampmodem _q, float complex _x, float * _m);
-void ampmodem_demod_dsb_pll_costas (ampmodem _q, float complex _x, float * _m);
-void ampmodem_demod_ssb_pll_carrier(ampmodem _q, float complex _x, float * _m);
-void ampmodem_demod_ssb            (ampmodem _q, float complex _x, float * _m);
+void ampmodem_demod_dsb_peak_detect(ampmodem _q, _Fcomplex _x, float * _m);
+void ampmodem_demod_dsb_pll_carrier(ampmodem _q, _Fcomplex _x, float * _m);
+void ampmodem_demod_dsb_pll_costas (ampmodem _q, _Fcomplex _x, float * _m);
+void ampmodem_demod_ssb_pll_carrier(ampmodem _q, _Fcomplex _x, float * _m);
+void ampmodem_demod_ssb            (ampmodem _q, _Fcomplex _x, float * _m);
 
 struct ampmodem_s {
     // modulation index
@@ -56,7 +56,7 @@ struct ampmodem_s {
     wdelaycf        delay;      // delay buffer to align to low-pass filter delay
 
     // demodulation function pointer
-    void (*demod)(ampmodem _q, float complex _x, float * _m);
+    void (*demod)(ampmodem _q, _Fcomplex _x, float * _m);
 };
 
 // create ampmodem object
@@ -189,9 +189,9 @@ unsigned int ampmodem_get_delay_demod(ampmodem _q)
 
 void ampmodem_modulate(ampmodem        _q,
                        float           _x,
-                       float complex * _y)
+                       _Fcomplex * _y)
 {
-    float complex x_hat = 0.0f;
+    _Fcomplex x_hat = 0.0f;
 
     if (_q->type == LIQUID_AMPMODEM_DSB) {
         x_hat = _x;
@@ -217,7 +217,7 @@ void ampmodem_modulate(ampmodem        _q,
 void ampmodem_modulate_block(ampmodem        _q,
                              float *         _m,
                              unsigned int    _n,
-                             float complex * _s)
+                             _Fcomplex * _s)
 {
     // TODO: implement more efficient method
     unsigned int i;
@@ -227,7 +227,7 @@ void ampmodem_modulate_block(ampmodem        _q,
 
 // demodulate
 void ampmodem_demodulate(ampmodem      _q,
-                         float complex _y,
+                         _Fcomplex _y,
                          float *       _x)
 {
     // invoke internal type-specific method
@@ -240,7 +240,7 @@ void ampmodem_demodulate(ampmodem      _q,
 //  _n      :   number of input, output samples
 //  _x      :   message signal m(t), [size: _n x 1]
 void ampmodem_demodulate_block(ampmodem        _q,
-                               float complex * _y,
+                               _Fcomplex * _y,
                                unsigned int    _n,
                                float *         _x)
 {
@@ -257,7 +257,7 @@ void ampmodem_demodulate_block(ampmodem        _q,
 //
 
 void ampmodem_demod_dsb_peak_detect(ampmodem      _q,
-                                    float complex _x,
+                                    _Fcomplex _x,
                                     float *       _y)
 {
     // compute signal magnitude
@@ -272,20 +272,20 @@ void ampmodem_demod_dsb_peak_detect(ampmodem      _q,
 }
 
 void ampmodem_demod_dsb_pll_carrier(ampmodem      _q,
-                                    float complex _x,
+                                    _Fcomplex _x,
                                     float *       _y)
 {
     // split signal into two branches:
     //   0. low-pass filter for carrier recovery and
     //   1. delay to align signal output
-    float complex x0, x1;
+    _Fcomplex x0, x1;
     firfilt_crcf_push   (_q->lowpass, _x);
     firfilt_crcf_execute(_q->lowpass, &x0);
     wdelaycf_push       (_q->delay,   _x);
     wdelaycf_read       (_q->delay,   &x1);
 
     // mix each signal down
-    float complex v0, v1;
+    _Fcomplex v0, v1;
     nco_crcf_mix_down(_q->mixer, x0, &v0);
     nco_crcf_mix_down(_q->mixer, x1, &v1);
 
@@ -307,11 +307,11 @@ void ampmodem_demod_dsb_pll_carrier(ampmodem      _q,
 }
 
 void ampmodem_demod_dsb_pll_costas(ampmodem      _q,
-                                   float complex _x,
+                                   _Fcomplex _x,
                                    float *       _y)
 {
     // mix signal down
-    float complex v;
+    _Fcomplex v;
     nco_crcf_mix_down(_q->mixer, _x, &v);
 
     // compute phase error
@@ -329,20 +329,20 @@ void ampmodem_demod_dsb_pll_costas(ampmodem      _q,
 }
 
 void ampmodem_demod_ssb_pll_carrier(ampmodem      _q,
-                                    float complex _x,
+                                    _Fcomplex _x,
                                     float *       _y)
 {
     // split signal into two branches:
     //   0. low-pass filter for carrier recovery and
     //   1. delay to align signal output
-    float complex x0, x1;
+    _Fcomplex x0, x1;
     firfilt_crcf_push   (_q->lowpass, _x);
     firfilt_crcf_execute(_q->lowpass, &x0);
     wdelaycf_push       (_q->delay,   _x);
     wdelaycf_read       (_q->delay,   &x1);
 
     // mix each signal down
-    float complex v0, v1;
+    _Fcomplex v0, v1;
     nco_crcf_mix_down(_q->mixer, x0, &v0);
     nco_crcf_mix_down(_q->mixer, x1, &v1);
 
@@ -368,7 +368,7 @@ void ampmodem_demod_ssb_pll_carrier(ampmodem      _q,
 }
 
 void ampmodem_demod_ssb(ampmodem      _q,
-                        float complex _x,
+                        _Fcomplex _x,
                         float *       _y)
 {
     // apply hilbert transform and retrieve both upper and lower side-bands
@@ -378,4 +378,3 @@ void ampmodem_demod_ssb(ampmodem      _q,
     // recover message
     *_y = 0.5f * (_q->type == LIQUID_AMPMODEM_USB ? m_usb : m_lsb) / _q->mod_index;
 }
-
diff --git a/src/modem/src/cpfskdem.c b/src/modem/src/cpfskdem.c
index f1881231..ba073431 100644
--- a/src/modem/src/cpfskdem.c
+++ b/src/modem/src/cpfskdem.c
@@ -32,7 +32,7 @@
 
 #define DEBUG_CPFSKDEM  0
 
-// 
+//
 // internal methods
 //
 
@@ -45,23 +45,23 @@ void cpfskdem_init_noncoherent(cpfskdem _q);
 #if 0
 // demodulate array of samples (coherent)
 void cpfskdem_demodulate_coherent(cpfskdem        _q,
-                                  float complex   _y,
+                                  _Fcomplex   _y,
                                   unsigned int  * _s,
                                   unsigned int  * _nw);
 
 // demodulate array of samples (non-coherent)
 void cpfskdem_demodulate_noncoherent(cpfskdem        _q,
-                                     float complex   _y,
+                                     _Fcomplex   _y,
                                      unsigned int  * _s,
                                      unsigned int  * _nw);
 #else
 // demodulate array of samples (coherent)
 unsigned int cpfskdem_demodulate_coherent(cpfskdem        _q,
-                                          float complex * _y);
+                                          _Fcomplex * _y);
 
 // demodulate array of samples (non-coherent)
 unsigned int cpfskdem_demodulate_noncoherent(cpfskdem        _q,
-                                             float complex * _y);
+                                             _Fcomplex * _y);
 #endif
 
 // cpfskdem
@@ -85,12 +85,12 @@ struct cpfskdem_s {
     // demodulation function pointer
 #if 0
     void (*demodulate)(cpfskdem        _q,
-                       float complex   _y,
+                       _Fcomplex   _y,
                        unsigned int  * _s,
                        unsigned int  * _nw);
 #else
     unsigned int (*demodulate)(cpfskdem        _q,
-                               float complex * _y);
+                               _Fcomplex * _y);
 #endif
 
     // common data structure shared between coherent and non-coherent
@@ -103,7 +103,7 @@ struct cpfskdem_s {
             firpfb_crcf mf;     // matched filter
             firpfb_crcf dmf;    // matched filter (derivative)
             */
-            
+
             firfilt_crcf mf;    // matched filter
         } coherent;
 
@@ -118,7 +118,7 @@ struct cpfskdem_s {
     // state variables
     unsigned int  index;    // debug
     unsigned int  counter;  // sample counter
-    float complex z_prime;  // (coherent only)
+    _Fcomplex z_prime;  // (coherent only)
 };
 
 // create cpfskdem object (frequency demodulator)
@@ -242,7 +242,7 @@ void cpfskdem_init_noncoherent(cpfskdem _q)
 {
     // specify non-coherent receiver
     _q->demod_type = CPFSKDEM_NONCOHERENT;
-    
+
     // set demodulate function pointer
     _q->demodulate = cpfskdem_demodulate_noncoherent;
 
@@ -311,7 +311,7 @@ unsigned int cpfskdem_get_delay(cpfskdem _q)
 //  _s      :   output symbol array
 //  _nw     :   number of output symbols written
 void cpfskdem_demodulate(cpfskdem        _q,
-                         float complex * _y,
+                         _Fcomplex * _y,
                          unsigned int    _n,
                          unsigned int  * _s,
                          unsigned int  * _nw)
@@ -333,7 +333,7 @@ void cpfskdem_demodulate(cpfskdem        _q,
 
 // demodulate array of samples (coherent)
 void cpfskdem_demodulate_coherent(cpfskdem        _q,
-                                  float complex   _y,
+                                  _Fcomplex   _y,
                                   unsigned int  * _s,
                                   unsigned int  * _nw)
 {
@@ -345,7 +345,7 @@ void cpfskdem_demodulate_coherent(cpfskdem        _q,
 
 #if DEBUG_CPFSKDEM
     // compute output sample
-    float complex zp;
+    _Fcomplex zp;
     firfilt_crcf_execute(_q->data.coherent.mf, &zp);
     printf("y(end+1) = %12.8f + 1i*%12.8f;\n", crealf(_y), cimagf(_y));
     printf("z(end+1) = %12.8f + 1i*%12.8f;\n", crealf(zp), cimagf(zp));
@@ -356,9 +356,9 @@ void cpfskdem_demodulate_coherent(cpfskdem        _q,
     if ( (_q->counter % _q->k)==0 ) {
         // reset sample counter
         _q->counter = 0;
-    
+
         // compute output sample
-        float complex z;
+        _Fcomplex z;
         firfilt_crcf_execute(_q->data.coherent.mf, &z);
 
         // compute instantaneous frequency scaled by modulation index
@@ -386,7 +386,7 @@ void cpfskdem_demodulate_coherent(cpfskdem        _q,
 
 // demodulate array of samples (non-coherent)
 void cpfskdem_demodulate_noncoherent(cpfskdem        _q,
-                                     float complex   _y,
+                                     _Fcomplex   _y,
                                      unsigned int  * _s,
                                      unsigned int  * _nw)
 {
@@ -399,14 +399,14 @@ void cpfskdem_demodulate_noncoherent(cpfskdem        _q,
 //  _q      :   continuous-phase frequency demodulator object
 //  _y      :   input sample array [size: _k x 1]
 unsigned int cpfskdem_demodulate(cpfskdem        _q,
-                                 float complex * _y)
+                                 _Fcomplex * _y)
 {
     return _q->demodulate(_q, _y);
 }
 
 // demodulate array of samples (coherent)
 unsigned int cpfskdem_demodulate_coherent(cpfskdem        _q,
-                                          float complex * _y)
+                                          _Fcomplex * _y)
 {
     unsigned int i;
     unsigned int sym_out = 0;
@@ -417,7 +417,7 @@ unsigned int cpfskdem_demodulate_coherent(cpfskdem        _q,
 
 #if DEBUG_CPFSKDEM
         // compute output sample
-        float complex zp;
+        _Fcomplex zp;
         firfilt_crcf_execute(_q->data.coherent.mf, &zp);
         printf("y(end+1) = %12.8f + 1i*%12.8f;\n", crealf(_y), cimagf(_y));
         printf("z(end+1) = %12.8f + 1i*%12.8f;\n", crealf(zp), cimagf(zp));
@@ -426,7 +426,7 @@ unsigned int cpfskdem_demodulate_coherent(cpfskdem        _q,
         // decimate output
         if ( i == 0 ) {
             // compute output sample
-            float complex z;
+            _Fcomplex z;
             firfilt_crcf_execute(_q->data.coherent.mf, &z);
 
             // compute instantaneous frequency scaled by modulation index
@@ -452,9 +452,8 @@ unsigned int cpfskdem_demodulate_coherent(cpfskdem        _q,
 
 // demodulate array of samples (non-coherent)
 unsigned int cpfskdem_demodulate_noncoherent(cpfskdem        _q,
-                                             float complex * _y)
+                                             _Fcomplex * _y)
 {
     return 0;
 }
 #endif
-
diff --git a/src/modem/src/cpfskmod.c b/src/modem/src/cpfskmod.c
index e44cd82c..f473efa7 100644
--- a/src/modem/src/cpfskmod.c
+++ b/src/modem/src/cpfskmod.c
@@ -30,7 +30,7 @@
 
 #include "liquid.internal.h"
 
-// 
+//
 // internal methods
 //
 
@@ -220,7 +220,7 @@ unsigned int cpfskmod_get_delay(cpfskmod _q)
 //  _y      :   output sample array [size: _k x 1]
 void cpfskmod_modulate(cpfskmod        _q,
                        unsigned int    _s,
-                       float complex * _y)
+                       _Fcomplex * _y)
 {
     // run interpolator
     float v = 2.0f*_s - (float)(_q->M) + 1.0f;
@@ -238,7 +238,7 @@ void cpfskmod_modulate(cpfskmod        _q,
     }
 }
 
-// 
+//
 // internal methods
 //
 
@@ -308,4 +308,3 @@ void cpfskmod_firdes(unsigned int _k,
     for (i=0; i<_ht_len; i++)
         _ht[i] *= 1.0f / ht_sum;
 }
-
diff --git a/src/modem/src/fskdem.c b/src/modem/src/fskdem.c
index 1edab70b..fe9c8a20 100644
--- a/src/modem/src/fskdem.c
+++ b/src/modem/src/fskdem.c
@@ -33,7 +33,7 @@
 
 #define DEBUG_FSKDEM 0
 
-// 
+//
 // internal methods
 //
 
@@ -48,8 +48,8 @@ struct fskdem_s {
     unsigned int    M;          // constellation size
     float           M2;         // (M-1)/2
     unsigned int    K;          // FFT size
-    float complex * buf_time;   // FFT input buffer
-    float complex * buf_freq;   // FFT output buffer
+    _Fcomplex * buf_time;   // FFT input buffer
+    _Fcomplex * buf_freq;   // FFT output buffer
     FFT_PLAN        fft;        // FFT object
     unsigned int *  demod_map;  // demodulation map
 
@@ -116,7 +116,7 @@ fskdem fskdem_create(unsigned int _m,
         if (err < 1e-6f)
             break;
     }
-    
+
     // determine demodulation mapping between tones and frequency bins
     // TODO: use gray coding
     q->demod_map = (unsigned int *) malloc(q->M * sizeof(unsigned int));
@@ -141,8 +141,8 @@ fskdem fskdem_create(unsigned int _m,
     }
 
     // allocate memory for transform
-    q->buf_time = (float complex*) malloc(q->K * sizeof(float complex));
-    q->buf_freq = (float complex*) malloc(q->K * sizeof(float complex));
+    q->buf_time = (_Fcomplex*) malloc(q->K * sizeof(_Fcomplex));
+    q->buf_freq = (_Fcomplex*) malloc(q->K * sizeof(_Fcomplex));
     q->fft = FFT_CREATE_PLAN(q->K, q->buf_time, q->buf_freq, FFT_DIR_FORWARD, 0);
 
     // reset modem object
@@ -192,10 +192,10 @@ void fskdem_reset(fskdem _q)
 //  _q      :   fskdem object
 //  _y      :   input sample array [size: _k x 1]
 unsigned int fskdem_demodulate(fskdem          _q,
-                               float complex * _y)
+                               _Fcomplex * _y)
 {
     // copy input to internal time buffer
-    memmove(_q->buf_time, _y, _q->k*sizeof(float complex));
+    memmove(_q->buf_time, _y, _q->k*sizeof(_Fcomplex));
 
     // compute transform, storing result in 'buf_freq'
     FFT_EXECUTE(_q->fft);
@@ -256,7 +256,7 @@ float fskdem_get_symbol_energy(fskdem       _q,
     unsigned int index = _q->demod_map[_s];
 
     // compute energy around FFT bin
-    float complex v = _q->buf_freq[index];
+    _Fcomplex v = _q->buf_freq[index];
     float energy = crealf(v)*crealf(v) + cimagf(v)*cimagf(v);
     int i;
     for (i=0; i<_range; i++) {
@@ -264,8 +264,8 @@ float fskdem_get_symbol_energy(fskdem       _q,
         unsigned int i0 = (index         + i) % _q->K;
         unsigned int i1 = (index + _q->K - i) % _q->K;
 
-        float complex v0 = _q->buf_freq[i0];
-        float complex v1 = _q->buf_freq[i1];
+        _Fcomplex v0 = _q->buf_freq[i0];
+        _Fcomplex v1 = _q->buf_freq[i1];
 
         energy += crealf(v0)*crealf(v0) + cimagf(v0)*cimagf(v0);
         energy += crealf(v1)*crealf(v1) + cimagf(v1)*cimagf(v1);
@@ -273,4 +273,3 @@ float fskdem_get_symbol_energy(fskdem       _q,
 
     return energy;
 }
-
diff --git a/src/modem/src/fskmod.c b/src/modem/src/fskmod.c
index d19f610e..8697cc24 100644
--- a/src/modem/src/fskmod.c
+++ b/src/modem/src/fskmod.c
@@ -30,7 +30,7 @@
 
 #include "liquid.internal.h"
 
-// 
+//
 // internal methods
 //
 
@@ -119,7 +119,7 @@ void fskmod_reset(fskmod _q)
 //  _y      :   output sample array [size: _k x 1]
 void fskmod_modulate(fskmod          _q,
                      unsigned int    _s,
-                     float complex * _y)
+                     _Fcomplex * _y)
 {
     // validate input
     if (_s >= _q->M) {
@@ -139,9 +139,8 @@ void fskmod_modulate(fskmod          _q,
     for (i=0; i<_q->k; i++) {
         // compute complex output
         nco_crcf_cexpf(_q->oscillator, &_y[i]);
-        
+
         // step oscillator
         nco_crcf_step(_q->oscillator);
     }
 }
-
diff --git a/src/modem/src/gmskdem.c b/src/modem/src/gmskdem.c
index e3a19cf1..dbb33f99 100644
--- a/src/modem/src/gmskdem.c
+++ b/src/modem/src/gmskdem.c
@@ -55,7 +55,7 @@ struct gmskdem_s {
     firfilt_rrrf filter;    // receiver matched filter
 #endif
 
-    float complex x_prime;  // received signal state
+    _Fcomplex x_prime;  // received signal state
 
     // demodulated symbols counter
     unsigned int num_symbols_demod;
@@ -194,7 +194,7 @@ void gmskdem_set_eq_bw(gmskdem _q,
 }
 
 void gmskdem_demodulate(gmskdem _q,
-                        float complex * _x,
+                        _Fcomplex * _x,
                         unsigned int * _s)
 {
     // increment symbol counter
diff --git a/src/modem/src/gmskmod.c b/src/modem/src/gmskmod.c
index 0b3d1383..4b61a165 100644
--- a/src/modem/src/gmskmod.c
+++ b/src/modem/src/gmskmod.c
@@ -123,7 +123,7 @@ void gmskmod_reset(gmskmod _q)
 
 void gmskmod_modulate(gmskmod _q,
                       unsigned int _s,
-                      float complex * _y)
+                      _Fcomplex * _y)
 {
     // generate sample from symbol
     float x = _s==0 ? -_q->k_inv : _q->k_inv;
@@ -148,5 +148,3 @@ void gmskmod_modulate(gmskmod _q,
 
 
 }
-
-
diff --git a/src/modem/src/modem_arb_const.c b/src/modem/src/modem_arb_const.c
index 4c99a640..7d2d62c3 100644
--- a/src/modem/src/modem_arb_const.c
+++ b/src/modem/src/modem_arb_const.c
@@ -30,47 +30,47 @@
 #include "liquid.internal.h"
 
 // 'square' 32-QAM (first quadrant)
-const float complex modem_arb_sqam32[8] = {
-      0.22361000+  0.22361000*_Complex_I,   0.67082000+  0.22361000*_Complex_I, 
-      0.67082000+  1.11800000*_Complex_I,   1.11800000+  0.22361000*_Complex_I, 
-      0.22361000+  0.67082000*_Complex_I,   0.67082000+  0.67082000*_Complex_I, 
+const _Fcomplex modem_arb_sqam32[8] = {
+      0.22361000+  0.22361000*_Complex_I,   0.67082000+  0.22361000*_Complex_I,
+      0.67082000+  1.11800000*_Complex_I,   1.11800000+  0.22361000*_Complex_I,
+      0.22361000+  0.67082000*_Complex_I,   0.67082000+  0.67082000*_Complex_I,
       0.22361000+  1.11800000*_Complex_I,   1.11800000+  0.67082000*_Complex_I
 };
 
 // 'square' 128-QAM (first quadrant)
-const float complex modem_arb_sqam128[32] = {
-      0.11043000+  0.11043000*_Complex_I,   0.33129000+  0.11043000*_Complex_I, 
-      0.11043000+  0.33129000*_Complex_I,   0.33129000+  0.33129000*_Complex_I, 
-      0.77302000+  0.11043000*_Complex_I,   0.55216000+  0.11043000*_Complex_I, 
-      0.77302000+  0.33129000*_Complex_I,   0.55216000+  0.33129000*_Complex_I, 
-      0.77302000+  0.99388000*_Complex_I,   0.55216000+  0.99388000*_Complex_I, 
-      0.77302000+  1.21470000*_Complex_I,   0.55216000+  1.21470000*_Complex_I, 
-      0.99388000+  0.11043000*_Complex_I,   1.21470000+  0.11043000*_Complex_I, 
-      0.99388000+  0.33129000*_Complex_I,   1.21470000+  0.33129000*_Complex_I, 
-      0.11043000+  0.77302000*_Complex_I,   0.33129000+  0.77302000*_Complex_I, 
-      0.11043000+  0.55216000*_Complex_I,   0.33129000+  0.55216000*_Complex_I, 
-      0.77302000+  0.77302000*_Complex_I,   0.55216000+  0.77302000*_Complex_I, 
-      0.77302000+  0.55216000*_Complex_I,   0.55216000+  0.55216000*_Complex_I, 
-      0.11043000+  0.99388000*_Complex_I,   0.33129000+  0.99388000*_Complex_I, 
-      0.11043000+  1.21470000*_Complex_I,   0.33129000+  1.21470000*_Complex_I, 
-      0.99388000+  0.77302000*_Complex_I,   1.21470000+  0.77302000*_Complex_I, 
+const _Fcomplex modem_arb_sqam128[32] = {
+      0.11043000+  0.11043000*_Complex_I,   0.33129000+  0.11043000*_Complex_I,
+      0.11043000+  0.33129000*_Complex_I,   0.33129000+  0.33129000*_Complex_I,
+      0.77302000+  0.11043000*_Complex_I,   0.55216000+  0.11043000*_Complex_I,
+      0.77302000+  0.33129000*_Complex_I,   0.55216000+  0.33129000*_Complex_I,
+      0.77302000+  0.99388000*_Complex_I,   0.55216000+  0.99388000*_Complex_I,
+      0.77302000+  1.21470000*_Complex_I,   0.55216000+  1.21470000*_Complex_I,
+      0.99388000+  0.11043000*_Complex_I,   1.21470000+  0.11043000*_Complex_I,
+      0.99388000+  0.33129000*_Complex_I,   1.21470000+  0.33129000*_Complex_I,
+      0.11043000+  0.77302000*_Complex_I,   0.33129000+  0.77302000*_Complex_I,
+      0.11043000+  0.55216000*_Complex_I,   0.33129000+  0.55216000*_Complex_I,
+      0.77302000+  0.77302000*_Complex_I,   0.55216000+  0.77302000*_Complex_I,
+      0.77302000+  0.55216000*_Complex_I,   0.55216000+  0.55216000*_Complex_I,
+      0.11043000+  0.99388000*_Complex_I,   0.33129000+  0.99388000*_Complex_I,
+      0.11043000+  1.21470000*_Complex_I,   0.33129000+  1.21470000*_Complex_I,
+      0.99388000+  0.77302000*_Complex_I,   1.21470000+  0.77302000*_Complex_I,
       0.99388000+  0.55216000*_Complex_I,   1.21470000+  0.55216000*_Complex_I
 };
 
 // V.29 star constellation
-const float complex modem_arb_V29[16] = {
-      0.06804100+  0.06804100*_Complex_I,   0.20412000+  0.00000000*_Complex_I, 
-      0.00000000+  0.20412000*_Complex_I,  -0.06804100+  0.06804100*_Complex_I, 
-      0.00000000+ -0.20412000*_Complex_I,   0.06804100+ -0.06804100*_Complex_I, 
-     -0.06804100+ -0.06804100*_Complex_I,  -0.20412000+  0.00000000*_Complex_I, 
-      0.20412000+  0.20412000*_Complex_I,   0.34021000+  0.00000000*_Complex_I, 
-      0.00000000+  0.34021000*_Complex_I,  -0.20412000+  0.20412000*_Complex_I, 
-      0.00000000+ -0.34021000*_Complex_I,   0.20412000+ -0.20412000*_Complex_I, 
+const _Fcomplex modem_arb_V29[16] = {
+      0.06804100+  0.06804100*_Complex_I,   0.20412000+  0.00000000*_Complex_I,
+      0.00000000+  0.20412000*_Complex_I,  -0.06804100+  0.06804100*_Complex_I,
+      0.00000000+ -0.20412000*_Complex_I,   0.06804100+ -0.06804100*_Complex_I,
+     -0.06804100+ -0.06804100*_Complex_I,  -0.20412000+  0.00000000*_Complex_I,
+      0.20412000+  0.20412000*_Complex_I,   0.34021000+  0.00000000*_Complex_I,
+      0.00000000+  0.34021000*_Complex_I,  -0.20412000+  0.20412000*_Complex_I,
+      0.00000000+ -0.34021000*_Complex_I,   0.20412000+ -0.20412000*_Complex_I,
      -0.20412000+ -0.20412000*_Complex_I,  -0.34021000+  0.00000000*_Complex_I
 };
 
 // Virginia Tech logo
-const float complex modem_arb_vt64[64] = {
+const _Fcomplex modem_arb_vt64[64] = {
      -1.5633e+00+  5.5460e-01*_Complex_I,  -1.3833e+00+  5.5460e-01*_Complex_I,
      -1.0234e+00+  5.5460e-01*_Complex_I,  -1.2034e+00+  5.5460e-01*_Complex_I,
      -7.3553e-01+  5.0751e-02*_Complex_I,  -8.0750e-01+  1.7671e-01*_Complex_I,
@@ -106,39 +106,39 @@ const float complex modem_arb_vt64[64] = {
 };
 
 // optimal 16-QAM
-const float complex modem_arb16opt[16] = {
-     -0.87119000+ -0.87970000*_Complex_I,  -1.15090000+ -0.26101000*_Complex_I, 
-     -1.10090000+  0.87457000*_Complex_I,  -0.81088000+  0.29689000*_Complex_I, 
-     -0.21295000+ -0.91897000*_Complex_I,  -0.46984000+ -0.29804000*_Complex_I, 
-     -0.43443000+  0.91820000*_Complex_I,  -0.16786000+  0.30338000*_Complex_I, 
-      1.10000000+ -0.87511000*_Complex_I,   0.81125000+ -0.29671000*_Complex_I, 
-      0.87134000+  0.87989000*_Complex_I,   1.15170000+  0.26143000*_Complex_I, 
-      0.43379000+ -0.91801000*_Complex_I,   0.16807000+ -0.30335000*_Complex_I, 
+const _Fcomplex modem_arb16opt[16] = {
+     -0.87119000+ -0.87970000*_Complex_I,  -1.15090000+ -0.26101000*_Complex_I,
+     -1.10090000+  0.87457000*_Complex_I,  -0.81088000+  0.29689000*_Complex_I,
+     -0.21295000+ -0.91897000*_Complex_I,  -0.46984000+ -0.29804000*_Complex_I,
+     -0.43443000+  0.91820000*_Complex_I,  -0.16786000+  0.30338000*_Complex_I,
+      1.10000000+ -0.87511000*_Complex_I,   0.81125000+ -0.29671000*_Complex_I,
+      0.87134000+  0.87989000*_Complex_I,   1.15170000+  0.26143000*_Complex_I,
+      0.43379000+ -0.91801000*_Complex_I,   0.16807000+ -0.30335000*_Complex_I,
       0.21246000+  0.91867000*_Complex_I,   0.47033000+  0.29787000*_Complex_I
 };
 
 // optimal 32-QAM
-const float complex modem_arb32opt[32] = {
-     -1.04570000+ -0.72639000*_Complex_I,  -1.26710000+ -0.00824020*_Complex_I, 
-     -0.99868000+  0.92359000*_Complex_I,  -1.13660000+  0.45833000*_Complex_I, 
-     -0.67812000+ -1.07470000*_Complex_I,  -0.88363000+ -0.25914000*_Complex_I, 
-     -0.64443000+  0.62407000*_Complex_I,  -0.76238000+  0.18163000*_Complex_I, 
-     -0.20985000+ -0.91032000*_Complex_I,  -0.08603100+ -0.45730000*_Complex_I, 
-     -0.18073000+  0.75747000*_Complex_I,   0.02826900+ -0.01908400*_Complex_I, 
-     -0.55206000+ -0.61092000*_Complex_I,  -0.42946000+ -0.16611000*_Complex_I, 
-     -0.51187000+  1.09190000*_Complex_I,  -0.30769000+  0.27731000*_Complex_I, 
-      1.20280000+ -0.58421000*_Complex_I,   1.29120000+ -0.09249800*_Complex_I, 
-      1.10450000+  0.69170000*_Complex_I,   0.96433000+  0.24011000*_Complex_I, 
-      0.60130000+ -1.16500000*_Complex_I,   0.83106000+ -0.23576000*_Complex_I, 
-      0.73090000+  1.01880000*_Complex_I,   0.62090000+  0.54470000*_Complex_I, 
-      0.23884000+ -0.81583000*_Complex_I,   0.36064000+ -0.36749000*_Complex_I, 
-     -0.02439300+  1.23570000*_Complex_I,   0.15492000+  0.41465000*_Complex_I, 
-      0.11172000+ -1.28340000*_Complex_I,   0.70560000+ -0.68005000*_Complex_I, 
+const _Fcomplex modem_arb32opt[32] = {
+     -1.04570000+ -0.72639000*_Complex_I,  -1.26710000+ -0.00824020*_Complex_I,
+     -0.99868000+  0.92359000*_Complex_I,  -1.13660000+  0.45833000*_Complex_I,
+     -0.67812000+ -1.07470000*_Complex_I,  -0.88363000+ -0.25914000*_Complex_I,
+     -0.64443000+  0.62407000*_Complex_I,  -0.76238000+  0.18163000*_Complex_I,
+     -0.20985000+ -0.91032000*_Complex_I,  -0.08603100+ -0.45730000*_Complex_I,
+     -0.18073000+  0.75747000*_Complex_I,   0.02826900+ -0.01908400*_Complex_I,
+     -0.55206000+ -0.61092000*_Complex_I,  -0.42946000+ -0.16611000*_Complex_I,
+     -0.51187000+  1.09190000*_Complex_I,  -0.30769000+  0.27731000*_Complex_I,
+      1.20280000+ -0.58421000*_Complex_I,   1.29120000+ -0.09249800*_Complex_I,
+      1.10450000+  0.69170000*_Complex_I,   0.96433000+  0.24011000*_Complex_I,
+      0.60130000+ -1.16500000*_Complex_I,   0.83106000+ -0.23576000*_Complex_I,
+      0.73090000+  1.01880000*_Complex_I,   0.62090000+  0.54470000*_Complex_I,
+      0.23884000+ -0.81583000*_Complex_I,   0.36064000+ -0.36749000*_Complex_I,
+     -0.02439300+  1.23570000*_Complex_I,   0.15492000+  0.41465000*_Complex_I,
+      0.11172000+ -1.28340000*_Complex_I,   0.70560000+ -0.68005000*_Complex_I,
       0.28323000+  0.89268000*_Complex_I,   0.48844000+  0.10367000*_Complex_I
 };
 
 // optimal 64-QAM
-const float complex modem_arb64opt[64] = {
+const _Fcomplex modem_arb64opt[64] = {
      -9.6048e-01 +  -1.0031e+00*_Complex_I,
      -1.1105e+00 +  -6.8896e-01*_Complex_I,
      -1.1029e+00 +  -9.5064e-02*_Complex_I,
@@ -205,7 +205,7 @@ const float complex modem_arb64opt[64] = {
       3.9791e-01 +   1.8370e-01*_Complex_I,
 };
 // optimal 128-QAM
-const float complex modem_arb128opt[128] = {
+const _Fcomplex modem_arb128opt[128] = {
      -1.0682e+00 +  -9.2598e-01*_Complex_I,
      -1.1831e+00 +  -7.0704e-01*_Complex_I,
      -1.3029e+00 +  -1.0555e-01*_Complex_I,
@@ -337,7 +337,7 @@ const float complex modem_arb128opt[128] = {
 
 
 // optimal 256-QAM
-const float complex modem_arb256opt[256] = {
+const _Fcomplex modem_arb256opt[256] = {
      -9.3121e-01 +  -1.0845e+00*_Complex_I,
      -1.0165e+00 +  -9.3103e-01*_Complex_I,
      -1.1864e+00 +  -6.3650e-01*_Complex_I,
diff --git a/src/modem/src/modem_ook.c b/src/modem/src/modem_ook.c
index 7f7b62ff..72409ea7 100644
--- a/src/modem/src/modem_ook.c
+++ b/src/modem/src/modem_ook.c
@@ -51,7 +51,7 @@ MODEM() MODEM(_create_ook)()
 // modulate symbol using on/off keying
 void MODEM(_modulate_ook)(MODEM()         _q,
                           unsigned int    _sym_in,
-                          float complex * _y)
+                          _Fcomplex * _y)
 {
     // compute output sample directly from input
     *_y = _sym_in ? 0.0f : M_SQRT2;
@@ -59,7 +59,7 @@ void MODEM(_modulate_ook)(MODEM()         _q,
 
 // demodulate OOK
 void MODEM(_demodulate_ook)(MODEM()        _q,
-                            float complex  _x,
+                            _Fcomplex  _x,
                             unsigned int * _sym_out)
 {
     // slice directly to output symbol
@@ -69,4 +69,3 @@ void MODEM(_demodulate_ook)(MODEM()        _q,
     MODEM(_modulate_ook)(_q, *_sym_out, &_q->x_hat);
     _q->r = _x;
 }
-
diff --git a/src/modem/src/modemf.c b/src/modem/src/modemf.c
index 4d8aeb52..8d7cc515 100644
--- a/src/modem/src/modemf.c
+++ b/src/modem/src/modemf.c
@@ -34,7 +34,7 @@
 #define FREQDEM(name)       LIQUID_CONCAT(freqdem,name)
 
 #define T                   float           /* primitive type */
-#define TC                  float complex   /* primitive type (complex) */
+#define TC                  _Fcomplex   /* primitive type (complex) */
 
 #define PRINTVAL_T(X,F)     PRINTVAL_FLOAT(X,F)
 #define PRINTVAL_TC(X,F)    PRINTVAL_CFLOAT(X,F)
diff --git a/src/modem/tests/ampmodem_autotest.c b/src/modem/tests/ampmodem_autotest.c
index 60c56726..de224f3c 100644
--- a/src/modem/tests/ampmodem_autotest.c
+++ b/src/modem/tests/ampmodem_autotest.c
@@ -65,11 +65,11 @@ void ampmodem_test_harness(float                _mod_index,
         wdelayf_push(message_delay, msg_in);
 
         // modulate
-        float complex x;
+        _Fcomplex x;
         ampmodem_modulate(mod, msg_in, &x);
 
         // add channel impairments
-        float complex y = x*cexpf(_Complex_I*_phi) +
+        _Fcomplex y = x*cexpf(_Complex_I*_phi) +
             nstd*(randnf() + _Complex_I*randnf())*M_SQRT1_2;
 
         // update phase
@@ -121,5 +121,3 @@ void autotest_ampmodem_lsb_carrier_on () { ampmodem_test_harness(0.8f,LIQUID_AMP
 void autotest_ampmodem_dsb_carrier_off() { ampmodem_test_harness(0.8f,LIQUID_AMPMODEM_DSB,1,0.02,0.0); }
 void autotest_ampmodem_usb_carrier_off() { ampmodem_test_harness(0.8f,LIQUID_AMPMODEM_USB,1,0.00,0.0); }
 void autotest_ampmodem_lsb_carrier_off() { ampmodem_test_harness(0.8f,LIQUID_AMPMODEM_LSB,1,0.00,0.0); }
-
-
diff --git a/src/modem/tests/cpfskmodem_autotest.c b/src/modem/tests/cpfskmodem_autotest.c
index 35414433..d0e2056a 100644
--- a/src/modem/tests/cpfskmodem_autotest.c
+++ b/src/modem/tests/cpfskmodem_autotest.c
@@ -38,12 +38,12 @@ void cpfskmodem_test_mod_demod(unsigned int _bps,
     // derived values
     unsigned int delay = cpfskmod_get_delay(mod) + cpfskdem_get_delay(dem);
     //unsigned int  M = 1 << _m;      // constellation size
-    
+
     unsigned int  num_symbols = 80 + delay; // number of symbols to test
 
     msequence ms = msequence_create_default(7);
 
-    float complex buf[_k];      // sample buffer
+    _Fcomplex buf[_k];      // sample buffer
     unsigned int  sym_in [num_symbols]; // symbol buffer
     unsigned int  sym_out[num_symbols]; // symbol buffer
 
@@ -117,4 +117,3 @@ void autotest_cpfskmodem_bps1_h0p0625_k4_m3_gmsk()      { cpfskmodem_test_mod_de
 void autotest_cpfskmodem_bps2_h0p0250_k4_m3_square()    { cpfskmodem_test_mod_demod( 2, 0.2500f, 4, 3, 0.25f, LIQUID_CPFSK_SQUARE ); }
 void autotest_cpfskmodem_bps3_h0p1250_k4_m3_square()    { cpfskmodem_test_mod_demod( 3, 0.1250f, 4, 3, 0.25f, LIQUID_CPFSK_SQUARE ); }
 void autotest_cpfskmodem_bps4_h0p0625_k4_m3_square()    { cpfskmodem_test_mod_demod( 4, 0.0625f, 4, 3, 0.25f, LIQUID_CPFSK_SQUARE ); }
-
diff --git a/src/modem/tests/freqmodem_autotest.c b/src/modem/tests/freqmodem_autotest.c
index ff7efb06..2df7dd7a 100644
--- a/src/modem/tests/freqmodem_autotest.c
+++ b/src/modem/tests/freqmodem_autotest.c
@@ -39,7 +39,7 @@ void freqmodem_test(float _kf)
 
     // allocate arrays
     float         m[num_samples];       // message signal
-    float complex r[num_samples];       // received signal (complex baseband)
+    _Fcomplex r[num_samples];       // received signal (complex baseband)
     float         y[num_samples];       // demodulator output
 
     // generate message signal (sum of sines)
@@ -68,4 +68,3 @@ void freqmodem_test(float _kf)
 void autotest_freqmodem_kf_0_02() { freqmodem_test(0.02f); }
 void autotest_freqmodem_kf_0_04() { freqmodem_test(0.04f); }
 void autotest_freqmodem_kf_0_08() { freqmodem_test(0.08f); }
-
diff --git a/src/modem/tests/fskmodem_autotest.c b/src/modem/tests/fskmodem_autotest.c
index dabdb4f6..2e210e09 100644
--- a/src/modem/tests/fskmodem_autotest.c
+++ b/src/modem/tests/fskmodem_autotest.c
@@ -36,8 +36,8 @@ void fskmodem_test_mod_demod(unsigned int _m,
     fskdem dem = fskdem_create(_m,_k,_bandwidth);
 
     unsigned int M = 1 << _m;   // constellation size
-    float complex buf[_k];      // transmit buffer
-    
+    _Fcomplex buf[_k];      // transmit buffer
+
     // modulate, demodulate, count errors
     unsigned int i;
     for (i=0; i<M; i++) {
@@ -82,4 +82,3 @@ void autotest_fskmodem_misc_M128()  { fskmodem_test_mod_demod( 7,  200, 0.372145
 void autotest_fskmodem_misc_M256()  { fskmodem_test_mod_demod( 8,  500, 0.3721451); }
 void autotest_fskmodem_misc_M512()  { fskmodem_test_mod_demod( 9, 1000, 0.3721451); }
 void autotest_fskmodem_misc_M1024() { fskmodem_test_mod_demod(10, 2000, 0.3721451); }
-
diff --git a/src/modem/tests/modem_autotest.c b/src/modem/tests/modem_autotest.c
index 9fbbcb0c..f0b5c193 100644
--- a/src/modem/tests/modem_autotest.c
+++ b/src/modem/tests/modem_autotest.c
@@ -32,7 +32,7 @@ void modem_test_mod_demod(modulation_scheme _ms)
 
     // run the test
     unsigned int i, s, M = 1 << modem_get_bps(mod);
-    float complex x;
+    _Fcomplex x;
     float e = 0.0f;
     for (i=0; i<M; i++) {
         modem_modulate(mod, i, &x);
@@ -40,7 +40,7 @@ void modem_test_mod_demod(modulation_scheme _ms)
         CONTEND_EQUALITY(s, i);
 
         CONTEND_DELTA( modem_get_demodulator_phase_error(demod), 0.0f, 1e-3f);
-        
+
         CONTEND_DELTA( modem_get_demodulator_evm(demod), 0.0f, 1e-3f);
 
         e += crealf(x*conjf(x));
@@ -115,4 +115,3 @@ void autotest_mod_demod_arb64opt()  { modem_test_mod_demod(LIQUID_MODEM_ARB64OPT
 void autotest_mod_demod_arb128opt() { modem_test_mod_demod(LIQUID_MODEM_ARB128OPT); }
 void autotest_mod_demod_arb256opt() { modem_test_mod_demod(LIQUID_MODEM_ARB256OPT); }
 void autotest_mod_demod_arb64vt()   { modem_test_mod_demod(LIQUID_MODEM_ARB64VT);   }
-
diff --git a/src/modem/tests/modem_demodsoft_autotest.c b/src/modem/tests/modem_demodsoft_autotest.c
index 928a0a8b..b00a0b29 100644
--- a/src/modem/tests/modem_demodsoft_autotest.c
+++ b/src/modem/tests/modem_demodsoft_autotest.c
@@ -34,15 +34,15 @@ void modem_test_demodsoft(modulation_scheme _ms)
     modem mod   = modem_create(_ms);
     modem demod = modem_create(_ms);
 
-    // 
+    //
     unsigned int bps = modem_get_bps(demod);
 
     // run the test
     unsigned int i, s, M=1<<bps;
     unsigned int sym_soft;
     unsigned char soft_bits[bps];
-    float complex x;
-    
+    _Fcomplex x;
+
     for (i=0; i<M; i++) {
         // modulate symbol
         modem_modulate(mod, i, &x);
@@ -127,4 +127,3 @@ void autotest_demodsoft_arb64opt()  { modem_test_demodsoft(LIQUID_MODEM_ARB64OPT
 void autotest_demodsoft_arb128opt() { modem_test_demodsoft(LIQUID_MODEM_ARB128OPT); }
 void autotest_demodsoft_arb256opt() { modem_test_demodsoft(LIQUID_MODEM_ARB256OPT); }
 void autotest_demodsoft_arb64vt()   { modem_test_demodsoft(LIQUID_MODEM_ARB64VT);   }
-
diff --git a/src/modem/tests/modem_demodstats_autotest.c b/src/modem/tests/modem_demodstats_autotest.c
index bee7abf4..4570e1d1 100644
--- a/src/modem/tests/modem_demodstats_autotest.c
+++ b/src/modem/tests/modem_demodstats_autotest.c
@@ -34,8 +34,8 @@ void modem_test_demodstats(modulation_scheme _ms)
 
     // run the test
     unsigned int i, s, M = 1 << modem_get_bps(mod);
-    float complex x;
-    float complex x_hat;    // rotated symbol
+    _Fcomplex x;
+    _Fcomplex x_hat;    // rotated symbol
     float demodstats;
     float phi = 0.01f;
 
@@ -156,4 +156,3 @@ void autotest_demodstats_arb64opt() { modem_test_demodstats(LIQUID_MODEM_ARB64OP
 void autotest_demodstats_arb128opt(){ modem_test_demodstats(LIQUID_MODEM_ARB128OPT);}
 void autotest_demodstats_arb256opt(){ modem_test_demodstats(LIQUID_MODEM_ARB256OPT);}
 void autotest_demodstats_arb64vt()  { modem_test_demodstats(LIQUID_MODEM_ARB64VT);  }
-
diff --git a/src/multichannel/bench/firpfbch2_crcf_benchmark.c b/src/multichannel/bench/firpfbch2_crcf_benchmark.c
index 28f9f678..c0993b41 100644
--- a/src/multichannel/bench/firpfbch2_crcf_benchmark.c
+++ b/src/multichannel/bench/firpfbch2_crcf_benchmark.c
@@ -43,8 +43,8 @@ void firpfbch2_crcf_execute_bench(struct rusage *     _start,
 
     unsigned long int i;
 
-    float complex x[_num_channels];
-    float complex y[_num_channels];
+    _Fcomplex x[_num_channels];
+    _Fcomplex y[_num_channels];
     for (i=0; i<_num_channels; i++)
         x[i] = 1.0f + _Complex_I*1.0f;
 
@@ -81,5 +81,3 @@ void benchmark_firpfbch2_crcf_s64   FIRPFBCH2_EXECUTE_BENCH_API(64,   2,  LIQUID
 void benchmark_firpfbch2_crcf_s256  FIRPFBCH2_EXECUTE_BENCH_API(256,  2,  LIQUID_SYNTHESIZER)
 void benchmark_firpfbch2_crcf_s512  FIRPFBCH2_EXECUTE_BENCH_API(512,  2,  LIQUID_SYNTHESIZER)
 void benchmark_firpfbch2_crcf_s1024 FIRPFBCH2_EXECUTE_BENCH_API(1024, 2,  LIQUID_SYNTHESIZER)
-
-
diff --git a/src/multichannel/bench/firpfbch_crcf_benchmark.c b/src/multichannel/bench/firpfbch_crcf_benchmark.c
index 6beca208..cd40a21d 100644
--- a/src/multichannel/bench/firpfbch_crcf_benchmark.c
+++ b/src/multichannel/bench/firpfbch_crcf_benchmark.c
@@ -44,8 +44,8 @@ void firpfbch_crcf_execute_bench(
 
     unsigned long int i;
 
-    float complex x[_num_channels];
-    float complex y[_num_channels];
+    _Fcomplex x[_num_channels];
+    _Fcomplex y[_num_channels];
     for (i=0; i<_num_channels; i++)
         x[i] = 1.0f + _Complex_I*1.0f;
 
@@ -83,5 +83,3 @@ void benchmark_firpfbch_crcf_a64     FIRPFBCH_EXECUTE_BENCH_API(64,   2,  LIQUID
 void benchmark_firpfbch_crcf_a256    FIRPFBCH_EXECUTE_BENCH_API(256,  2,  LIQUID_ANALYZER)
 void benchmark_firpfbch_crcf_a512    FIRPFBCH_EXECUTE_BENCH_API(512,  2,  LIQUID_ANALYZER)
 void benchmark_firpfbch_crcf_a1024   FIRPFBCH_EXECUTE_BENCH_API(1024, 2,  LIQUID_ANALYZER)
-
-
diff --git a/src/multichannel/bench/firpfbchr_crcf_benchmark.c b/src/multichannel/bench/firpfbchr_crcf_benchmark.c
index 025973ac..251e1de0 100644
--- a/src/multichannel/bench/firpfbchr_crcf_benchmark.c
+++ b/src/multichannel/bench/firpfbchr_crcf_benchmark.c
@@ -43,8 +43,8 @@ void firpfbchr_crcf_execute_bench(struct rusage *     _start,
 
     unsigned long int i;
 
-    float complex x[_P];
-    float complex y[_M];
+    _Fcomplex x[_P];
+    _Fcomplex y[_M];
     for (i=0; i<_P; i++)
         x[i] = randnf() + _Complex_I*randnf();
 
@@ -74,4 +74,3 @@ void benchmark_firpfbchr_crcf_M0512_P0511  FIRPFBCHR_EXECUTE_BENCH_API( 512,  51
 void benchmark_firpfbchr_crcf_M1024_P1023  FIRPFBCHR_EXECUTE_BENCH_API(1024, 1023, 4)
 void benchmark_firpfbchr_crcf_M2048_P2047  FIRPFBCHR_EXECUTE_BENCH_API(2048, 2047, 4)
 void benchmark_firpfbchr_crcf_M4096_P4095  FIRPFBCHR_EXECUTE_BENCH_API(4096, 4095, 4)
-
diff --git a/src/multichannel/bench/ofdmframesync_acquire_benchmark.c b/src/multichannel/bench/ofdmframesync_acquire_benchmark.c
index 4a0a5794..7e52bbe9 100644
--- a/src/multichannel/bench/ofdmframesync_acquire_benchmark.c
+++ b/src/multichannel/bench/ofdmframesync_acquire_benchmark.c
@@ -56,7 +56,7 @@ void ofdmframesync_acquire_bench(struct rusage *_start,
     ofdmframesync fs = ofdmframesync_create(M,cp_len,taper_len,NULL,NULL,NULL);
 
     unsigned int i;
-    float complex y[num_samples];   // frame samples
+    _Fcomplex y[num_samples];   // frame samples
 
     // assemble full frame
     unsigned int n=0;
@@ -102,4 +102,3 @@ void benchmark_ofdmframesync_acquire_n64    OFDMFRAMESYNC_ACQUIRE_BENCH_API(64,
 void benchmark_ofdmframesync_acquire_n128   OFDMFRAMESYNC_ACQUIRE_BENCH_API(128,16)
 void benchmark_ofdmframesync_acquire_n256   OFDMFRAMESYNC_ACQUIRE_BENCH_API(256,32)
 void benchmark_ofdmframesync_acquire_n512   OFDMFRAMESYNC_ACQUIRE_BENCH_API(512,64)
-
diff --git a/src/multichannel/bench/ofdmframesync_rxsymbol_benchmark.c b/src/multichannel/bench/ofdmframesync_rxsymbol_benchmark.c
index 8e144c64..b70d13ef 100644
--- a/src/multichannel/bench/ofdmframesync_rxsymbol_benchmark.c
+++ b/src/multichannel/bench/ofdmframesync_rxsymbol_benchmark.c
@@ -56,8 +56,8 @@ void ofdmframesync_rxsymbol_bench(struct rusage *_start,
     ofdmframesync fs = ofdmframesync_create(M,cp_len,taper_len,NULL,NULL,NULL);
 
     unsigned int i;
-    float complex X[M];         // channelized symbol
-    float complex x[M+cp_len];  // time-domain symbol
+    _Fcomplex X[M];         // channelized symbol
+    _Fcomplex x[M+cp_len];  // time-domain symbol
 
     // synchronize short sequence (first)
     ofdmframegen_write_S0a(fg, x);
@@ -110,4 +110,3 @@ void benchmark_ofdmframesync_rxsymbol_n64   OFDMFRAMESYNC_RXSYMBOL_BENCH_API(64,
 void benchmark_ofdmframesync_rxsymbol_n128  OFDMFRAMESYNC_RXSYMBOL_BENCH_API(128,16)
 void benchmark_ofdmframesync_rxsymbol_n256  OFDMFRAMESYNC_RXSYMBOL_BENCH_API(256,32)
 void benchmark_ofdmframesync_rxsymbol_n512  OFDMFRAMESYNC_RXSYMBOL_BENCH_API(512,64)
-
diff --git a/src/multichannel/src/firpfbch_cccf.c b/src/multichannel/src/firpfbch_cccf.c
index d0f18aec..81dcff07 100644
--- a/src/multichannel/src/firpfbch_cccf.c
+++ b/src/multichannel/src/firpfbch_cccf.c
@@ -30,13 +30,13 @@
 #define EXTENSION_SHORT     "f"
 #define EXTENSION_FULL      "cccf"
 
-// 
+//
 #define FIRPFBCH(name)      LIQUID_CONCAT(firpfbch_cccf,name)
 
-#define T                   float complex   // general
-#define TO                  float complex   // output
-#define TC                  float complex   // coefficients
-#define TI                  float complex   // input
+#define T                   _Fcomplex   // general
+#define TO                  _Fcomplex   // output
+#define TC                  _Fcomplex   // coefficients
+#define TI                  _Fcomplex   // input
 #define WINDOW(name)        LIQUID_CONCAT(windowcf,name)
 #define DOTPROD(name)       LIQUID_CONCAT(dotprod_cccf,name)
 
@@ -50,4 +50,3 @@
 
 // source files
 #include "firpfbch.c"
-
diff --git a/src/multichannel/src/firpfbch_crcf.c b/src/multichannel/src/firpfbch_crcf.c
index 1b15cb8e..512fd35a 100644
--- a/src/multichannel/src/firpfbch_crcf.c
+++ b/src/multichannel/src/firpfbch_crcf.c
@@ -30,15 +30,15 @@
 #define EXTENSION_SHORT     "f"
 #define EXTENSION_FULL      "crcf"
 
-// 
+//
 #define FIRPFBCH(name)      LIQUID_CONCAT(firpfbch_crcf,name)
 #define FIRPFBCH2(name)     LIQUID_CONCAT(firpfbch2_crcf,name)
 #define FIRPFBCHR(name)     LIQUID_CONCAT(firpfbchr_crcf,name)
 
-#define T                   float complex   // general
-#define TO                  float complex   // output
+#define T                   _Fcomplex   // general
+#define TO                  _Fcomplex   // output
 #define TC                  float           // coefficients
-#define TI                  float complex   // input
+#define TI                  _Fcomplex   // input
 #define WINDOW(name)        LIQUID_CONCAT(windowcf,name)
 #define DOTPROD(name)       LIQUID_CONCAT(dotprod_crcf,name)
 
@@ -54,4 +54,3 @@
 #include "firpfbch.c"       // maximally-decimated polyphase filterbank
 #include "firpfbch2.c"      // polyphase filterbank w/ output rate 2 Fs / M
 #include "firpfbchr.c"      // polyphase filterbank w/ output rate P Fs / M
-
diff --git a/src/multichannel/src/firpfbch_old.c b/src/multichannel/src/firpfbch_old.c
index c62326e8..a975471f 100644
--- a/src/multichannel/src/firpfbch_old.c
+++ b/src/multichannel/src/firpfbch_old.c
@@ -41,18 +41,18 @@ struct firpfbch_s {
     unsigned int m;
     float beta;
     float dt;
-    float complex * x;  // time-domain buffer
-    float complex * X;  // freq-domain buffer
+    _Fcomplex * x;  // time-domain buffer
+    _Fcomplex * X;  // freq-domain buffer
 
     // run|state buffers
-    float complex * X_prime;    // freq-domain buffer (analysis
+    _Fcomplex * X_prime;    // freq-domain buffer (analysis
                                 // filter bank)
 
     // filter
     unsigned int h_len;
     float * h;
     unsigned int filter_index;
-    
+
     // create separate bank of dotprod and window objects
     DOTPROD() * dp;
     WINDOW() * w;
@@ -102,7 +102,7 @@ firpfbch firpfbch_create(unsigned int _num_channels,
         printf("error: firpfbch_create(), unsupported nyquist flag: %d\n", _nyquist);
         exit(1);
     }
-    
+
     unsigned int i;
     if (_gradient) {
         float dh[c->h_len];
@@ -146,9 +146,9 @@ firpfbch firpfbch_create(unsigned int _num_channels,
 
     // allocate memory for buffers
     // TODO : use fftw_malloc if HAVE_FFTW3_H
-    c->x = (float complex*) malloc((c->num_channels)*sizeof(float complex));
-    c->X = (float complex*) malloc((c->num_channels)*sizeof(float complex));
-    c->X_prime = (float complex*) malloc((c->num_channels)*sizeof(float complex));
+    c->x = (_Fcomplex*) malloc((c->num_channels)*sizeof(_Fcomplex));
+    c->X = (_Fcomplex*) malloc((c->num_channels)*sizeof(_Fcomplex));
+    c->X_prime = (_Fcomplex*) malloc((c->num_channels)*sizeof(_Fcomplex));
     firpfbch_clear(c);
 
     // create fft plan
@@ -196,29 +196,29 @@ void firpfbch_print(firpfbch _c)
     }
 }
 
-void firpfbch_get_filter_taps(firpfbch _c, 
+void firpfbch_get_filter_taps(firpfbch _c,
                               float * _h)
 {
     memmove(_h, _c->h, (_c->h_len)*sizeof(float));
 }
 
-// 
+//
 // SYNTHESIZER
 //
 
-void firpfbch_synthesizer_execute(firpfbch _c, float complex * _x, float complex * _y)
+void firpfbch_synthesizer_execute(firpfbch _c, _Fcomplex * _x, _Fcomplex * _y)
 {
     unsigned int i;
 
     // copy samples into ifft input buffer _c->X
-    memmove(_c->X, _x, (_c->num_channels)*sizeof(float complex));
+    memmove(_c->X, _x, (_c->num_channels)*sizeof(_Fcomplex));
 
     // execute inverse fft, store in buffer _c->x
     FFT_EXECUTE(_c->fft);
 
     // push samples into filter bank and execute, putting
     // samples into output buffer _y
-    float complex * r;
+    _Fcomplex * r;
     for (i=0; i<_c->num_channels; i++) {
         WINDOW(_push)(_c->w[i], _c->x[i]);
         WINDOW(_read)(_c->w[i], &r);
@@ -229,11 +229,11 @@ void firpfbch_synthesizer_execute(firpfbch _c, float complex * _x, float complex
     }
 }
 
-// 
+//
 // ANALYZER
 //
 
-void firpfbch_analyzer_execute(firpfbch _c, float complex * _x, float complex * _y)
+void firpfbch_analyzer_execute(firpfbch _c, _Fcomplex * _x, _Fcomplex * _y)
 {
     unsigned int i;
     for (i=0; i<_c->num_channels; i++)
@@ -246,7 +246,7 @@ void firpfbch_analyzer_execute(firpfbch _c, float complex * _x, float complex *
     firpfbch_analyzer_saverunstate(_c);
 }
 
-void firpfbch_analyzer_push(firpfbch _c, float complex _x)
+void firpfbch_analyzer_push(firpfbch _c, _Fcomplex _x)
 {
     // push sample into the buffer at filter_index
     WINDOW(_push)(_c->w[_c->filter_index], _x);
@@ -255,7 +255,7 @@ void firpfbch_analyzer_push(firpfbch _c, float complex _x)
     _c->filter_index = (_c->filter_index+_c->num_channels-1) % _c->num_channels;
 }
 
-void firpfbch_analyzer_run(firpfbch _c, float complex * _y)
+void firpfbch_analyzer_run(firpfbch _c, _Fcomplex * _y)
 {
     // NOTE: The analyzer is different from the synthesizer in
     //       that the invocation of the commutator results in a
@@ -265,13 +265,13 @@ void firpfbch_analyzer_run(firpfbch _c, float complex * _y)
     //       the remaining filters are executed.
 
     // restore saved IDFT input state X from X_prime
-    memmove(_c->X, _c->X_prime, (_c->num_channels)*sizeof(float complex));
+    memmove(_c->X, _c->X_prime, (_c->num_channels)*sizeof(_Fcomplex));
 
     unsigned int i, b;
     unsigned int k = _c->filter_index;
 
     // push first value and compute output
-    float complex * r;
+    _Fcomplex * r;
     WINDOW(_read)(_c->w[k], &r);
     DOTPROD(_execute)(_c->dp[0], r, &(_c->X[0]));
 
@@ -279,7 +279,7 @@ void firpfbch_analyzer_run(firpfbch _c, float complex * _y)
     FFT_EXECUTE(_c->fft);
 
     // copy results to output buffer
-    memmove(_y, _c->x, (_c->num_channels)*sizeof(float complex));
+    memmove(_y, _c->x, (_c->num_channels)*sizeof(_Fcomplex));
 
     // push remaining samples into filter bank and execute in
     // *reverse* order, putting result into the inverse DFT
@@ -301,7 +301,7 @@ void firpfbch_analyzer_run(firpfbch _c, float complex * _y)
 // IDFT input buffer X into the temporary buffer X_prime
 void firpfbch_analyzer_saverunstate(firpfbch _c)
 {
-    memmove(_c->X_prime, _c->X, (_c->num_channels)*sizeof(float complex));
+    memmove(_c->X_prime, _c->X, (_c->num_channels)*sizeof(_Fcomplex));
 }
 
 // clear the run state of the filter bank
diff --git a/src/multichannel/src/ofdmframe.common.c b/src/multichannel/src/ofdmframe.common.c
index e656362f..8db9fa60 100644
--- a/src/multichannel/src/ofdmframe.common.c
+++ b/src/multichannel/src/ofdmframe.common.c
@@ -40,8 +40,8 @@
 //  _M_S0   :   total number of enabled subcarriers in S0
 void ofdmframe_init_S0(unsigned char * _p,
                        unsigned int    _M,
-                       float complex * _S0,
-                       float complex * _s0,
+                       _Fcomplex * _S0,
+                       _Fcomplex * _s0,
                        unsigned int *  _M_S0)
 {
     unsigned int i;
@@ -108,8 +108,8 @@ void ofdmframe_init_S0(unsigned char * _p,
 //  _M_S1   :   total number of enabled subcarriers in S1
 void ofdmframe_init_S1(unsigned char * _p,
                        unsigned int    _M,
-                       float complex * _S1,
-                       float complex * _s1,
+                       _Fcomplex * _S1,
+                       _Fcomplex * _s1,
                        unsigned int *  _M_S1)
 {
     unsigned int i;
@@ -333,4 +333,3 @@ void ofdmframe_print_sctype(unsigned char * _p,
 
     printf("]\n");
 }
-
diff --git a/src/multichannel/src/ofdmframegen.c b/src/multichannel/src/ofdmframegen.c
index db2d99c6..36ff79db 100644
--- a/src/multichannel/src/ofdmframegen.c
+++ b/src/multichannel/src/ofdmframegen.c
@@ -48,7 +48,7 @@ struct ofdmframegen_s {
     // tapering/trasition
     unsigned int taper_len; // number of samples in tapering window/overlap
     float * taper;          // tapering window
-    float complex *postfix; // overlapping symbol buffer
+    _Fcomplex *postfix; // overlapping symbol buffer
 
     // constants
     unsigned int M_null;    // number of null subcarriers
@@ -62,16 +62,16 @@ struct ofdmframegen_s {
 
     // transform object
     FFT_PLAN ifft;          // ifft object
-    float complex * X;      // frequency-domain buffer
-    float complex * x;      // time-domain buffer
+    _Fcomplex * X;      // frequency-domain buffer
+    _Fcomplex * x;      // time-domain buffer
 
     // PLCP short
-    float complex * S0;     // short sequence (frequency)
-    float complex * s0;     // short sequence (time)
+    _Fcomplex * S0;     // short sequence (frequency)
+    _Fcomplex * s0;     // short sequence (time)
 
     // PLCP long
-    float complex * S1;     // long sequence (frequency)
-    float complex * s1;     // long sequence (time)
+    _Fcomplex * S1;     // long sequence (frequency)
+    _Fcomplex * s1;     // long sequence (time)
 
     // pilot sequence
     msequence ms_pilot;
@@ -133,21 +133,21 @@ ofdmframegen ofdmframegen_create(unsigned int    _M,
     unsigned int i;
 
     // allocate memory for transform objects
-    q->X = (float complex*) malloc((q->M)*sizeof(float complex));
-    q->x = (float complex*) malloc((q->M)*sizeof(float complex));
+    q->X = (_Fcomplex*) malloc((q->M)*sizeof(_Fcomplex));
+    q->x = (_Fcomplex*) malloc((q->M)*sizeof(_Fcomplex));
     q->ifft = FFT_CREATE_PLAN(q->M, q->X, q->x, FFT_DIR_BACKWARD, FFT_METHOD);
 
     // allocate memory for PLCP arrays
-    q->S0 = (float complex*) malloc((q->M)*sizeof(float complex));
-    q->s0 = (float complex*) malloc((q->M)*sizeof(float complex));
-    q->S1 = (float complex*) malloc((q->M)*sizeof(float complex));
-    q->s1 = (float complex*) malloc((q->M)*sizeof(float complex));
+    q->S0 = (_Fcomplex*) malloc((q->M)*sizeof(_Fcomplex));
+    q->s0 = (_Fcomplex*) malloc((q->M)*sizeof(_Fcomplex));
+    q->S1 = (_Fcomplex*) malloc((q->M)*sizeof(_Fcomplex));
+    q->s1 = (_Fcomplex*) malloc((q->M)*sizeof(_Fcomplex));
     ofdmframe_init_S0(q->p, q->M, q->S0, q->s0, &q->M_S0);
     ofdmframe_init_S1(q->p, q->M, q->S1, q->s1, &q->M_S1);
 
     // create tapering window and transition buffer
     q->taper   = (float*)         malloc(q->taper_len * sizeof(float));
-    q->postfix = (float complex*) malloc(q->taper_len * sizeof(float complex));
+    q->postfix = (_Fcomplex*) malloc(q->taper_len * sizeof(_Fcomplex));
     for (i=0; i<q->taper_len; i++) {
         float t = ((float)i + 0.5f) / (float)(q->taper_len);
         float g = sinf(M_PI_2*t);
@@ -235,7 +235,7 @@ void ofdmframegen_reset(ofdmframegen _q)
 //  |        M + cp_len      |        M + cp_len      |
 //
 void ofdmframegen_write_S0a(ofdmframegen    _q,
-                            float complex * _y)
+                            _Fcomplex * _y)
 {
     unsigned int i;
     unsigned int k;
@@ -250,7 +250,7 @@ void ofdmframegen_write_S0a(ofdmframegen    _q,
 }
 
 void ofdmframegen_write_S0b(ofdmframegen _q,
-                            float complex * _y)
+                            _Fcomplex * _y)
 {
     unsigned int i;
     unsigned int k;
@@ -260,14 +260,14 @@ void ofdmframegen_write_S0b(ofdmframegen _q,
     }
 
     // copy postfix (first 'taper_len' samples of s0 symbol)
-    memmove(_q->postfix, _q->s0, _q->taper_len*sizeof(float complex));
+    memmove(_q->postfix, _q->s0, _q->taper_len*sizeof(_Fcomplex));
 }
 
 void ofdmframegen_write_S1(ofdmframegen _q,
-                           float complex * _y)
+                           _Fcomplex * _y)
 {
     // copy S1 symbol to output, adding cyclic prefix and tapering window
-    memmove(_q->x, _q->s1, (_q->M)*sizeof(float complex));
+    memmove(_q->x, _q->s1, (_q->M)*sizeof(_Fcomplex));
     ofdmframegen_gensymbol(_q, _y);
 }
 
@@ -277,8 +277,8 @@ void ofdmframegen_write_S1(ofdmframegen _q,
 //  _x      :   input symbols, [size: _M x 1]
 //  _y      :   output samples, [size: _M x 1]
 void ofdmframegen_writesymbol(ofdmframegen    _q,
-                              float complex * _x,
-                              float complex * _y)
+                              _Fcomplex * _x,
+                              _Fcomplex * _y)
 {
     // move frequency data to internal buffer
     unsigned int i;
@@ -312,7 +312,7 @@ void ofdmframegen_writesymbol(ofdmframegen    _q,
 
 // write tail to output
 void ofdmframegen_writetail(ofdmframegen    _q,
-                            float complex * _buffer)
+                            _Fcomplex * _buffer)
 {
     // write tail to output, applying tapering window
     unsigned int i;
@@ -320,7 +320,7 @@ void ofdmframegen_writetail(ofdmframegen    _q,
         _buffer[i] = _q->postfix[i] * _q->taper[_q->taper_len-i-1];
 }
 
-// 
+//
 // internal methods
 //
 
@@ -343,12 +343,12 @@ void ofdmframegen_writetail(ofdmframegen    _q,
 //
 //  _buffer         :   output sample buffer [size: (_q->M + _q->cp_len) x 1]
 void ofdmframegen_gensymbol(ofdmframegen    _q,
-                            float complex * _buffer)
+                            _Fcomplex * _buffer)
 {
     // copy input symbol with cyclic prefix to output symbol
-    memmove( &_buffer[0],          &_q->x[_q->M-_q->cp_len], _q->cp_len*sizeof(float complex));
-    memmove( &_buffer[_q->cp_len], &_q->x[               0], _q->M    * sizeof(float complex));
-    
+    memmove( &_buffer[0],          &_q->x[_q->M-_q->cp_len], _q->cp_len*sizeof(_Fcomplex));
+    memmove( &_buffer[_q->cp_len], &_q->x[               0], _q->M    * sizeof(_Fcomplex));
+
     // apply tapering window to over-lapping regions
     unsigned int i;
     for (i=0; i<_q->taper_len; i++) {
@@ -357,6 +357,5 @@ void ofdmframegen_gensymbol(ofdmframegen    _q,
     }
 
     // copy post-fix to output (first 'taper_len' samples of input symbol)
-    memmove(_q->postfix, _q->x, _q->taper_len*sizeof(float complex));
+    memmove(_q->postfix, _q->x, _q->taper_len*sizeof(_Fcomplex));
 }
-
diff --git a/src/multichannel/src/ofdmframesync.c b/src/multichannel/src/ofdmframesync.c
index 1e67c80d..5f72fdd4 100644
--- a/src/multichannel/src/ofdmframesync.c
+++ b/src/multichannel/src/ofdmframesync.c
@@ -61,24 +61,24 @@ struct ofdmframesync_s {
 
     // transform object
     FFT_PLAN fft;           // ifft object
-    float complex * X;      // frequency-domain buffer
-    float complex * x;      // time-domain buffer
+    _Fcomplex * X;      // frequency-domain buffer
+    _Fcomplex * x;      // time-domain buffer
     windowcf input_buffer;  // input sequence buffer
 
     // PLCP sequences
-    float complex * S0;     // short sequence (freq)
-    float complex * s0;     // short sequence (time)
-    float complex * S1;     // long sequence (freq)
-    float complex * s1;     // long sequence (time)
+    _Fcomplex * S0;     // short sequence (freq)
+    _Fcomplex * s0;     // short sequence (time)
+    _Fcomplex * S1;     // long sequence (freq)
+    _Fcomplex * s1;     // long sequence (time)
 
     // gain
     float g0;               // nominal gain (coarse initial estimate)
-    float complex * G0a;    // complex subcarrier gain estimate, S0[a]
-    float complex * G0b;    // complex subcarrier gain estimate, S0[b]
-    float complex * G1;     // complex subcarrier gain estimate, S1
-    float complex * G;      // complex subcarrier gain estimate
-    float complex * B;      // subcarrier phase rotation due to backoff
-    float complex * R;      // 
+    _Fcomplex * G0a;    // complex subcarrier gain estimate, S0[a]
+    _Fcomplex * G0b;    // complex subcarrier gain estimate, S0[b]
+    _Fcomplex * G1;     // complex subcarrier gain estimate, S1
+    _Fcomplex * G;      // complex subcarrier gain estimate
+    _Fcomplex * B;      // subcarrier phase rotation due to backoff
+    _Fcomplex * R;      //
 
     // receiver state
     enum {
@@ -105,8 +105,8 @@ struct ofdmframesync_s {
     unsigned int timer;         // input sample timer
     unsigned int num_symbols;   // symbol counter
     unsigned int backoff;       // sample timing backoff
-    float complex s_hat_0;      // first S0 symbol metrics estimate
-    float complex s_hat_1;      // second S0 symbol metrics estimate
+    _Fcomplex s_hat_0;      // first S0 symbol metrics estimate
+    _Fcomplex s_hat_1;      // second S0 symbol metrics estimate
 
     // detection thresholds
     float plcp_detect_thresh;   // plcp detection threshold, nominally 0.35
@@ -122,7 +122,7 @@ struct ofdmframesync_s {
     windowcf debug_x;
     windowf  debug_rssi;
     windowcf debug_framesyms;
-    float complex * G_hat;  // complex subcarrier gain estimate, S1
+    _Fcomplex * G_hat;  // complex subcarrier gain estimate, S1
     float * px;             // pilot x-value
     float * py;             // pilot y-value
     float p_phase[2];       // pilot polyfit
@@ -185,18 +185,18 @@ ofdmframesync ofdmframesync_create(unsigned int           _M,
     }
 
     // create transform object
-    q->X = (float complex*) malloc((q->M)*sizeof(float complex));
-    q->x = (float complex*) malloc((q->M)*sizeof(float complex));
+    q->X = (_Fcomplex*) malloc((q->M)*sizeof(_Fcomplex));
+    q->x = (_Fcomplex*) malloc((q->M)*sizeof(_Fcomplex));
     q->fft = FFT_CREATE_PLAN(q->M, q->x, q->X, FFT_DIR_FORWARD, FFT_METHOD);
- 
+
     // create input buffer the length of the transform
     q->input_buffer = windowcf_create(q->M + q->cp_len);
 
     // allocate memory for PLCP arrays
-    q->S0 = (float complex*) malloc((q->M)*sizeof(float complex));
-    q->s0 = (float complex*) malloc((q->M)*sizeof(float complex));
-    q->S1 = (float complex*) malloc((q->M)*sizeof(float complex));
-    q->s1 = (float complex*) malloc((q->M)*sizeof(float complex));
+    q->S0 = (_Fcomplex*) malloc((q->M)*sizeof(_Fcomplex));
+    q->s0 = (_Fcomplex*) malloc((q->M)*sizeof(_Fcomplex));
+    q->S1 = (_Fcomplex*) malloc((q->M)*sizeof(_Fcomplex));
+    q->s1 = (_Fcomplex*) malloc((q->M)*sizeof(_Fcomplex));
     ofdmframe_init_S0(q->p, q->M, q->S0, q->s0, &q->M_S0);
     ofdmframe_init_S1(q->p, q->M, q->S1, q->s1, &q->M_S1);
 
@@ -207,17 +207,17 @@ ofdmframesync ofdmframesync_create(unsigned int           _M,
 
     // gain
     q->g0 = 1.0f;
-    q->G0a = (float complex*) malloc((q->M)*sizeof(float complex));
-    q->G0b = (float complex*) malloc((q->M)*sizeof(float complex));
-    q->G   = (float complex*) malloc((q->M)*sizeof(float complex));
-    q->B   = (float complex*) malloc((q->M)*sizeof(float complex));
-    q->R   = (float complex*) malloc((q->M)*sizeof(float complex));
+    q->G0a = (_Fcomplex*) malloc((q->M)*sizeof(_Fcomplex));
+    q->G0b = (_Fcomplex*) malloc((q->M)*sizeof(_Fcomplex));
+    q->G   = (_Fcomplex*) malloc((q->M)*sizeof(_Fcomplex));
+    q->B   = (_Fcomplex*) malloc((q->M)*sizeof(_Fcomplex));
+    q->R   = (_Fcomplex*) malloc((q->M)*sizeof(_Fcomplex));
 
 #if 1
-    memset(q->G0a, 0x00, q->M*sizeof(float complex));
-    memset(q->G0b, 0x00, q->M*sizeof(float complex));
-    memset(q->G ,  0x00, q->M*sizeof(float complex));
-    memset(q->B,   0x00, q->M*sizeof(float complex));
+    memset(q->G0a, 0x00, q->M*sizeof(_Fcomplex));
+    memset(q->G0b, 0x00, q->M*sizeof(_Fcomplex));
+    memset(q->G ,  0x00, q->M*sizeof(_Fcomplex));
+    memset(q->B,   0x00, q->M*sizeof(_Fcomplex));
 #endif
 
     // timing backoff
@@ -231,7 +231,7 @@ ofdmframesync ofdmframesync_create(unsigned int           _M,
     q->callback = _callback;
     q->userdata = _userdata;
 
-    // 
+    //
     // synchronizer objects
     //
 
@@ -257,11 +257,11 @@ ofdmframesync ofdmframesync_create(unsigned int           _M,
     q->debug_x =        NULL;
     q->debug_rssi =     NULL;
     q->debug_framesyms =NULL;
-    
+
     q->G_hat = NULL;
     q->px    = NULL;
     q->py    = NULL;
-    
+
     q->debug_pilot_0 = NULL;
     q->debug_pilot_1 = NULL;
 #endif
@@ -357,11 +357,11 @@ int ofdmframesync_is_frame_open(ofdmframesync _q)
 }
 
 void ofdmframesync_execute(ofdmframesync _q,
-                           float complex * _x,
+                           _Fcomplex * _x,
                            unsigned int _n)
 {
     unsigned int i;
-    float complex x;
+    _Fcomplex x;
     for (i=0; i<_n; i++) {
         x = _x[i];
 
@@ -437,7 +437,7 @@ void ofdmframesync_execute_seekplcp(ofdmframesync _q)
     _q->timer = 0;
 
     //
-    float complex * rc;
+    _Fcomplex * rc;
     windowcf_read(_q->input_buffer, &rc);
 
     // estimate gain
@@ -462,7 +462,7 @@ void ofdmframesync_execute_seekplcp(ofdmframesync _q)
     // estimate S0 gain
     ofdmframesync_estimate_gain_S0(_q, &rc[_q->cp_len], _q->G0a);
 
-    float complex s_hat;
+    _Fcomplex s_hat;
     ofdmframesync_S0_metrics(_q, _q->G0a, &s_hat);
     s_hat *= g;
 
@@ -478,7 +478,7 @@ void ofdmframesync_execute_seekplcp(ofdmframesync _q)
     // save gain (permits dynamic invocation of get_rssi() method)
     _q->g0 = g;
 
-    // 
+    //
     if (cabsf(s_hat) > _q->plcp_detect_thresh) {
 
         int dt = (int)roundf(tau_hat);
@@ -514,7 +514,7 @@ void ofdmframesync_execute_S0a(ofdmframesync _q)
     _q->timer = 0;
 
     //
-    float complex * rc;
+    _Fcomplex * rc;
     windowcf_read(_q->input_buffer, &rc);
 
     // TODO : re-estimate nominal gain
@@ -522,7 +522,7 @@ void ofdmframesync_execute_S0a(ofdmframesync _q)
     // estimate S0 gain
     ofdmframesync_estimate_gain_S0(_q, &rc[_q->cp_len], _q->G0a);
 
-    float complex s_hat;
+    _Fcomplex s_hat;
     ofdmframesync_S0_metrics(_q, _q->G0a, &s_hat);
     s_hat *= _q->g0;
 
@@ -562,13 +562,13 @@ void ofdmframesync_execute_S0b(ofdmframesync _q)
     _q->timer = _q->M + _q->cp_len - _q->backoff;
 
     //
-    float complex * rc;
+    _Fcomplex * rc;
     windowcf_read(_q->input_buffer, &rc);
 
     // estimate S0 gain
     ofdmframesync_estimate_gain_S0(_q, &rc[_q->cp_len], _q->G0b);
 
-    float complex s_hat;
+    _Fcomplex s_hat;
     ofdmframesync_S0_metrics(_q, _q->G0b, &s_hat);
     s_hat *= _q->g0;
 
@@ -602,7 +602,7 @@ void ofdmframesync_execute_S0b(ofdmframesync _q)
     }
 #endif
 
-    float complex g_hat = 0.0f;
+    _Fcomplex g_hat = 0.0f;
     unsigned int i;
     for (i=0; i<_q->M; i++)
         g_hat += _q->G0b[i] * conjf(_q->G0a[i]);
@@ -612,9 +612,9 @@ void ofdmframesync_execute_S0b(ofdmframesync _q)
     float nu_hat = 2.0f * cargf(g_hat) / (float)(_q->M);
 #else
     // compute carrier frequency offset estimate using ML method
-    float complex t0 = 0.0f;
+    _Fcomplex t0 = 0.0f;
     for (i=0; i<_q->M2; i++) {
-        t0 += conjf(rc[i])       *       _q->s0[i] * 
+        t0 += conjf(rc[i])       *       _q->s0[i] *
                     rc[i+_q->M2] * conjf(_q->s0[i+_q->M2]);
     }
     float nu_hat = cargf(t0) / (float)(_q->M2);
@@ -641,7 +641,7 @@ void ofdmframesync_execute_S1(ofdmframesync _q)
     _q->num_symbols++;
 
     // run fft
-    float complex * rc;
+    _Fcomplex * rc;
     windowcf_read(_q->input_buffer, &rc);
 
     // estimate S1 gain
@@ -649,7 +649,7 @@ void ofdmframesync_execute_S1(ofdmframesync _q)
     ofdmframesync_estimate_gain_S1(_q, &rc[_q->cp_len], _q->G);
 
     // compute detector output
-    float complex g_hat = 0.0f;
+    _Fcomplex g_hat = 0.0f;
     unsigned int i;
     for (i=0; i<_q->M; i++) {
         //g_hat += _q->G[(i+1+_q->M)%_q->M]*conjf(_q->G[(i+_q->M)%_q->M]);
@@ -730,9 +730,9 @@ void ofdmframesync_execute_rxsymbols(ofdmframesync _q)
     if (_q->timer == 0) {
 
         // run fft
-        float complex * rc;
+        _Fcomplex * rc;
         windowcf_read(_q->input_buffer, &rc);
-        memmove(_q->x, &rc[_q->cp_len-_q->backoff], (_q->M)*sizeof(float complex));
+        memmove(_q->x, &rc[_q->cp_len-_q->backoff], (_q->M)*sizeof(_Fcomplex));
         FFT_EXECUTE(_q->fft);
 
         // recover symbol in internal _q->X buffer
@@ -763,12 +763,12 @@ void ofdmframesync_execute_rxsymbols(ofdmframesync _q)
 
 // compute S0 metrics
 void ofdmframesync_S0_metrics(ofdmframesync _q,
-                              float complex * _G,
-                              float complex * _s_hat)
+                              _Fcomplex * _G,
+                              _Fcomplex * _s_hat)
 {
     // timing, carrier offset correction
     unsigned int i;
-    float complex s_hat = 0.0f;
+    _Fcomplex s_hat = 0.0f;
 
     // compute timing estimate, accumulate phase difference across
     // gains on subsequent pilot subcarriers (note that all the odd
@@ -787,15 +787,15 @@ void ofdmframesync_S0_metrics(ofdmframesync _q,
 //  _x      :   input array (time), [size: M x 1]
 //  _G      :   output gain (freq)
 void ofdmframesync_estimate_gain_S0(ofdmframesync   _q,
-                                    float complex * _x,
-                                    float complex * _G)
+                                    _Fcomplex * _x,
+                                    _Fcomplex * _G)
 {
     // move input array into fft input buffer
-    memmove(_q->x, _x, (_q->M)*sizeof(float complex));
+    memmove(_q->x, _x, (_q->M)*sizeof(_Fcomplex));
 
     // compute fft, storing result into _q->X
     FFT_EXECUTE(_q->fft);
-    
+
     // compute gain, ignoring NULL subcarriers
     unsigned int i;
     float gain = sqrtf(_q->M_S0) / (float)(_q->M);
@@ -820,15 +820,15 @@ void ofdmframesync_estimate_gain_S0(ofdmframesync   _q,
 //  _x      :   input array (time), [size: M x 1]
 //  _G      :   output gain (freq)
 void ofdmframesync_estimate_gain_S1(ofdmframesync _q,
-                                    float complex * _x,
-                                    float complex * _G)
+                                    _Fcomplex * _x,
+                                    _Fcomplex * _G)
 {
     // move input array into fft input buffer
-    memmove(_q->x, _x, (_q->M)*sizeof(float complex));
+    memmove(_q->x, _x, (_q->M)*sizeof(_Fcomplex));
 
     // compute fft, storing result into _q->X
     FFT_EXECUTE(_q->fft);
-    
+
     // compute gain, ignoring NULL subcarriers
     unsigned int i;
     float gain = sqrtf(_q->M_S1) / (float)(_q->M);
@@ -844,7 +844,7 @@ void ofdmframesync_estimate_gain_S1(ofdmframesync _q,
 
         // normalize gain
         _G[i] *= gain;
-    }   
+    }
 }
 
 // estimate complex equalizer gain from G0 and G1
@@ -856,7 +856,7 @@ void ofdmframesync_estimate_eqgain(ofdmframesync _q,
 #if DEBUG_OFDMFRAMESYNC
     if (_q->debug_enabled) {
         // copy pre-smoothed gain
-        memmove(_q->G_hat, _q->G, _q->M*sizeof(float complex));
+        memmove(_q->G_hat, _q->G, _q->M*sizeof(_Fcomplex));
     }
 #endif
 
@@ -873,7 +873,7 @@ void ofdmframesync_estimate_eqgain(ofdmframesync _q,
         _q->x[i] = (i < _ntaps) ? 1.0f : 0.0f;
     FFT_EXECUTE(_q->fft);
 
-    memmove(_q->G0a, _q->G, _q->M*sizeof(float complex));
+    memmove(_q->G0a, _q->G, _q->M*sizeof(_Fcomplex));
 
     // smooth complex equalizer gains
     for (i=0; i<_q->M; i++) {
@@ -883,9 +883,9 @@ void ofdmframesync_estimate_eqgain(ofdmframesync _q,
             continue;
         }
 
-        float complex w;
-        float complex w0 = 0.0f;
-        float complex G_hat = 0.0f;
+        _Fcomplex w;
+        _Fcomplex w0 = 0.0f;
+        _Fcomplex G_hat = 0.0f;
 
         unsigned int j;
         for (j=0; j<_q->M; j++) {
@@ -918,7 +918,7 @@ void ofdmframesync_estimate_eqgain_poly(ofdmframesync _q,
 #if DEBUG_OFDMFRAMESYNC
     if (_q->debug_enabled) {
         // copy pre-smoothed gain
-        memmove(_q->G_hat, _q->G, _q->M*sizeof(float complex));
+        memmove(_q->G_hat, _q->G, _q->M*sizeof(_Fcomplex));
     }
 #endif
 
@@ -1011,7 +1011,7 @@ void ofdmframesync_rxsymbol(ofdmframesync _q)
 
     unsigned int n=0;
     unsigned int k;
-    float complex pilot = 1.0f;
+    _Fcomplex pilot = 1.0f;
     for (i=0; i<_q->M; i++) {
 
         // start at mid-point (effective fftshift)
@@ -1101,7 +1101,7 @@ void ofdmframesync_rxsymbol(ofdmframesync _q)
     // set internal phase state
     _q->phi_prime = p_phase[0];
     //printf("%3u : theta : %12.8f, nco freq: %12.8f\n", _q->num_symbols, p_phase[0], nco_crcf_get_frequency(_q->nco_rx));
-    
+
     // increment symbol counter
     _q->num_symbols++;
 
@@ -1123,7 +1123,7 @@ void ofdmframesync_debug_enable(ofdmframesync _q)
     _q->debug_x         = windowcf_create(DEBUG_OFDMFRAMESYNC_BUFFER_LEN);
     _q->debug_rssi      = windowf_create(DEBUG_OFDMFRAMESYNC_BUFFER_LEN);
     _q->debug_framesyms = windowcf_create(DEBUG_OFDMFRAMESYNC_BUFFER_LEN);
-    _q->G_hat           = (float complex*) malloc((_q->M)*sizeof(float complex));
+    _q->G_hat           = (_Fcomplex*) malloc((_q->M)*sizeof(_Fcomplex));
 
     _q->px = (float*) malloc((_q->M_pilot)*sizeof(float));
     _q->py = (float*) malloc((_q->M_pilot)*sizeof(float));
@@ -1171,7 +1171,7 @@ void ofdmframesync_debug_print(ofdmframesync _q,
     fprintf(fid,"M_pilot = %u;\n", _q->M_pilot);
     fprintf(fid,"M_data  = %u;\n", _q->M_data);
     unsigned int i;
-    float complex * rc;
+    _Fcomplex * rc;
     float * r;
 
     // save subcarrier allocation
@@ -1311,4 +1311,3 @@ void ofdmframesync_debug_print(ofdmframesync _q,
     fprintf(stderr,"ofdmframesync_debug_print(): compile-time debugging disabled\n");
 #endif
 }
-
diff --git a/src/multichannel/tests/firpfbch2_crcf_autotest.c b/src/multichannel/tests/firpfbch2_crcf_autotest.c
index 0c60644e..f34801e8 100644
--- a/src/multichannel/tests/firpfbch2_crcf_autotest.c
+++ b/src/multichannel/tests/firpfbch2_crcf_autotest.c
@@ -37,8 +37,8 @@ void firpfbch2_crcf_runtest(unsigned int _M,
     unsigned int num_samples = _M * num_symbols;
 
     // allocate arrays
-    float complex x[num_samples];
-    float complex y[num_samples];
+    _Fcomplex x[num_samples];
+    _Fcomplex y[num_samples];
 
     // generate pseudo-random sequence
     unsigned int s = 1;         // seed
@@ -55,7 +55,7 @@ void firpfbch2_crcf_runtest(unsigned int _M,
     firpfbch2_crcf qs = firpfbch2_crcf_create_kaiser(LIQUID_SYNTHESIZER, _M, _m, _As);
 
     // run channelizer
-    float complex Y[_M];
+    _Fcomplex Y[_M];
     for (i=0; i<num_samples; i+=_M/2) {
         // run analysis filterbank
         firpfbch2_crcf_execute(qa, &x[i], Y);
@@ -82,7 +82,7 @@ void firpfbch2_crcf_runtest(unsigned int _M,
         }
 
         // compute rmse
-        float complex err = y[i] - (i < delay ? 0.0f : x[i-delay]);
+        _Fcomplex err = y[i] - (i < delay ? 0.0f : x[i-delay]);
         rmse += crealf(err * conjf(err));
     }
 
@@ -96,4 +96,3 @@ void autotest_firpfbch2_crcf_n8()    { firpfbch2_crcf_runtest(   8, 5, 60.0f); }
 void autotest_firpfbch2_crcf_n16()   { firpfbch2_crcf_runtest(  16, 5, 60.0f); }
 void autotest_firpfbch2_crcf_n32()   { firpfbch2_crcf_runtest(  32, 5, 60.0f); }
 void autotest_firpfbch2_crcf_n64()   { firpfbch2_crcf_runtest(  64, 5, 60.0f); }
-
diff --git a/src/multichannel/tests/firpfbch_crcf_analyzer_autotest.c b/src/multichannel/tests/firpfbch_crcf_analyzer_autotest.c
index 7786236a..421bd3b0 100644
--- a/src/multichannel/tests/firpfbch_crcf_analyzer_autotest.c
+++ b/src/multichannel/tests/firpfbch_crcf_analyzer_autotest.c
@@ -59,9 +59,9 @@ void autotest_firpfbch_crcf_analysis()
     firfilt_crcf f = firfilt_crcf_create(h, h_len);
 
     // allocate memory for arrays
-    float complex y[num_samples];                   // time-domain input
-    float complex Y0[num_symbols][num_channels];    // channelized output
-    float complex Y1[num_symbols][num_channels];    // channelized output
+    _Fcomplex y[num_samples];                   // time-domain input
+    _Fcomplex Y0[num_symbols][num_channels];    // channelized output
+    _Fcomplex Y1[num_symbols][num_channels];    // channelized output
 
     // generate input sequence (complex noise)
     ms = msequence_create_default(7);
@@ -71,7 +71,7 @@ void autotest_firpfbch_crcf_analysis()
     }
     msequence_destroy(ms);
 
-    // 
+    //
     // run analysis filter bank
     //
 
@@ -79,7 +79,7 @@ void autotest_firpfbch_crcf_analysis()
         firpfbch_crcf_analyzer_execute(q, &y[i*num_channels], &Y0[i][0]);
 
 
-    // 
+    //
     // run traditional down-converter (inefficient)
     //
 
@@ -148,5 +148,3 @@ void autotest_firpfbch_crcf_analysis()
     }
 
 }
-
-
diff --git a/src/multichannel/tests/firpfbch_crcf_synthesizer_autotest.c b/src/multichannel/tests/firpfbch_crcf_synthesizer_autotest.c
index 038b2380..79c8a9c2 100644
--- a/src/multichannel/tests/firpfbch_crcf_synthesizer_autotest.c
+++ b/src/multichannel/tests/firpfbch_crcf_synthesizer_autotest.c
@@ -59,9 +59,9 @@ void autotest_firpfbch_crcf_synthesis()
     // create filterbank channelizer object
     firpfbch_crcf q = firpfbch_crcf_create(LIQUID_SYNTHESIZER, num_channels, p, h);
 
-    float complex Y[num_symbols][num_channels];     // channelized input
-    float complex y0[num_samples];                  // time-domain output
-    float complex y1[num_samples];                  // time-domain output
+    _Fcomplex Y[num_symbols][num_channels];     // channelized input
+    _Fcomplex y0[num_samples];                  // time-domain output
+    _Fcomplex y1[num_samples];                  // time-domain output
 
     // generate input sequence (complex noise)
     ms = msequence_create_default(7);
@@ -73,14 +73,14 @@ void autotest_firpfbch_crcf_synthesis()
     }
     msequence_destroy(ms);
 
-    // 
+    //
     // run synthesis filter bank
     //
 
     for (i=0; i<num_symbols; i++)
         firpfbch_crcf_synthesizer_execute(q, &Y[i][0], &y0[i*num_channels]);
 
-    // 
+    //
     // run traditional up-converter (inefficient)
     //
 
@@ -90,7 +90,7 @@ void autotest_firpfbch_crcf_synthesis()
 
     unsigned int n;
     float dphi; // carrier frequency
-    float complex y_hat;
+    _Fcomplex y_hat;
     for (i=0; i<num_channels; i++) {
         // reset filter
         firfilt_crcf_reset(f);
@@ -123,9 +123,9 @@ void autotest_firpfbch_crcf_synthesis()
     firfilt_crcf_destroy(f);
     firpfbch_crcf_destroy(q);
 
-    // 
+    //
     // compare results
-    // 
+    //
     for (i=0; i<num_samples; i++) {
 
         // print channelizer outputs
@@ -142,4 +142,3 @@ void autotest_firpfbch_crcf_synthesis()
         CONTEND_DELTA( cimagf(y0[i]), cimagf(y1[i]), tol );
     }
 }
-
diff --git a/src/multichannel/tests/ofdmframesync_autotest.c b/src/multichannel/tests/ofdmframesync_autotest.c
index f411f9db..fc41a4c8 100644
--- a/src/multichannel/tests/ofdmframesync_autotest.c
+++ b/src/multichannel/tests/ofdmframesync_autotest.c
@@ -36,7 +36,7 @@
 //  _p          :   subcarrier allocation
 //  _M          :   number of subcarriers
 //  _userdata   :   user-defined data structure
-int ofdmframesync_autotest_callback(float complex * _X,
+int ofdmframesync_autotest_callback(_Fcomplex * _X,
                                     unsigned char * _p,
                                     unsigned int    _M,
                                     void * _userdata)
@@ -44,10 +44,10 @@ int ofdmframesync_autotest_callback(float complex * _X,
     printf("******** callback invoked!\n");
 
     // type cast _userdata as complex float array
-    float complex * X = (float complex *)_userdata;
+    _Fcomplex * X = (_Fcomplex *)_userdata;
 
     // copy values and return
-    memmove(X, _X, _M*sizeof(float complex));
+    memmove(X, _X, _M*sizeof(_Fcomplex));
 
     // return
     return 0;
@@ -82,12 +82,12 @@ void ofdmframesync_acquire_test(unsigned int _num_subcarriers,
     ofdmframegen fg = ofdmframegen_create(M, cp_len, taper_len, p);
     //ofdmframegen_print(fg);
 
-    float complex X[M];         // original data sequence
-    float complex X_test[M];    // recovered data sequence
+    _Fcomplex X[M];         // original data sequence
+    _Fcomplex X_test[M];    // recovered data sequence
     ofdmframesync fs = ofdmframesync_create(M,cp_len,taper_len,p,ofdmframesync_autotest_callback,(void*)X_test);
 
     unsigned int i;
-    float complex y[num_samples];   // frame samples
+    _Fcomplex y[num_samples];   // frame samples
 
     // assemble full frame
     unsigned int n=0;
@@ -142,4 +142,3 @@ void autotest_ofdmframesync_acquire_n64()   { ofdmframesync_acquire_test(64,  8,
 void autotest_ofdmframesync_acquire_n128()  { ofdmframesync_acquire_test(128, 16, 0); }
 void autotest_ofdmframesync_acquire_n256()  { ofdmframesync_acquire_test(256, 32, 0); }
 void autotest_ofdmframesync_acquire_n512()  { ofdmframesync_acquire_test(512, 64, 0); }
-
diff --git a/src/nco/bench/nco_benchmark.c b/src/nco/bench/nco_benchmark.c
index e23b64e8..dd388d1e 100644
--- a/src/nco/bench/nco_benchmark.c
+++ b/src/nco/bench/nco_benchmark.c
@@ -53,8 +53,8 @@ void benchmark_nco_mix_up(struct rusage *_start,
                           struct rusage *_finish,
                           unsigned long int *_num_iterations)
 {
-    float complex x[16],  y[16];
-    memset(x, 0, 16*sizeof(float complex));
+    _Fcomplex x[16],  y[16];
+    memset(x, 0, 16*sizeof(_Fcomplex));
 
     nco_crcf p = nco_crcf_create(LIQUID_NCO);
     nco_crcf_set_phase(p, 0.0f);
@@ -80,8 +80,8 @@ void benchmark_nco_mix_block_up(struct rusage *_start,
                                 struct rusage *_finish,
                                 unsigned long int *_num_iterations)
 {
-    float complex x[16], y[16];
-    memset(x, 0, 16*sizeof(float complex));
+    _Fcomplex x[16], y[16];
+    memset(x, 0, 16*sizeof(_Fcomplex));
 
     nco_crcf p = nco_crcf_create(LIQUID_NCO);
     nco_crcf_set_phase(p, 0.0f);
@@ -98,4 +98,3 @@ void benchmark_nco_mix_block_up(struct rusage *_start,
     *_num_iterations *= 16;
     nco_crcf_destroy(p);
 }
-
diff --git a/src/nco/bench/vco_benchmark.c b/src/nco/bench/vco_benchmark.c
index 094abfab..64e798a7 100644
--- a/src/nco/bench/vco_benchmark.c
+++ b/src/nco/bench/vco_benchmark.c
@@ -50,8 +50,8 @@ void benchmark_vco_mix_up(struct rusage *_start,
                           struct rusage *_finish,
                           unsigned long int *_num_iterations)
 {
-    float complex x[16],  y[16];
-    memset(x, 0, 16*sizeof(float complex));
+    _Fcomplex x[16],  y[16];
+    memset(x, 0, 16*sizeof(_Fcomplex));
 
     nco_crcf p = nco_crcf_create(LIQUID_VCO);
     nco_crcf_set_phase(p, 0.0f);
@@ -77,8 +77,8 @@ void benchmark_vco_mix_block_up(struct rusage *_start,
                                 struct rusage *_finish,
                                 unsigned long int *_num_iterations)
 {
-    float complex x[16], y[16];
-    memset(x, 0, 16*sizeof(float complex));
+    _Fcomplex x[16], y[16];
+    memset(x, 0, 16*sizeof(_Fcomplex));
 
     nco_crcf p = nco_crcf_create(LIQUID_VCO);
     nco_crcf_set_phase(p, 0.0f);
@@ -95,4 +95,3 @@ void benchmark_vco_mix_block_up(struct rusage *_start,
     *_num_iterations *= 16;
     nco_crcf_destroy(p);
 }
-
diff --git a/src/nco/src/nco_crcf.c b/src/nco/src/nco_crcf.c
index 5b9a2925..f5cb61f0 100644
--- a/src/nco/src/nco_crcf.c
+++ b/src/nco/src/nco_crcf.c
@@ -28,7 +28,7 @@
 
 #define NCO(name)   LIQUID_CONCAT(nco_crcf,name)
 #define T           float
-#define TC          float complex
+#define TC          _Fcomplex
 
 #define SIN         sinf
 #define COS         cosf
diff --git a/src/nco/tests/data/nco_sincos_fsqrt1_2.c b/src/nco/tests/data/nco_sincos_fsqrt1_2.c
index c05c898b..649beeaa 100644
--- a/src/nco/tests/data/nco_sincos_fsqrt1_2.c
+++ b/src/nco/tests/data/nco_sincos_fsqrt1_2.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex nco_sincos_fsqrt1_2[256] = {
+_Fcomplex nco_sincos_fsqrt1_2[256] = {
     1.000000000000 + _Complex_I*  0.000000000000,
     0.760244597076 + _Complex_I*  0.649636939080,
     0.155943694765 + _Complex_I*  0.987765945993,
@@ -283,4 +283,3 @@ float complex nco_sincos_fsqrt1_2[256] = {
    -0.985113105181 + _Complex_I*  0.171907446032,
    -0.860604342767 + _Complex_I* -0.509274155254,
    -0.323426498437 + _Complex_I* -0.946253295957};
-
diff --git a/src/nco/tests/data/nco_sincos_fsqrt1_3.c b/src/nco/tests/data/nco_sincos_fsqrt1_3.c
index 5b94c0f0..16c8b0f3 100644
--- a/src/nco/tests/data/nco_sincos_fsqrt1_3.c
+++ b/src/nco/tests/data/nco_sincos_fsqrt1_3.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex nco_sincos_fsqrt1_3[256] = {
+_Fcomplex nco_sincos_fsqrt1_3[256] = {
     1.000000000000 + _Complex_I*  0.000000000000,
     0.837911827695 + _Complex_I*  0.545805614673,
     0.404192461982 + _Complex_I*  0.914673960314,
@@ -283,4 +283,3 @@ float complex nco_sincos_fsqrt1_3[256] = {
     0.014439785103 + _Complex_I*  0.999895740868,
    -0.533649442727 + _Complex_I*  0.845705783519,
    -0.908742144910 + _Complex_I*  0.417358016653};
-
diff --git a/src/nco/tests/data/nco_sincos_fsqrt1_5.c b/src/nco/tests/data/nco_sincos_fsqrt1_5.c
index 64f8dfac..459de829 100644
--- a/src/nco/tests/data/nco_sincos_fsqrt1_5.c
+++ b/src/nco/tests/data/nco_sincos_fsqrt1_5.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex nco_sincos_fsqrt1_5[256] = {
+_Fcomplex nco_sincos_fsqrt1_5[256] = {
     1.000000000000 + _Complex_I*  0.000000000000,
     0.901655595150 + _Complex_I*  0.432454838954,
     0.625965624531 + _Complex_I*  0.779850650385,
@@ -283,4 +283,3 @@ float complex nco_sincos_fsqrt1_5[256] = {
     0.998862373647 + _Complex_I*  0.047686041058,
     0.880007788778 + _Complex_I*  0.474959252664,
     0.588065519407 + _Complex_I*  0.808813294206};
-
diff --git a/src/nco/tests/data/nco_sincos_fsqrt1_7.c b/src/nco/tests/data/nco_sincos_fsqrt1_7.c
index b11da3d3..cf41880f 100644
--- a/src/nco/tests/data/nco_sincos_fsqrt1_7.c
+++ b/src/nco/tests/data/nco_sincos_fsqrt1_7.c
@@ -26,7 +26,7 @@
 
 #include <complex.h>
 
-float complex nco_sincos_fsqrt1_7[256] = {
+_Fcomplex nco_sincos_fsqrt1_7[256] = {
     1.000000000000 + _Complex_I*  0.000000000000,
     0.929417729782 + _Complex_I*  0.369029380357,
     0.727634632866 + _Complex_I*  0.685964897829,
@@ -283,4 +283,3 @@ float complex nco_sincos_fsqrt1_7[256] = {
     0.192357809450 + _Complex_I*  0.981324856071,
    -0.183356945000 + _Complex_I*  0.983046403137,
    -0.533188200573 + _Complex_I*  0.845996656476};
-
diff --git a/src/nco/tests/nco_crcf_frequency_autotest.c b/src/nco/tests/nco_crcf_frequency_autotest.c
index 0eb9adc6..d872976e 100644
--- a/src/nco/tests/nco_crcf_frequency_autotest.c
+++ b/src/nco/tests/nco_crcf_frequency_autotest.c
@@ -26,10 +26,10 @@
 #include "liquid.h"
 
 // declare external arrays
-extern float complex nco_sincos_fsqrt1_2[];
-extern float complex nco_sincos_fsqrt1_3[];
-extern float complex nco_sincos_fsqrt1_5[];
-extern float complex nco_sincos_fsqrt1_7[];
+extern _Fcomplex nco_sincos_fsqrt1_2[];
+extern _Fcomplex nco_sincos_fsqrt1_3[];
+extern _Fcomplex nco_sincos_fsqrt1_5[];
+extern _Fcomplex nco_sincos_fsqrt1_7[];
 
 // autotest helper function
 //  _type       :   NCO type (e.g. LIQUID_NCO)
@@ -41,7 +41,7 @@ extern float complex nco_sincos_fsqrt1_7[];
 void nco_crcf_frequency_test(int             _type,
                              float           _phase,
                              float           _frequency,
-                             float complex * _sincos,
+                             _Fcomplex * _sincos,
                              unsigned int    _num_samples,
                              float           _tol)
 {
@@ -56,11 +56,11 @@ void nco_crcf_frequency_test(int             _type,
     unsigned int i;
     for (i=0; i<_num_samples; i++) {
         // compute complex output
-        float complex y_test;
+        _Fcomplex y_test;
         nco_crcf_cexpf(nco, &y_test);
 
         // compare to expected output
-        float complex y = _sincos[i];
+        _Fcomplex y = _sincos[i];
 
         // run tests
         CONTEND_DELTA( crealf(y_test), crealf(y), _tol );
@@ -87,4 +87,3 @@ void autotest_nco_crcf_frequency()
     nco_crcf_frequency_test(LIQUID_NCO, 0.0f, 0.447213595499958, nco_sincos_fsqrt1_5, 256, tol); // 1/sqrt(5)
     nco_crcf_frequency_test(LIQUID_NCO, 0.0f, 0.377964473009227, nco_sincos_fsqrt1_7, 256, tol); // 1/sqrt(7)
 }
-
diff --git a/src/nco/tests/nco_crcf_mix_autotest.c b/src/nco/tests/nco_crcf_mix_autotest.c
index 184dfcfd..f08ff460 100644
--- a/src/nco/tests/nco_crcf_mix_autotest.c
+++ b/src/nco/tests/nco_crcf_mix_autotest.c
@@ -39,8 +39,8 @@ void autotest_nco_crcf_mix_block_up()
     nco_crcf_set_frequency(nco, freq);
 
     // generate signal
-    float complex buf_0[buf_len];
-    float complex buf_1[buf_len];
+    _Fcomplex buf_0[buf_len];
+    _Fcomplex buf_1[buf_len];
     unsigned int i;
     for (i=0; i<buf_len; i++)
         buf_0[i] = cexpf(_Complex_I*2*M_PI*randf());
@@ -51,7 +51,7 @@ void autotest_nco_crcf_mix_block_up()
     // compare result to expected
     float phi = phase;
     for (i=0; i<buf_len; i++) {
-        float complex v = buf_0[i] * cexpf(_Complex_I*phi);
+        _Fcomplex v = buf_0[i] * cexpf(_Complex_I*phi);
         CONTEND_DELTA( crealf(buf_1[i]), crealf(v), tol);
         CONTEND_DELTA( cimagf(buf_1[i]), cimagf(v), tol);
         phi += freq;
@@ -60,4 +60,3 @@ void autotest_nco_crcf_mix_block_up()
     // destroy object
     nco_crcf_destroy(nco);
 }
-
diff --git a/src/nco/tests/nco_crcf_phase_autotest.c b/src/nco/tests/nco_crcf_phase_autotest.c
index 349636ff..81f1d55f 100644
--- a/src/nco/tests/nco_crcf_phase_autotest.c
+++ b/src/nco/tests/nco_crcf_phase_autotest.c
@@ -198,8 +198,8 @@ void autotest_nco_block_mixing()
     unsigned int num_samples = 1024;
 
     // store samples
-    float complex * x = (float complex*)malloc(num_samples*sizeof(float complex));
-    float complex * y = (float complex*)malloc(num_samples*sizeof(float complex));
+    _Fcomplex * x = (_Fcomplex*)malloc(num_samples*sizeof(_Fcomplex));
+    _Fcomplex * y = (_Fcomplex*)malloc(num_samples*sizeof(_Fcomplex));
 
     // generate complex sin/cos
     for (i=0; i<num_samples; i++)
@@ -234,4 +234,3 @@ void autotest_nco_block_mixing()
     // destroy NCO object
     nco_crcf_destroy(p);
 }
-
diff --git a/src/nco/tests/nco_crcf_pll_autotest.c b/src/nco/tests/nco_crcf_pll_autotest.c
index c3b1ef8c..b5eb6b65 100644
--- a/src/nco/tests/nco_crcf_pll_autotest.c
+++ b/src/nco/tests/nco_crcf_pll_autotest.c
@@ -51,7 +51,7 @@ void nco_crcf_pll_test(int          _type,
     // run loop
     unsigned int i;
     float phase_error;
-    float complex r, v;
+    _Fcomplex r, v;
     for (i=0; i<_num_iterations; i++) {
         // received complex signal
         nco_crcf_cexpf(nco_tx,&r);
@@ -110,7 +110,7 @@ void autotest_nco_crcf_pll_phase()
     nco_crcf_pll_test(LIQUID_NCO,  M_PI/2.0f,  0.0f, bw, num_steps, tol);
     nco_crcf_pll_test(LIQUID_NCO,  M_PI/1.1f,  0.0f, bw, num_steps, tol);
 }
-    
+
 void autotest_nco_crcf_pll_freq()
 {
     float        bw        = 0.1f;
@@ -127,4 +127,3 @@ void autotest_nco_crcf_pll_freq()
     nco_crcf_pll_test(LIQUID_NCO,  0.0f,       0.8f, bw, num_steps, tol);
     nco_crcf_pll_test(LIQUID_NCO,  0.0f,       1.6f, bw, num_steps, tol);
 }
-
diff --git a/src/quantization/src/compand.c b/src/quantization/src/compand.c
index 40431ddc..6e99da0f 100644
--- a/src/quantization/src/compand.c
+++ b/src/quantization/src/compand.c
@@ -56,7 +56,7 @@ float expand_mulaw(float _y, float _mu)
     return copysign(x, _y);
 }
 
-void compress_cf_mulaw(float complex _x, float _mu, float complex * _y)
+void compress_cf_mulaw(_Fcomplex _x, float _mu, _Fcomplex * _y)
 {
 #ifdef LIQUID_VALIDATE_INPUT
     if ( _mu <= 0.0f ) {
@@ -67,7 +67,7 @@ void compress_cf_mulaw(float complex _x, float _mu, float complex * _y)
     *_y = cexpf(_Complex_I*cargf(_x)) * logf(1 + _mu*cabsf(_x)) / logf(1 + _mu);
 }
 
-void expand_cf_mulaw(float complex _y, float _mu, float complex * _x)
+void expand_cf_mulaw(_Fcomplex _y, float _mu, _Fcomplex * _x)
 {
 #ifdef LIQUID_VALIDATE_INPUT
     if ( _mu <= 0.0f ) {
@@ -89,4 +89,3 @@ float expand_alaw(float _x, float _a)
 
 }
 */
-
diff --git a/src/quantization/src/quantizercf.c b/src/quantization/src/quantizercf.c
index 16d043f2..9fae4528 100644
--- a/src/quantization/src/quantizercf.c
+++ b/src/quantization/src/quantizercf.c
@@ -26,10 +26,10 @@
 
 #include "liquid.internal.h"
 
-// 
+//
 #define QUANTIZER(name)     LIQUID_CONCAT(quantizercf,name)
 
-#define T                   float complex   // general
+#define T                   _Fcomplex   // general
 
 #define T_COMPLEX           1
 
diff --git a/src/quantization/tests/compand_autotest.c b/src/quantization/tests/compand_autotest.c
index 7aa2616e..aad7151e 100644
--- a/src/quantization/tests/compand_autotest.c
+++ b/src/quantization/tests/compand_autotest.c
@@ -50,13 +50,13 @@ void autotest_compand_float() {
 
 
 void autotest_compand_cfloat() {
-    float complex x = -0.707f - 0.707f*_Complex_I;
+    _Fcomplex x = -0.707f - 0.707f*_Complex_I;
     float mu=255.0f;
     unsigned int n=30;
 
-    float complex dx = 2*(0.707f +0.707f* _Complex_I)/(float)(n);
-    float complex y;
-    float complex z;
+    _Fcomplex dx = 2*(0.707f +0.707f* _Complex_I)/(float)(n);
+    _Fcomplex y;
+    _Fcomplex z;
     float tol = 1e-6f;
 
     unsigned int i;
@@ -77,4 +77,3 @@ void autotest_compand_cfloat() {
         //x = (x > 1.0f) ? 1.0f : x;
     }
 }
-
diff --git a/src/random/bench/random_benchmark.c b/src/random/bench/random_benchmark.c
index 4808321f..99f46c6f 100644
--- a/src/random/bench/random_benchmark.c
+++ b/src/random/bench/random_benchmark.c
@@ -23,7 +23,7 @@
 #include <sys/resource.h>
 #include "liquid.h"
 
-// 
+//
 // BENCHMARK: uniform
 //
 void benchmark_random_uniform(struct rusage *_start,
@@ -48,7 +48,7 @@ void benchmark_random_uniform(struct rusage *_start,
     *_num_iterations *= 4;
 }
 
-// 
+//
 // BENCHMARK: normal
 //
 void benchmark_random_normal(struct rusage *_start,
@@ -73,7 +73,7 @@ void benchmark_random_normal(struct rusage *_start,
     *_num_iterations *= 4;
 }
 
-// 
+//
 // BENCHMARK: complex normal
 //
 void benchmark_random_complex_normal(struct rusage *_start,
@@ -83,7 +83,7 @@ void benchmark_random_complex_normal(struct rusage *_start,
     // normalize number of iterations
     *_num_iterations /= 2;
 
-    float complex x = 0.0f;
+    _Fcomplex x = 0.0f;
     unsigned long int i;
 
     // start trials
@@ -98,7 +98,7 @@ void benchmark_random_complex_normal(struct rusage *_start,
     *_num_iterations *= 4;
 }
 
-// 
+//
 // BENCHMARK: Weibull
 //
 void benchmark_random_weibull(struct rusage *_start,
@@ -126,7 +126,7 @@ void benchmark_random_weibull(struct rusage *_start,
     *_num_iterations *= 4;
 }
 
-// 
+//
 // BENCHMARK: Rice-K
 //
 void benchmark_random_ricek(struct rusage *_start,
@@ -152,4 +152,3 @@ void benchmark_random_ricek(struct rusage *_start,
     getrusage(RUSAGE_SELF, _finish);
     *_num_iterations *= 4;
 }
-
diff --git a/src/random/src/randn.c b/src/random/src/randn.c
index 7cd2e245..529853e6 100644
--- a/src/random/src/randn.c
+++ b/src/random/src/randn.c
@@ -53,7 +53,7 @@ void awgn(float *_x, float _nstd)
 }
 
 // Complex Gauss
-void crandnf(float complex * _y)
+void crandnf(_Fcomplex * _y)
 {
     // generate two uniform random numbers
     float u1, u2;
@@ -69,14 +69,14 @@ void crandnf(float complex * _y)
 }
 
 // Internal complex Gauss (inline)
-float complex icrandnf()
+_Fcomplex icrandnf()
 {
-    float complex y;
+    _Fcomplex y;
     crandnf(&y);
     return y;
 }
 
-void cawgn(float complex *_x, float _nstd)
+void cawgn(_Fcomplex *_x, float _nstd)
 {
     *_x += icrandnf()*_nstd*0.707106781186547f;
 }
@@ -104,4 +104,3 @@ float randnf_cdf(float _x,
 {
     return 0.5 + 0.5*erff( M_SQRT1_2*(_x-_eta)/_sig );
 }
-
diff --git a/src/random/src/randricek.c b/src/random/src/randricek.c
index f08d566d..c669fc2a 100644
--- a/src/random/src/randricek.c
+++ b/src/random/src/randricek.c
@@ -33,7 +33,7 @@
 // Rice-K
 float randricekf(float _K, float _omega)
 {
-    float complex x, y;
+    _Fcomplex x, y;
     float s = sqrtf((_omega*_K)/(_K+1));
     float sig = sqrtf(0.5f*_omega/(_K+1));
     crandnf(&x);
@@ -109,5 +109,3 @@ float randricekf_cdf(float _x,
 
     return F;
 }
-
-
diff --git a/src/random/tests/random_autotest.c b/src/random/tests/random_autotest.c
index a9e389f5..2d32370d 100644
--- a/src/random/tests/random_autotest.c
+++ b/src/random/tests/random_autotest.c
@@ -73,7 +73,7 @@ void autotest_crandnf()
 {
     unsigned long int N = LIQUID_RANDOM_AUTOTEST_NUM_TRIALS;
     unsigned long int i;
-    float complex x;
+    _Fcomplex x;
     float m1=0.0f, m2=0.0f;
     float tol = LIQUID_RANDOM_AUTOTEST_ERROR_TOL;
 
@@ -134,4 +134,3 @@ void autotest_randricekf()
     CONTEND_DELTA(m1, 0.92749f, tol);
     CONTEND_DELTA(m2, omega, tol);
 }
-
diff --git a/src/vector/src/vectorcf_add.port.c b/src/vector/src/vectorcf_add.port.c
index dd1905d6..ef9aac2b 100644
--- a/src/vector/src/vectorcf_add.port.c
+++ b/src/vector/src/vectorcf_add.port.c
@@ -20,15 +20,14 @@
  * THE SOFTWARE.
  */
 
-// 
+//
 // Vector
 //
 
 #include "liquid.internal.h"
 
 #define VECTOR(name)    LIQUID_CONCAT(liquid_vectorcf,name)
-#define T               float complex
+#define T               _Fcomplex
 #define TP              float
 
 #include "vector_add.c"
-
diff --git a/src/vector/src/vectorcf_mul.port.c b/src/vector/src/vectorcf_mul.port.c
index bf0f587e..3fa36985 100644
--- a/src/vector/src/vectorcf_mul.port.c
+++ b/src/vector/src/vectorcf_mul.port.c
@@ -20,15 +20,14 @@
  * THE SOFTWARE.
  */
 
-// 
+//
 // Vector
 //
 
 #include "liquid.internal.h"
 
 #define VECTOR(name)    LIQUID_CONCAT(liquid_vectorcf,name)
-#define T               float complex
+#define T               _Fcomplex
 #define TP              float
 
 #include "vector_mul.c"
-
diff --git a/src/vector/src/vectorcf_norm.port.c b/src/vector/src/vectorcf_norm.port.c
index 189d0903..e7f0bdae 100644
--- a/src/vector/src/vectorcf_norm.port.c
+++ b/src/vector/src/vectorcf_norm.port.c
@@ -20,15 +20,14 @@
  * THE SOFTWARE.
  */
 
-// 
+//
 // Vector
 //
 
 #include "liquid.internal.h"
 
 #define VECTOR(name)    LIQUID_CONCAT(liquid_vectorcf,name)
-#define T               float complex
+#define T               _Fcomplex
 #define TP              float
 
 #include "vector_norm.c"
-
diff --git a/src/vector/src/vectorcf_trig.port.c b/src/vector/src/vectorcf_trig.port.c
index 9773245c..13d8a2a0 100644
--- a/src/vector/src/vectorcf_trig.port.c
+++ b/src/vector/src/vectorcf_trig.port.c
@@ -20,17 +20,16 @@
  * THE SOFTWARE.
  */
 
-// 
+//
 // Vector
 //
 
 #include "liquid.internal.h"
 
 #define VECTOR(name)    LIQUID_CONCAT(liquid_vectorcf,name)
-#define T               float complex
+#define T               _Fcomplex
 #define TP              float
 
 #define T_COMPLEX       1
 
 #include "vector_trig.c"
-
-- 
2.32.0.windows.1

