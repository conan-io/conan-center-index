diff --git a/CMakeLists.txt b/CMakeLists.txt
index f469eb9f..b42f9c0d 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -14,6 +14,8 @@ if(POLICY CMP0042)
     cmake_policy(SET CMP0042 NEW)
 endif()
 
+set(BRPC_REVISION "f43bdcec")
+
 set(BRPC_VERSION 0.9.0)
 
 SET(CPACK_GENERATOR "DEB")
@@ -46,17 +48,22 @@ endif()
 
 if(WITH_THRIFT)
     set(THRIFT_CPP_FLAG "-DENABLE_THRIFT_FRAMED_PROTOCOL")
-    set(THRIFTNB_LIB "thriftnb")
-    set(THRIFT_LIB "thrift")
+    if(RECIPE_BUILD_TYPE MATCHES debug)
+      set(THRIFTNB_LIB "thriftnbd")
+      set(THRIFT_LIB "thriftd")
+    else()
+      set(THRIFTNB_LIB "thriftnb")
+      set(THRIFT_LIB "thrift")
+    endif()
 endif()
 
 include(GNUInstallDirs)
 
 configure_file(${PROJECT_SOURCE_DIR}/config.h.in ${PROJECT_SOURCE_DIR}/src/butil/config.h @ONLY)
 
-set(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)
+list(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)
 
-find_package(GFLAGS REQUIRED)
+find_package(BRPCGFLAGS REQUIRED)
 
 execute_process(
     COMMAND bash -c "grep \"namespace [_A-Za-z0-9]\\+ {\" ${GFLAGS_INCLUDE_PATH}/gflags/gflags_declare.h | head -1 | awk '{print $2}' | tr -d '\n'"
@@ -74,11 +81,6 @@ include_directories(
     ${CMAKE_CURRENT_BINARY_DIR}
 )
 
-execute_process(
-    COMMAND bash -c "git rev-parse --short HEAD | tr -d '\n'"
-    OUTPUT_VARIABLE BRPC_REVISION
-)
-
 if(CMAKE_SYSTEM_NAME STREQUAL "Darwin")
     include(CheckFunctionExists)
     CHECK_FUNCTION_EXISTS(clock_gettime HAVE_CLOCK_GETTIME)
@@ -130,14 +132,16 @@ endif()
 
 if(WITH_GLOG)
     find_path(GLOG_INCLUDE_PATH NAMES glog/logging.h)
-    find_library(GLOG_LIB NAMES glog)
+    # This diff hunk is necessary since a debug build produces glogd
+    find_library(GLOG_LIB NAMES glog glogd)
     if((NOT GLOG_INCLUDE_PATH) OR (NOT GLOG_LIB))
         message(FATAL_ERROR "Fail to find glog")
     endif()
     include_directories(${GLOG_INCLUDE_PATH})
 endif()
 
-find_library(PROTOC_LIB NAMES protoc)
+# This diff hunk is necessary since a debug build produces protocd
+find_library(PROTOC_LIB NAMES protoc protocd)
 if(NOT PROTOC_LIB)
     message(FATAL_ERROR "Fail to find protoc lib")
 endif()
@@ -157,9 +161,13 @@ include_directories(
         ${OPENSSL_INCLUDE_DIR}
         )
 
+# This diff hunk is necessary because the protobuf package disables the
+# backwards-compatible aliasing of Protobuf_LIBRARIES with
+# PROTOBUF_LIBRARIES. Normally, that should be enabled with
+# protobuf_MODULE_COMPATIBLE
 set(DYNAMIC_LIB
     ${GFLAGS_LIBRARY}
-    ${PROTOBUF_LIBRARIES}
+    ${Protobuf_LIBRARIES}
     ${LEVELDB_LIB}
     ${PROTOC_LIB}
     ${CMAKE_THREAD_LIBS_INIT}
@@ -171,6 +179,12 @@ set(DYNAMIC_LIB
     z)
 set(BRPC_PRIVATE_LIBS "-lgflags -lprotobuf -lleveldb -lprotoc -lssl -lcrypto -ldl -lz")
 
+if(WITH_SNAPPY)
+  find_library(SNAPPY_LIB NAMES snappy)
+  set(DYNAMIC_LIB ${DYNAMIC_LIB} ${SNAPPY_LIB})
+  set(BRPC_PRIVATE_LIBS "${BRPC_PRIVATE_LIBS} -lsnappy")
+endif()
+
 if(WITH_GLOG)
     set(DYNAMIC_LIB ${DYNAMIC_LIB} ${GLOG_LIB})
     set(BRPC_PRIVATE_LIBS "${BRPC_PRIVATE_LIBS} -lglog")
diff --git a/cmake/CompileProto.cmake b/cmake/CompileProto.cmake
index a8cf114b..a6bf18e6 100644
--- a/cmake/CompileProto.cmake
+++ b/cmake/CompileProto.cmake
@@ -1,3 +1,4 @@
+# 
 function(compile_proto OUT_HDRS OUT_SRCS DESTDIR HDR_OUTPUT_DIR PROTO_DIR PROTO_FILES)
   foreach(P ${PROTO_FILES})
     string(REPLACE .proto .pb.h HDR ${P})
@@ -7,13 +8,17 @@ function(compile_proto OUT_HDRS OUT_SRCS DESTDIR HDR_OUTPUT_DIR PROTO_DIR PROTO_
     set(SRC ${DESTDIR}/${SRC})
     list(APPEND HDRS ${HDR})
     list(APPEND SRCS ${SRC})
+    if(CMAKE_SYSTEM_NAME STREQUAL "Darwin")
+      list(JOIN CONAN_LIB_DIRS ":" JOINED_CONAN_LIB_DIRS)
+      set(DYLD_LIBRARY_PATH_FRAGMENT DYLD_LIBRARY_PATH=${Protobuf_LIB_DIRS}:${JOINED_CONAN_LIB_DIRS}:${Protobuf_LIB_DIRS_RELEASE}:${Protobuf_LIB_DIRS_DEBUG}:${Protobuf_LIB_DIRS_RELWITHDEBINFO}:${Protobuf_LIB_DIRS_MINSIZEREL})
+    endif()
     add_custom_command(
       OUTPUT ${HDR} ${SRC}
-      COMMAND ${PROTOBUF_PROTOC_EXECUTABLE} ${PROTOC_FLAGS} -I${PROTO_DIR} --cpp_out=${DESTDIR} ${PROTO_DIR}/${P}
+      COMMAND ${DYLD_LIBRARY_PATH_FRAGMENT} ${PROTOBUF_PROTOC_EXECUTABLE} ${PROTOC_FLAGS} -I${PROTO_DIR} --cpp_out=${DESTDIR} ${PROTO_DIR}/${P}
       COMMAND ${CMAKE_COMMAND} -E copy ${HDR} ${HDR_OUTPUT_DIR}/${HDR_RELATIVE}
       DEPENDS ${PROTO_DIR}/${P}
     )
   endforeach()
   set(${OUT_HDRS} ${HDRS} PARENT_SCOPE)
   set(${OUT_SRCS} ${SRCS} PARENT_SCOPE)
-endfunction()
\ No newline at end of file
+endfunction()
diff --git a/cmake/FindGFLAGS.cmake b/cmake/FindGFLAGS.cmake
index 50950422..0c21004b 100644
--- a/cmake/FindGFLAGS.cmake
+++ b/cmake/FindGFLAGS.cmake
@@ -9,7 +9,7 @@ if (GFLAGS_STATIC)
     set(CMAKE_FIND_LIBRARY_SUFFIXES .a ${CMAKE_FIND_LIBRARY_SUFFIXES})
   endif (WIN32)
 endif (GFLAGS_STATIC)
-find_library(GFLAGS_LIBRARY NAMES gflags libgflags)
+find_library(GFLAGS_LIBRARY NAMES gflags libgflags gflags_debug libgflags_debug gflags_nothreads libgflags_nothreads gflags_nothreads_debug libgflags_nothreads_debug)
 if(GFLAGS_INCLUDE_PATH AND GFLAGS_LIBRARY)
   set(GFLAGS_FOUND TRUE)
 endif(GFLAGS_INCLUDE_PATH AND GFLAGS_LIBRARY)
diff --git a/src/brpc/policy/gzip_compress.cpp b/src/brpc/policy/gzip_compress.cpp
index edba16d1..d1ac6644 100644
--- a/src/brpc/policy/gzip_compress.cpp
+++ b/src/brpc/policy/gzip_compress.cpp
@@ -17,6 +17,7 @@
 
 // Authors: Ge,Jun (gejun@baidu.com)
 
+#include <cstdlib>
 #include <google/protobuf/io/gzip_stream.h>    // GzipXXXStream
 #include "butil/logging.h"
 #include "brpc/policy/gzip_compress.h"
@@ -27,22 +28,31 @@ namespace brpc {
 namespace policy {
 
 static void LogError(const google::protobuf::io::GzipOutputStream& gzip) {
+#ifdef WITH_ZLIB
     if (gzip.ZlibErrorMessage()) {
         LOG(WARNING) << "Fail to decompress: " << gzip.ZlibErrorMessage();
     } else {
         LOG(WARNING) << "Fail to decompress.";
     }
+#endif
+
+    std::abort();
 }
 
 static void LogError(const google::protobuf::io::GzipInputStream& gzip) {
+#ifdef WITH_ZLIB
     if (gzip.ZlibErrorMessage()) {
         LOG(WARNING) << "Fail to decompress: " << gzip.ZlibErrorMessage();
     } else {
         LOG(WARNING) << "Fail to decompress.";
     }
+#endif
+
+    std::abort();
 }
 
 bool GzipCompress(const google::protobuf::Message& msg, butil::IOBuf* buf) {
+#ifdef WITH_ZLIB
     butil::IOBufAsZeroCopyOutputStream wrapper(buf);
     google::protobuf::io::GzipOutputStream::Options gzip_opt;
     gzip_opt.format = google::protobuf::io::GzipOutputStream::GZIP;
@@ -52,9 +62,13 @@ bool GzipCompress(const google::protobuf::Message& msg, butil::IOBuf* buf) {
         return false;
     }
     return gzip.Close();
+#endif
+
+    std::abort();
 }
 
 bool GzipDecompress(const butil::IOBuf& data, google::protobuf::Message* msg) {
+#ifdef WITH_ZLIB
     butil::IOBufAsZeroCopyInputStream wrapper(data);
     google::protobuf::io::GzipInputStream gzip(
             &wrapper, google::protobuf::io::GzipInputStream::GZIP);
@@ -63,10 +77,14 @@ bool GzipDecompress(const butil::IOBuf& data, google::protobuf::Message* msg) {
         return false;
     }
     return true;
+#endif
+
+    std::abort();
 }
 
 bool GzipCompress(const butil::IOBuf& msg, butil::IOBuf* buf,
                   const GzipCompressOptions* options_in) {
+#ifdef WITH_ZLIB
     butil::IOBufAsZeroCopyOutputStream wrapper(buf);
     google::protobuf::io::GzipOutputStream::Options gzip_opt;
     if (options_in) {
@@ -101,11 +119,15 @@ bool GzipCompress(const butil::IOBuf& msg, butil::IOBuf* buf,
         out.BackUp(size_out);
     }
     return out.Close();
+#endif
+
+    std::abort();
 }
 
 inline bool GzipDecompressBase(
     const butil::IOBuf& data, butil::IOBuf* msg,
     google::protobuf::io::GzipInputStream::Format format) {
+#ifdef WITH_ZLIB
     butil::IOBufAsZeroCopyInputStream wrapper(data);
     google::protobuf::io::GzipInputStream in(&wrapper, format);
     butil::IOBufAsZeroCopyOutputStream out(msg);
@@ -140,31 +162,50 @@ inline bool GzipDecompressBase(
         out.BackUp(size_out);
     }
     return true;
+#endif
+
+    std::abort();
 }
 
 bool ZlibCompress(const google::protobuf::Message& res, butil::IOBuf* buf) {
+#ifdef WITH_ZLIB
     butil::IOBufAsZeroCopyOutputStream wrapper(buf);
     google::protobuf::io::GzipOutputStream::Options zlib_opt;
     zlib_opt.format = google::protobuf::io::GzipOutputStream::ZLIB;
     google::protobuf::io::GzipOutputStream zlib(&wrapper, zlib_opt);
     return res.SerializeToZeroCopyStream(&zlib) && zlib.Close();
+#endif
+
+    std::abort();
 }
 
 bool ZlibDecompress(const butil::IOBuf& data, google::protobuf::Message* req) {
+#ifdef WITH_ZLIB
     butil::IOBufAsZeroCopyInputStream wrapper(data);
     google::protobuf::io::GzipInputStream zlib(
         &wrapper, google::protobuf::io::GzipInputStream::ZLIB);
     return ParsePbFromZeroCopyStream(req, &zlib);
+#endif
+
+    std::abort();
 }
 
 bool GzipDecompress(const butil::IOBuf& data, butil::IOBuf* msg) {
+#ifdef WITH_ZLIB
     return GzipDecompressBase(
         data, msg, google::protobuf::io::GzipInputStream::GZIP);
+#endif
+
+    std::abort();
 }
 
 bool ZlibDecompress(const butil::IOBuf& data, butil::IOBuf* msg) {
+#ifdef WITH_ZLIB
     return GzipDecompressBase(
         data, msg, google::protobuf::io::GzipInputStream::ZLIB);
+#endif
+
+    std::abort();
 }
 
 }  // namespace policy
diff --git a/src/butil/mac/foundation_util.h b/src/butil/mac/foundation_util.h
index 53b29326..8e004381 100644
--- a/src/butil/mac/foundation_util.h
+++ b/src/butil/mac/foundation_util.h
@@ -51,9 +51,6 @@ typedef CR_FORWARD_ENUM(unsigned int, NSSearchPathDirectory);
 typedef unsigned int NSSearchPathDomainMask;
 #endif
 
-typedef struct OpaqueSecTrustRef* SecACLRef;
-typedef struct OpaqueSecTrustedApplicationRef* SecTrustedApplicationRef;
-
 namespace butil {
 
 class FilePath;
diff --git a/src/bvar/scoped_timer.h b/src/bvar/scoped_timer.h
index b3f1c5c9..bc68b081 100644
--- a/src/bvar/scoped_timer.h
+++ b/src/bvar/scoped_timer.h
@@ -48,7 +48,7 @@ public:
         *_bvar << (butil::cpuwide_time_us() - _start_time);
     }
 
-    void reset() { _start_time = butil::cpuwide_time_us(); }
+    //void reset() { _start_time = butil::cpuwide_time_us(); }
 
 private:
     DISALLOW_COPY_AND_ASSIGN(ScopedTimer);
