diff --git a/crates/c_api/CMakeLists.txt b/crates/c_api/CMakeLists.txt
index b15c787..54eaed2 100644
--- a/crates/c_api/CMakeLists.txt
+++ b/crates/c_api/CMakeLists.txt
@@ -6,6 +6,8 @@ option(BUILD_SHARED_LIBS "Build using shared libraries" OFF)
 option(WASMI_ALWAYS_BUILD "If cmake should always invoke cargo to build Wasmi" ON)
 set(WASMI_TARGET "" CACHE STRING "Rust target to build for")
 
+add_compile_definitions(COMPILING_WASM_RUNTIME_API=1)
+
 if(NOT WASMI_TARGET)
     execute_process(
         COMMAND rustc -vV
@@ -43,6 +45,10 @@ endif()
 list(TRANSFORM WASMI_SHARED_FILES PREPEND ${WASMI_TARGET_DIR}/)
 list(TRANSFORM WASMI_STATIC_FILES PREPEND ${WASMI_TARGET_DIR}/)
 
+if(NOT BUILD_SHARED_LIBS)
+  set(WASMI_SHARED_FILES)
+endif()
+
 # Instructions on how to build and install the Wasmi Rust crate.
 find_program(WASMI_CARGO_BINARY cargo REQUIRED)
 include(ExternalProject)
@@ -79,7 +85,6 @@ else()
     target_link_libraries(wasmi INTERFACE ${WASMI_STATIC_FILES})
 
     if(WASMI_TARGET MATCHES "windows")
-        target_compile_options(wasmi INTERFACE -DWASM_API_EXTERN= -DWASI_API_EXTERN=)
         target_link_libraries(wasmi INTERFACE ws2_32 advapi32 userenv ntdll shell32 ole32 bcrypt)
     elseif(NOT WASMI_TARGET MATCHES "darwin")
         target_link_libraries(wasmi INTERFACE pthread dl m)
@@ -112,6 +117,7 @@ install(
     DESTINATION ${CMAKE_INSTALL_LIBDIR}
 )
 
+if(BUILD_SHARED_LIBS)
 if(WASMI_TARGET MATCHES "darwin")
     set(INSTALLED_LIB "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}/libwasmi.dylib")
     install(
@@ -131,6 +137,7 @@ if(WASMI_TARGET MATCHES "darwin")
         install(CODE "execute_process(COMMAND ${install_name_tool_cmd})")
     endif()
 endif()
+endif()
 
 # Documentation Generation via Doxygen:
 set(DOXYGEN_CONF_IN ${CMAKE_CURRENT_SOURCE_DIR}/doxygen.conf.in)
@@ -141,19 +148,3 @@ add_custom_target(doc
     DEPENDS ${WASMI_GENERATED_CONF_H} ${DOXYGEN_CONF_OUT}
     WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
 )
-
-# C-Header Formatting via clang-format:
-find_program(CLANG_FORMAT clang-format REQUIRED)
-file(GLOB_RECURSE HEADER_FILES
-    ${CMAKE_CURRENT_SOURCE_DIR}/include/wasmi.h
-    ${CMAKE_CURRENT_SOURCE_DIR}/include/wasmi/*.h
-    ${CMAKE_CURRENT_SOURCE_DIR}/include/wasmi/*.hh
-)
-add_custom_target(check-format
-    COMMAND ${CLANG_FORMAT} -style=llvm -Werror --dry-run ${HEADER_FILES}
-    COMMENT "clang-format: Check formatting for Wasmi C-API header files"
-)
-add_custom_target(format
-    COMMAND ${CLANG_FORMAT} -style=llvm -i ${HEADER_FILES}
-    COMMENT "clang-format: Apply formatting rules for Wasmi C-API header files"
-)
diff --git a/crates/c_api/include/wasm.h b/crates/c_api/include/wasm.h
index 5ee617f..a76f10e 100644
--- a/crates/c_api/include/wasm.h
+++ b/crates/c_api/include/wasm.h
@@ -13,11 +13,17 @@
 #include <assert.h>
 
 #ifndef WASM_API_EXTERN
-#if defined(_WIN32) && !defined(__MINGW32__) && !defined(LIBWASM_STATIC)
+#if defined(_MSC_BUILD)
+#if defined(COMPILING_WASM_RUNTIME_API)
+#define WASM_API_EXTERN __declspec(dllexport)
+#elif defined(_DLL)
 #define WASM_API_EXTERN __declspec(dllimport)
 #else
 #define WASM_API_EXTERN
 #endif
+#else
+#define WASM_API_EXTERN
+#endif
 #endif
 
 #ifdef __cplusplus
@@ -145,7 +151,13 @@ WASM_API_EXTERN own wasm_engine_t* wasm_engine_new_with_config(own wasm_config_t
 WASM_DECLARE_OWN(store)
 
 WASM_API_EXTERN own wasm_store_t* wasm_store_new(wasm_engine_t*);
+WASM_API_EXTERN own wasm_store_t* wasm_store_new_with_memory_max_pages(wasm_engine_t*, uint32_t max_pages);
+
+// Store fuel functions (forward declarations)
+struct wasmi_error;
 
+WASM_API_EXTERN struct wasmi_error* wasm_store_get_fuel(const wasm_store_t*, uint64_t* fuel);
+WASM_API_EXTERN struct wasmi_error* wasm_store_set_fuel(wasm_store_t*, uint64_t fuel);
 
 ///////////////////////////////////////////////////////////////////////////////
 // Type Representations
diff --git a/crates/c_api/include/wasmi.h b/crates/c_api/include/wasmi.h
index 2caffa3..0c0584e 100644
--- a/crates/c_api/include/wasmi.h
+++ b/crates/c_api/include/wasmi.h
@@ -10,7 +10,7 @@
 /**
  * \brief Wasmi version string.
  */
-#define WASMI_VERSION "0.35.0"
+#define WASMI_VERSION "0.42.1"
 /**
  * \brief Wasmi major version number.
  */
@@ -18,10 +18,10 @@
 /**
  * \brief Wasmi minor version number.
  */
-#define WASMI_VERSION_MINOR 35
+#define WASMI_VERSION_MINOR 42
 /**
  * \brief Wasmi patch version number.
  */
-#define WASMI_VERSION_PATCH 0
+#define WASMI_VERSION_PATCH 1
 
 #endif // WASMI_H
diff --git a/crates/c_api/src/store.rs b/crates/c_api/src/store.rs
index 56d4898..9abda8e 100644
--- a/crates/c_api/src/store.rs
+++ b/crates/c_api/src/store.rs
@@ -1,7 +1,7 @@
 use crate::{wasm_engine_t, wasmi_error_t, ForeignData};
 use alloc::{boxed::Box, sync::Arc};
 use core::{cell::UnsafeCell, ffi};
-use wasmi::{AsContext, AsContextMut, Store, StoreContext, StoreContextMut};
+use wasmi::{AsContext, AsContextMut, Store, StoreContext, StoreContextMut, StoreLimits, StoreLimitsBuilder};
 
 /// This representation of a `Store` is used to implement the `wasm.h` API (and
 /// *not* the `wasmi.h` API!)
@@ -16,7 +16,7 @@ use wasmi::{AsContext, AsContextMut, Store, StoreContext, StoreContextMut};
 /// least Wasmi's implementation).
 #[derive(Clone)]
 pub struct WasmStoreRef {
-    inner: Arc<UnsafeCell<Store<()>>>,
+    inner: Arc<UnsafeCell<Store<StoreLimits>>>,
 }
 
 impl WasmStoreRef {
@@ -27,7 +27,7 @@ impl WasmStoreRef {
     /// # Safety
     ///
     /// It is the callers responsibility to provide a valid `self`.
-    pub unsafe fn context(&self) -> StoreContext<'_, ()> {
+    pub unsafe fn context(&self) -> StoreContext<'_, StoreLimits> {
         (*self.inner.get()).as_context()
     }
 
@@ -38,7 +38,7 @@ impl WasmStoreRef {
     /// # Safety
     ///
     /// It is the callers responsibility to provide a valid `self`.
-    pub unsafe fn context_mut(&mut self) -> StoreContextMut<'_, ()> {
+    pub unsafe fn context_mut(&mut self) -> StoreContextMut<'_, StoreLimits> {
         (*self.inner.get()).as_context_mut()
     }
 }
@@ -56,17 +56,71 @@ pub struct wasm_store_t {
 
 wasmi_c_api_macros::declare_own!(wasm_store_t);
 
-/// Creates a new [`Store<()>`](wasmi::Store) for the given `engine`.
+/// Creates a new [`Store<StoreLimits>`](wasmi::Store) for the given `engine`.
+///
+/// The store is created with no resource limits (original behavior).
+/// For memory-limited stores, use [`wasm_store_new_with_memory_max_pages`].
 ///
 /// The returned [`wasm_store_t`] must be freed using [`wasm_store_delete`].
 ///
-/// Wraps [`<wasmi::Store<()>>::new`](wasmi::Store::new).
+/// Wraps [`<wasmi::Store<StoreLimits>>::new`](wasmi::Store::new).
 #[cfg_attr(not(feature = "prefix-symbols"), no_mangle)]
 #[allow(clippy::arc_with_non_send_sync)]
 #[cfg_attr(feature = "prefix-symbols", wasmi_c_api_macros::prefix_symbol)]
 pub extern "C" fn wasm_store_new(engine: &wasm_engine_t) -> Box<wasm_store_t> {
     let engine = &engine.inner;
-    let store = Store::new(engine, ());
+
+    // Create store with no resource limits (original behavior)
+    let limits = StoreLimitsBuilder::new().build();
+    let store = Store::new(engine, limits);
+
+    Box::new(wasm_store_t {
+        inner: WasmStoreRef {
+            inner: Arc::new(UnsafeCell::new(store)),
+        },
+    })
+}
+
+/// Creates a new [`Store<StoreLimits>`](wasmi::Store) for the given `engine` with memory limits.
+///
+/// This function creates a store with resource limits suitable for blockchain smart contracts.
+/// The memory limit is enforced during WebAssembly execution.
+///
+/// If `max_pages` exceeds 1024 (64MB), this function will panic.
+///
+/// The returned [`wasm_store_t`] must be freed using [`wasm_store_delete`].
+///
+/// Wraps [`<wasmi::Store<StoreLimits>>::new`](wasmi::Store::new).
+#[cfg_attr(not(feature = "prefix-symbols"), no_mangle)]
+#[allow(clippy::arc_with_non_send_sync)]
+#[cfg_attr(feature = "prefix-symbols", wasmi_c_api_macros::prefix_symbol)]
+pub extern "C" fn wasm_store_new_with_memory_max_pages(
+    engine: &wasm_engine_t,
+    max_pages: u32,
+) -> Box<wasm_store_t> {
+    // Validate max_pages limit (64MB = 1024 pages)
+    if max_pages > 1024 {
+        panic!("max_pages ({}) exceeds maximum allowed value of 1024 pages (64MB)", max_pages);
+    }
+
+    // Convert pages to bytes (each page is 64KB)
+    let max_memory_bytes = (max_pages as usize) * (64 * 1024);
+
+    // Create store limits with blockchain-suitable defaults
+    let limits = StoreLimitsBuilder::new()
+        .memory_size(max_memory_bytes) // User-specified memory limit
+        .instances(1) // Single instance for blockchain
+        .tables(1) // Single table for blockchain
+        .memories(1) // Single memory for blockchain
+        .table_elements(64) // Limited table elements for blockchain
+        .trap_on_grow_failure(false) // Return -1 on growth failure instead of trapping
+        .build();
+
+    let mut store = Store::new(&engine.inner, limits);
+
+    // Install the resource limiter
+    store.limiter(|limits| limits);
+
     Box::new(wasm_store_t {
         inner: WasmStoreRef {
             inner: Arc::new(UnsafeCell::new(store)),
@@ -175,3 +229,40 @@ pub extern "C" fn wasmi_context_set_fuel(
 ) -> Option<Box<wasmi_error_t>> {
     crate::handle_result(store.set_fuel(fuel), |()| {})
 }
+
+////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////
+
+/// Returns the current fuel of the wasm store context in `fuel`.
+///
+/// Wraps [`Store::get_fuel`].
+///
+/// # Errors
+///
+/// If [`Store::get_fuel`] errors.
+#[no_mangle]
+pub extern "C" fn wasm_store_get_fuel(
+    store: &wasm_store_t,
+    fuel: &mut u64,
+) -> Option<Box<wasmi_error_t>> {
+    let context = unsafe { store.inner.context() };
+    crate::handle_result(context.get_fuel(), |amt| {
+        *fuel = amt;
+    })
+}
+
+/// Sets the current fuel of the wasm store context to `fuel`.
+///
+/// Wraps [`Store::set_fuel`].
+///
+/// # Errors
+///
+/// If [`Store::set_fuel`] errors.
+#[no_mangle]
+pub extern "C" fn wasm_store_set_fuel(
+    store: &mut wasm_store_t,
+    fuel: u64,
+) -> Option<Box<wasmi_error_t>> {
+    let mut context = unsafe { store.inner.context_mut() };
+    crate::handle_result(context.set_fuel(fuel), |()| {})
+}
