--- a/src/cspice/dasfm.c
+++ b/src/cspice/dasfm.c
@@ -684,7 +684,7 @@ static integer c__1 = 1;
     extern logical failed_(void);
     static integer endrec, loccch;
     extern /* Subroutine */ int cleari_(integer *, integer *);
-    static char locdas[255];
+    static char locdas[128];
     static integer loccrc, dirrec[256];
     static char locifn[60];
     extern integer lnknfn_(integer *);
@@ -3730,11 +3730,11 @@ L_dasops:
 /*     Assign a name to the scratch file. This name is required */
 /*     by the DDH subsystem. */
 
-    s_copy(locdas, "DAS SCRATCH FILE", (ftnlen)255, (ftnlen)16);
+    s_copy(locdas, "DAS SCRATCH FILE", (ftnlen)128, (ftnlen)16);
 
 /*     Open a DAS file for scratch access. */
 
-    zzddhopn_(locdas, "SCRATCH", "DAS", handle, (ftnlen)255, (ftnlen)7, (
+    zzddhopn_(locdas, "SCRATCH", "DAS", handle, (ftnlen)128, (ftnlen)7, (
 	    ftnlen)3);
     if (failed_()) {
 	chkout_("DASOPS", (ftnlen)6);
@@ -4869,7 +4869,7 @@ L100003:
 		ioin__1.inopen = 0;
 		ioin__1.innum = 0;
 		ioin__1.innamed = 0;
-		ioin__1.innamlen = 255;
+		ioin__1.innamlen = 128;
 		ioin__1.inname = locdas;
 		ioin__1.inacc = 0;
 		ioin__1.inseq = 0;
@@ -4888,7 +4888,7 @@ L100003:
 		}
 		setmsg_("Attempt to update file record failed. File was '#'."
 			"  Value of IOSTAT was '#'.", (ftnlen)77);
-		errch_("#", locdas, (ftnlen)1, (ftnlen)255);
+		errch_("#", locdas, (ftnlen)1, (ftnlen)128);
 		errint_("#", &iostat, (ftnlen)1);
 		sigerr_("SPICE(DASWRITEFAIL)", (ftnlen)19);
 		chkout_("DASUFS", (ftnlen)6);
--- a/src/cspice/errdev.c
+++ b/src/cspice/errdev.c
@@ -16,7 +16,7 @@ static integer c__2 = 2;
     /* System generated locals */
     address a__1[2];
     integer i__1[2];
-    char ch__1[378], ch__2[65];
+    char ch__1[251], ch__2[65];
 
     /* Builtin functions */
     integer s_cmp(char *, char *, ftnlen, ftnlen);
@@ -27,9 +27,9 @@ static integer c__2 = 2;
     char upop[3];
     extern /* Subroutine */ int chkin_(char *, ftnlen), ucase_(char *, char *,
 	     ftnlen, ftnlen);
-    char locop[3], upnam[255];
+    char locop[3], upnam[128];
     extern /* Subroutine */ int ljust_(char *, char *, ftnlen, ftnlen);
-    char locnam[255];
+    char locnam[128];
     extern /* Subroutine */ int getdev_(char *, ftnlen);
     extern integer lastnb_(char *, ftnlen);
     extern /* Subroutine */ int sigerr_(char *, ftnlen), chkout_(char *, 
@@ -393,27 +393,27 @@ static integer c__2 = 2;
 /*        case for our own use.  So, save the input value */
 /*        and get an upper case version: */
 
-	ljust_(device, upnam, device_len, (ftnlen)255);
-	ucase_(upnam, upnam, (ftnlen)255, (ftnlen)255);
-	if (lastnb_(upnam, (ftnlen)255) > 255) {
-	    s_copy(locnam, device, (ftnlen)255, device_len);
+	ljust_(device, upnam, device_len, (ftnlen)128);
+	ucase_(upnam, upnam, (ftnlen)128, (ftnlen)128);
+	if (lastnb_(upnam, (ftnlen)128) > 128) {
+	    s_copy(locnam, device, (ftnlen)128, device_len);
 /* Writing concatenation */
 	    i__1[0] = 123, a__1[0] = "ERRDEV:  Device name exceeds FILEN cha"
 		    "racters; device selection not updated. The first FILEN c"
 		    "haracters of the name were:  ";
-	    i__1[1] = 255, a__1[1] = locnam;
-	    s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)378);
-	    setmsg_(ch__1, (ftnlen)378);
+	    i__1[1] = 128, a__1[1] = locnam;
+	    s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)251);
+	    setmsg_(ch__1, (ftnlen)251);
 	    sigerr_("SPICE(DEVICENAMETOOLONG)", (ftnlen)24);
 	    chkout_("ERRDEV", (ftnlen)6);
 	    return 0;
 	}
-	if (s_cmp(upnam, "SCREEN", (ftnlen)255, (ftnlen)6) == 0 || s_cmp(
-		upnam, "NULL", (ftnlen)255, (ftnlen)4) == 0) {
+	if (s_cmp(upnam, "SCREEN", (ftnlen)128, (ftnlen)6) == 0 || s_cmp(
+		upnam, "NULL", (ftnlen)128, (ftnlen)4) == 0) {
 
 /*           Store upper case version of DEVICE: */
 
-	    putdev_(upnam, (ftnlen)255);
+	    putdev_(upnam, (ftnlen)128);
 	} else {
 
 /*           We assume we've got a file name... */
--- a/src/cspice/outmsg.c
+++ b/src/cspice/outmsg.c
@@ -18,12 +18,12 @@ static integer c__1 = 1;
 {
     /* Initialized data */
 
-    static char defmsg[80*4] = "Oh, by the way:  The SPICELIB error handling"
-	    " actions are USER-TAILORABLE.  You  " "can choose whether the To"
-	    "olkit aborts or continues when errors occur, which     " "error "
-	    "messages to output, and where to send the output.  Please read t"
-	    "he ERROR  " "\"Required Reading\" file, or see the routines ERRA"
-	    "CT, ERRDEV, and ERRPRT.        ";
+    static char defmsg[78*4] = "Oh, by the way:  The SPICELIB error handling"
+	    " actions are USER-TAILORABLE.  You" "can choose whether the Tool"
+	    "kit aborts or continues when errors occur, which   " "error mess"
+	    "ages to output, and where to send the output.  Please read the E"
+	    "RROR" "\"Required Reading\" file, or see the routines ERRACT, ER"
+	    "RDEV, and ERRPRT.      ";
     static logical first = TRUE_;
 
     /* System generated locals */
@@ -38,7 +38,7 @@ static integer c__1 = 1;
 	     s_copy(char *, char *, ftnlen, ftnlen);
 
     /* Local variables */
-    char name__[32], line[80];
+    char name__[32], line[78];
     logical long__;
     char lmsg[1840];
     logical expl;
@@ -54,9 +54,9 @@ static integer c__1 = 1;
     integer start;
     logical short__;
     extern /* Subroutine */ int ljust_(char *, char *, ftnlen, ftnlen);
-    char device[255];
+    char device[128];
     integer remain;
-    static char border[80];
+    static char border[78];
     extern /* Subroutine */ int getdev_(char *, ftnlen);
     logical dfault;
     integer length;
@@ -609,7 +609,7 @@ static integer c__1 = 1;
 
     if (first) {
 	first = FALSE_;
-	for (i__ = 1; i__ <= 80; ++i__) {
+	for (i__ = 1; i__ <= 78; ++i__) {
 	    *(unsigned char *)&border[i__ - 1] = '=';
 	}
     }
@@ -652,19 +652,19 @@ static integer c__1 = 1;
 /*           result if this routine calls SIGERR.  So we output */
 /*           the error message directly: */
 
-	    getdev_(device, (ftnlen)255);
-	    wrline_(device, "SPICE(INVALIDLISTITEM)", (ftnlen)255, (ftnlen)22)
+	    getdev_(device, (ftnlen)128);
+	    wrline_(device, "SPICE(INVALIDLISTITEM)", (ftnlen)128, (ftnlen)22)
 		    ;
-	    wrline_(device, " ", (ftnlen)255, (ftnlen)1);
+	    wrline_(device, " ", (ftnlen)128, (ftnlen)1);
 	    wrline_(device, "OUTMSG:  An invalid message type was specified "
-		    "in the type list. ", (ftnlen)255, (ftnlen)65);
+		    "in the type list. ", (ftnlen)128, (ftnlen)65);
 /* Writing concatenation */
 	    i__3[0] = 29, a__1[0] = "The invalid message type was ";
 	    i__3[1] = 9, a__1[1] = words + ((i__2 = i__ - 1) < 5 && 0 <= i__2 
 		    ? i__2 : s_rnge("words", i__2, "outmsg_", (ftnlen)650)) * 
 		    9;
 	    s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)38);
-	    wrline_(device, ch__1, (ftnlen)255, (ftnlen)38);
+	    wrline_(device, ch__1, (ftnlen)128, (ftnlen)38);
 	}
     }
 
@@ -676,11 +676,11 @@ static integer c__1 = 1;
 
 /*     We get the default error output device: */
 
-    getdev_(device, (ftnlen)255);
+    getdev_(device, (ftnlen)128);
     output = short__ && msgsel_("SHORT", (ftnlen)5) || expl && msgsel_("EXPL"
 	    "AIN", (ftnlen)7) || long__ && msgsel_("LONG", (ftnlen)4) || trace 
 	    && msgsel_("TRACEBACK", (ftnlen)9) || dfault && msgsel_("DEFAULT",
-	     (ftnlen)7) && s_cmp(device, "NULL", (ftnlen)255, (ftnlen)4) != 0;
+	     (ftnlen)7) && s_cmp(device, "NULL", (ftnlen)128, (ftnlen)4) != 0;
 
 /*     We go ahead and output those messages that have been specified */
 /*     in the list and also are enabled for output. The order of the */
@@ -697,9 +697,9 @@ static integer c__1 = 1;
 /*     Write the starting border: skip a line, write the border, */
 /*     skip a line. */
 
-    wrline_(device, " ", (ftnlen)255, (ftnlen)1);
-    wrline_(device, border, (ftnlen)255, (ftnlen)80);
-    wrline_(device, " ", (ftnlen)255, (ftnlen)1);
+    wrline_(device, " ", (ftnlen)128, (ftnlen)1);
+    wrline_(device, border, (ftnlen)128, (ftnlen)78);
+    wrline_(device, " ", (ftnlen)128, (ftnlen)1);
 
 /*     Output the toolkit version and skip a line. */
 
@@ -707,9 +707,9 @@ static integer c__1 = 1;
 /* Writing concatenation */
     i__3[0] = 17, a__1[0] = "Toolkit version: ";
     i__3[1] = 80, a__1[1] = versn;
-    s_cat(line, a__1, i__3, &c__2, (ftnlen)80);
-    wrline_(device, line, (ftnlen)255, (ftnlen)80);
-    wrline_(device, " ", (ftnlen)255, (ftnlen)1);
+    s_cat(line, a__1, i__3, &c__2, (ftnlen)78);
+    wrline_(device, line, (ftnlen)128, (ftnlen)78);
+    wrline_(device, " ", (ftnlen)128, (ftnlen)1);
 
 /*     Next, we output the messages specified in the list */
 /*     that have been enabled. */
@@ -731,15 +731,15 @@ static integer c__1 = 1;
 	i__4[1] = 4, a__2[1] = " -- ";
 	i__4[2] = 80, a__2[2] = xmsg;
 	s_cat(tmpmsg, a__2, i__4, &c__3, (ftnlen)105);
-	wrline_(device, tmpmsg, (ftnlen)255, (ftnlen)105);
-	wrline_(device, " ", (ftnlen)255, (ftnlen)1);
+	wrline_(device, tmpmsg, (ftnlen)128, (ftnlen)105);
+	wrline_(device, " ", (ftnlen)128, (ftnlen)1);
     } else if (short__ && msgsel_("SHORT", (ftnlen)5)) {
 
 /*        Output the short error message without the explanation. */
 
 	getsms_(smsg, (ftnlen)25);
-	wrline_(device, smsg, (ftnlen)255, (ftnlen)25);
-	wrline_(device, " ", (ftnlen)255, (ftnlen)1);
+	wrline_(device, smsg, (ftnlen)128, (ftnlen)25);
+	wrline_(device, " ", (ftnlen)128, (ftnlen)1);
     } else if (expl && msgsel_("EXPLAIN", (ftnlen)7)) {
 
 /*        Obtain the explanatory text for the short error */
@@ -747,8 +747,8 @@ static integer c__1 = 1;
 
 	getsms_(smsg, (ftnlen)25);
 	expln_(smsg, xmsg, (ftnlen)25, (ftnlen)80);
-	wrline_(device, xmsg, (ftnlen)255, (ftnlen)80);
-	wrline_(device, " ", (ftnlen)255, (ftnlen)1);
+	wrline_(device, xmsg, (ftnlen)128, (ftnlen)80);
+	wrline_(device, " ", (ftnlen)128, (ftnlen)1);
     }
     if (long__ && msgsel_("LONG", (ftnlen)4)) {
 
@@ -760,7 +760,7 @@ static integer c__1 = 1;
 /*        Get the number of words in the error message. */
 
 	numwrd = wdcnt_(lmsg, (ftnlen)1840);
-	s_copy(line, " ", (ftnlen)80, (ftnlen)1);
+	s_copy(line, " ", (ftnlen)78, (ftnlen)1);
 	start = 1;
 
 /*        Format the words into output lines and display them as */
@@ -771,19 +771,19 @@ static integer c__1 = 1;
 	    nextwd_(lmsg, outwrd, lmsg, (ftnlen)1840, (ftnlen)1840, (ftnlen)
 		    1840);
 	    wrdlen = rtrim_(outwrd, (ftnlen)1840);
-	    if (start + wrdlen <= 80) {
-		s_copy(line + (start - 1), outwrd, 80 - (start - 1), (ftnlen)
+	    if (start + wrdlen <= 78) {
+		s_copy(line + (start - 1), outwrd, 78 - (start - 1), (ftnlen)
 			1840);
 		start = start + wrdlen + 1;
 	    } else {
-		if (wrdlen <= 80) {
+		if (wrdlen <= 78) {
 
 /*                 We had a short word, so just write the line and */
 /*                 continue. */
 
-		    wrline_(device, line, (ftnlen)255, (ftnlen)80);
+		    wrline_(device, line, (ftnlen)128, (ftnlen)78);
 		    start = wrdlen + 2;
-		    s_copy(line, outwrd, (ftnlen)80, (ftnlen)1840);
+		    s_copy(line, outwrd, (ftnlen)78, (ftnlen)1840);
 		} else {
 
 /*                 We got a very long word here, so we break it up and */
@@ -796,9 +796,9 @@ static integer c__1 = 1;
 /*                 is empty, we have all of the space available. */
 
 		    if (start > 1) {
-			remain = 80 - start;
+			remain = 78 - start;
 		    } else {
-			remain = 80;
+			remain = 78;
 		    }
 
 /*                 Now we stuff bits of the word into the output line */
@@ -810,9 +810,9 @@ static integer c__1 = 1;
 /*                 output lines. */
 
 		    if (remain < 10) {
-			wrline_(device, line, (ftnlen)255, (ftnlen)80);
-			s_copy(line, " ", (ftnlen)80, (ftnlen)1);
-			remain = 80;
+			wrline_(device, line, (ftnlen)128, (ftnlen)78);
+			s_copy(line, " ", (ftnlen)78, (ftnlen)1);
+			remain = 78;
 			start = 1;
 		    }
 
@@ -821,15 +821,15 @@ static integer c__1 = 1;
 /*                 part of the long word that we just wrote, left */
 /*                 justifying the remaining part before proceeding. */
 
-		    while(wrdlen > 80) {
-			s_copy(line + (start - 1), outwrd, 80 - (start - 1), 
+		    while(wrdlen > 78) {
+			s_copy(line + (start - 1), outwrd, 78 - (start - 1), 
 				remain);
-			wrline_(device, line, (ftnlen)255, (ftnlen)80);
+			wrline_(device, line, (ftnlen)128, (ftnlen)78);
 			s_copy(outwrd, " ", remain, (ftnlen)1);
 			ljust_(outwrd, outwrd, (ftnlen)1840, (ftnlen)1840);
-			s_copy(line, " ", (ftnlen)80, (ftnlen)1);
+			s_copy(line, " ", (ftnlen)78, (ftnlen)1);
 			wrdlen -= remain;
-			remain = 80;
+			remain = 78;
 			start = 1;
 		    }
 
@@ -840,7 +840,7 @@ static integer c__1 = 1;
 
 		    if (wrdlen > 0) {
 			start = wrdlen + 2;
-			s_copy(line, outwrd, (ftnlen)80, (ftnlen)1840);
+			s_copy(line, outwrd, (ftnlen)78, (ftnlen)1840);
 		    }
 		}
 	    }
@@ -848,10 +848,10 @@ static integer c__1 = 1;
 
 /*        We may need to write the remaining part of a line. */
 
-	if (s_cmp(line, " ", (ftnlen)80, (ftnlen)1) != 0) {
-	    wrline_(device, line, (ftnlen)255, (ftnlen)80);
+	if (s_cmp(line, " ", (ftnlen)78, (ftnlen)1) != 0) {
+	    wrline_(device, line, (ftnlen)128, (ftnlen)78);
 	}
-	wrline_(device, " ", (ftnlen)255, (ftnlen)1);
+	wrline_(device, " ", (ftnlen)128, (ftnlen)1);
     }
     if (trace && msgsel_("TRACEBACK", (ftnlen)9)) {
 
@@ -865,14 +865,14 @@ static integer c__1 = 1;
 /*           So, write a line telling the reader what's coming. */
 
 	    wrline_(device, "A traceback follows.  The name of the highest l"
-		    "evel module is first.", (ftnlen)255, (ftnlen)68);
+		    "evel module is first.", (ftnlen)128, (ftnlen)68);
 
 /*           While there are more names in the traceback */
 /*           representation, we stuff them into output lines and */
 /*           write the lines out when they are full. */
 
-	    s_copy(line, " ", (ftnlen)80, (ftnlen)1);
-	    remain = 80;
+	    s_copy(line, " ", (ftnlen)78, (ftnlen)1);
+	    remain = 78;
 	    i__1 = depth;
 	    for (index = 1; index <= i__1; ++index) {
 
@@ -892,7 +892,7 @@ static integer c__1 = 1;
 /*              name into the output line. */
 
 		if (index == 1) {
-		    suffix_(name__, &c__0, line, (ftnlen)32, (ftnlen)80);
+		    suffix_(name__, &c__0, line, (ftnlen)32, (ftnlen)78);
 		    remain -= length;
 		} else {
 
@@ -901,12 +901,12 @@ static integer c__1 = 1;
 /*                 the first thing on the next line. */
 
 		    if (remain >= 4) {
-			suffix_("-->", &c__1, line, (ftnlen)3, (ftnlen)80);
+			suffix_("-->", &c__1, line, (ftnlen)3, (ftnlen)78);
 			remain += -4;
 		    } else {
-			wrline_(device, line, (ftnlen)255, (ftnlen)80);
-			s_copy(line, "-->", (ftnlen)80, (ftnlen)3);
-			remain = 77;
+			wrline_(device, line, (ftnlen)128, (ftnlen)78);
+			s_copy(line, "-->", (ftnlen)78, (ftnlen)3);
+			remain = 75;
 		    }
 
 /*                 The name fits or it doesn't. If it does, just add */
@@ -914,12 +914,12 @@ static integer c__1 = 1;
 /*                 the first thing on the next line. */
 
 		    if (remain >= length) {
-			suffix_(name__, &c__1, line, (ftnlen)32, (ftnlen)80);
+			suffix_(name__, &c__1, line, (ftnlen)32, (ftnlen)78);
 			remain = remain - length - 1;
 		    } else {
-			wrline_(device, line, (ftnlen)255, (ftnlen)80);
-			s_copy(line, name__, (ftnlen)80, (ftnlen)32);
-			remain = 80 - length;
+			wrline_(device, line, (ftnlen)128, (ftnlen)78);
+			s_copy(line, name__, (ftnlen)78, (ftnlen)32);
+			remain = 78 - length;
 		    }
 		}
 	    }
@@ -929,10 +929,10 @@ static integer c__1 = 1;
 /*           names, or part of a long name.  If it does, */
 /*           we now write it out. */
 
-	    if (s_cmp(line, " ", (ftnlen)80, (ftnlen)1) != 0) {
-		wrline_(device, line, (ftnlen)255, (ftnlen)80);
+	    if (s_cmp(line, " ", (ftnlen)78, (ftnlen)1) != 0) {
+		wrline_(device, line, (ftnlen)128, (ftnlen)78);
 	    }
-	    wrline_(device, " ", (ftnlen)255, (ftnlen)1);
+	    wrline_(device, " ", (ftnlen)128, (ftnlen)1);
 	}
 
 /*        At this point, either we have output the trace */
@@ -947,9 +947,9 @@ static integer c__1 = 1;
 	for (i__ = 1; i__ <= 4; ++i__) {
 	    wrline_(device, defmsg + ((i__1 = i__ - 1) < 4 && 0 <= i__1 ? 
 		    i__1 : s_rnge("defmsg", i__1, "outmsg_", (ftnlen)971)) * 
-		    80, (ftnlen)255, (ftnlen)80);
+		    78, (ftnlen)128, (ftnlen)78);
 	}
-	wrline_(device, " ", (ftnlen)255, (ftnlen)1);
+	wrline_(device, " ", (ftnlen)128, (ftnlen)1);
     }
 
 /*     At this point, we've output all of the enabled messages */
@@ -958,7 +958,7 @@ static integer c__1 = 1;
 
 /*     Write the ending border out: */
 
-    wrline_(device, border, (ftnlen)255, (ftnlen)80);
+    wrline_(device, border, (ftnlen)128, (ftnlen)78);
     return 0;
 } /* outmsg_ */
 
--- a/src/cspice/prompt.c
+++ b/src/cspice/prompt.c
@@ -325,19 +325,13 @@ static integer c__1 = 1;
 
 
 
-
-/*     The code below should be used in the following environments: */
-
-/*     SUN/Fortran, */
-/*     HP/HP-Fortran, */
-/*     Silicon Graphics/Silicon Graphics Fortran, */
-/*     DEC Alpha-OSF/1--DEC Fortran, */
-/*     NeXT/Absoft Fortran */
-/*     PC Linux/Fort77 */
+/*     The following code should be used in the following environments: */
+/*     VAX/FORTRAN, IBM-PC/Lahey Fortran, MacIntosh/Language Systems */
+/*     Fortran */
 
     ci__1.cierr = 1;
     ci__1.ciunit = 6;
-    ci__1.cifmt = "(A,$)";
+    ci__1.cifmt = "(1H ,A,$)";
     iostat = s_wsfe(&ci__1);
     if (iostat != 0) {
 	goto L100001;
--- a/src/cspice/prtpkg.c
+++ b/src/cspice/prtpkg.c
@@ -36,7 +36,7 @@ logical prtpkg_0_(int n__, logical *short__, logical *long__, logical *expl,
     extern /* Subroutine */ int ucase_(char *, char *, ftnlen, ftnlen);
     char ltype[10];
     extern /* Subroutine */ int ljust_(char *, char *, ftnlen, ftnlen);
-    char device[255];
+    char device[128];
     extern /* Subroutine */ int getdev_(char *, ftnlen), wrline_(char *, char 
 	    *, ftnlen, ftnlen);
     char loctyp[10];
@@ -358,11 +358,11 @@ logical prtpkg_0_(int n__, logical *short__, logical *long__, logical *expl,
 
 /*     Executable Code: */
 
-    getdev_(device, (ftnlen)255);
+    getdev_(device, (ftnlen)128);
     wrline_(device, "PRTPKG:  You have called an entry point which has no ru"
 	    "n-time function; this may indicate a program bug.  Please check "
-	    "the PRTPKG documentation.  ", (ftnlen)255, (ftnlen)146);
-    wrline_(device, "SPICE(BOGUSENTRY)", (ftnlen)255, (ftnlen)17);
+	    "the PRTPKG documentation.  ", (ftnlen)128, (ftnlen)146);
+    wrline_(device, "SPICE(BOGUSENTRY)", (ftnlen)128, (ftnlen)17);
     ret_val = FALSE_;
     return ret_val;
 /* $Procedure      SETPRT ( Store Error Message Types to be Output ) */
@@ -787,9 +787,9 @@ L_msgsel:
 /*        avoid recursion, we output the messages directly, */
 /*        rather than call SIGERR. */
 
-	getdev_(device, (ftnlen)255);
-	wrline_(device, "SPICE(INVALIDMSGTYPE)", (ftnlen)255, (ftnlen)21);
-	wrline_(device, " ", (ftnlen)255, (ftnlen)1);
+	getdev_(device, (ftnlen)128);
+	wrline_(device, "SPICE(INVALIDMSGTYPE)", (ftnlen)128, (ftnlen)21);
+	wrline_(device, " ", (ftnlen)128, (ftnlen)1);
 	s_copy(loctyp, type__, (ftnlen)10, type_len);
 
 /*        Note:  What looks like a typo below isn't; there's */
@@ -801,7 +801,7 @@ L_msgsel:
 		"supplied as input; the type specifiedwas:  ";
 	i__1[1] = 10, a__1[1] = loctyp;
 	s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)96);
-	wrline_(device, ch__1, (ftnlen)255, (ftnlen)96);
+	wrline_(device, ch__1, (ftnlen)128, (ftnlen)96);
     }
     return ret_val;
 } /* prtpkg_ */
--- a/src/cspice/putdev.c
+++ b/src/cspice/putdev.c
@@ -10,11 +10,9 @@
 {
     /* Initialized data */
 
-    static char savdev[255] = "SCREEN                                       "
+    static char savdev[128] = "SCREEN                                       "
 	    "                                                                "
-	    "                                                                "
-	    "                                                                "
-	    "                  ";
+	    "                   ";
 
     /* Builtin functions */
     /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
@@ -329,7 +327,7 @@
 
 /*     Executable Code: */
 
-    s_copy(savdev, device, (ftnlen)255, device_len);
+    s_copy(savdev, device, (ftnlen)128, device_len);
     return 0;
 /* $Procedure      GETDEV ( Get Error Output Device Specification ) */
 
@@ -476,7 +474,7 @@ L_getdev:
 
 /*     Grab saved error output device specification: */
 
-    s_copy(device, savdev, device_len, (ftnlen)255);
+    s_copy(device, savdev, device_len, (ftnlen)128);
     return 0;
 } /* putdev_ */
 
--- a/src/cspice/rdtext.c
+++ b/src/cspice/rdtext.c
@@ -16,11 +16,9 @@ static integer c__1 = 1;
     /* Initialized data */
 
     static integer n = 0;
-    static char lstfil[255] = "                                             "
+    static char lstfil[128] = "                                             "
 	    "                                                                "
-	    "                                                                "
-	    "                                                                "
-	    "                  ";
+	    "                   ";
 
     /* System generated locals */
     integer i__1, i__2, i__3;
@@ -41,7 +39,7 @@ static integer c__1 = 1;
     integer unit, i__;
     extern /* Subroutine */ int chkin_(char *, ftnlen), errch_(char *, char *,
 	     ftnlen, ftnlen);
-    static integer index, units[96];
+    static integer index, units[20];
     extern integer isrchi_(integer *, integer *, integer *);
     integer number;
     extern /* Subroutine */ int sigerr_(char *, ftnlen), chkout_(char *, 
@@ -582,8 +580,8 @@ static integer c__1 = 1;
 
 /*     Are we reading the same file? */
 
-    same = s_cmp(lstfil, file, (ftnlen)255, file_len) == 0 && s_cmp(lstfil, 
-	    " ", (ftnlen)255, (ftnlen)1) != 0;
+    same = s_cmp(lstfil, file, (ftnlen)128, file_len) == 0 && s_cmp(lstfil, 
+	    " ", (ftnlen)128, (ftnlen)1) != 0;
     if (! same) {
 
 /*        We still might have the same file. For example these three */
@@ -637,7 +635,7 @@ static integer c__1 = 1;
 /*           need a free logical unit. But only if we don't */
 /*           have too many files open already. */
 
-	    if (n == 96) {
+	    if (n == 20) {
 		setmsg_("Too many files open already.", (ftnlen)28);
 		sigerr_("SPICE(TOOMANYFILESOPEN)", (ftnlen)23);
 		chkout_("RDTEXT", (ftnlen)6);
@@ -676,12 +674,12 @@ static integer c__1 = 1;
 /*               - The index of the file within the UNITS array. */
 
 	    ++n;
-	    units[(i__1 = n - 1) < 96 && 0 <= i__1 ? i__1 : s_rnge("units", 
+	    units[(i__1 = n - 1) < 20 && 0 <= i__1 ? i__1 : s_rnge("units", 
 		    i__1, "rdtext_", (ftnlen)659)] = unit;
 	    index = n;
 	}
-	s_copy(lstfil, file, (ftnlen)255, file_len);
-	lstunt = units[(i__1 = index - 1) < 96 && 0 <= i__1 ? i__1 : s_rnge(
+	s_copy(lstfil, file, (ftnlen)128, file_len);
+	lstunt = units[(i__1 = index - 1) < 20 && 0 <= i__1 ? i__1 : s_rnge(
 		"units", i__1, "rdtext_", (ftnlen)665)];
     }
 
@@ -711,15 +709,15 @@ L100001:
     *eof = iostat < 0;
     if (iostat != 0) {
 	cl__1.cerr = 0;
-	cl__1.cunit = units[(i__1 = index - 1) < 96 && 0 <= i__1 ? i__1 : 
+	cl__1.cunit = units[(i__1 = index - 1) < 20 && 0 <= i__1 ? i__1 : 
 		s_rnge("units", i__1, "rdtext_", (ftnlen)689)];
 	cl__1.csta = 0;
 	f_clos(&cl__1);
 	i__1 = n;
 	for (i__ = index + 1; i__ <= i__1; ++i__) {
-	    units[(i__2 = i__ - 2) < 96 && 0 <= i__2 ? i__2 : s_rnge("units", 
+	    units[(i__2 = i__ - 2) < 20 && 0 <= i__2 ? i__2 : s_rnge("units", 
 		    i__2, "rdtext_", (ftnlen)692)] = units[(i__3 = i__ - 1) < 
-		    96 && 0 <= i__3 ? i__3 : s_rnge("units", i__3, "rdtext_", 
+		    20 && 0 <= i__3 ? i__3 : s_rnge("units", i__3, "rdtext_", 
 		    (ftnlen)692)];
 	}
 	--n;
@@ -730,7 +728,7 @@ L100001:
 
 /*        LSTFIL is no longer valid */
 
-	s_copy(lstfil, " ", (ftnlen)255, (ftnlen)1);
+	s_copy(lstfil, " ", (ftnlen)128, (ftnlen)1);
 
 /*        If this is just the end of the file, don't report an error. */
 /*        (All files have to end sometime.) */
@@ -971,13 +969,13 @@ L_cltext:
     index = isrchi_(&number, &n, units);
     if (index > 0) {
 	cl__1.cerr = 0;
-	cl__1.cunit = units[(i__1 = index - 1) < 96 && 0 <= i__1 ? i__1 : 
+	cl__1.cunit = units[(i__1 = index - 1) < 20 && 0 <= i__1 ? i__1 : 
 		s_rnge("units", i__1, "rdtext_", (ftnlen)952)];
 	cl__1.csta = 0;
 	f_clos(&cl__1);
-	if (units[(i__1 = index - 1) < 96 && 0 <= i__1 ? i__1 : s_rnge("units"
+	if (units[(i__1 = index - 1) < 20 && 0 <= i__1 ? i__1 : s_rnge("units"
 		, i__1, "rdtext_", (ftnlen)954)] == lstunt) {
-	    s_copy(lstfil, " ", (ftnlen)255, (ftnlen)1);
+	    s_copy(lstfil, " ", (ftnlen)128, (ftnlen)1);
 	}
 
 /*        Remember all that salient information about the file? */
@@ -985,9 +983,9 @@ L_cltext:
 
 	i__1 = n;
 	for (i__ = index + 1; i__ <= i__1; ++i__) {
-	    units[(i__2 = i__ - 2) < 96 && 0 <= i__2 ? i__2 : s_rnge("units", 
+	    units[(i__2 = i__ - 2) < 20 && 0 <= i__2 ? i__2 : s_rnge("units", 
 		    i__2, "rdtext_", (ftnlen)963)] = units[(i__3 = i__ - 1) < 
-		    96 && 0 <= i__3 ? i__3 : s_rnge("units", i__3, "rdtext_", 
+		    20 && 0 <= i__3 ? i__3 : s_rnge("units", i__3, "rdtext_", 
 		    (ftnlen)963)];
 	}
 	--n;
--- a/src/cspice/stmp03.c
+++ b/src/cspice/stmp03.c
@@ -27,7 +27,7 @@
     extern /* Subroutine */ int chkin_(char *, ftnlen);
     extern doublereal dpmax_(void);
     extern /* Subroutine */ int errdp_(char *, doublereal *, ftnlen);
-    static doublereal pairs[20], lbound;
+    static doublereal pairs[18], lbound;
     extern /* Subroutine */ int sigerr_(char *, ftnlen), chkout_(char *, 
 	    ftnlen), setmsg_(char *, ftnlen);
 
@@ -563,8 +563,8 @@
 
     if (first) {
 	first = FALSE_;
-	for (i__ = 1; i__ <= 20; ++i__) {
-	    pairs[(i__1 = i__ - 1) < 20 && 0 <= i__1 ? i__1 : s_rnge("pairs", 
+	for (i__ = 1; i__ <= 18; ++i__) {
+	    pairs[(i__1 = i__ - 1) < 18 && 0 <= i__1 ? i__1 : s_rnge("pairs", 
 		    i__1, "stmp03_", (ftnlen)589)] = 1. / ((doublereal) i__ * 
 		    (doublereal) (i__ + 1));
 	}
@@ -694,8 +694,8 @@
 /*     LPAIR3 will be 18. */
 
     *c3 = 1.;
-    for (i__ = 20; i__ >= 4; i__ += -2) {
-	*c3 = 1. - *x * pairs[(i__1 = i__ - 1) < 20 && 0 <= i__1 ? i__1 : 
+    for (i__ = 18; i__ >= 4; i__ += -2) {
+	*c3 = 1. - *x * pairs[(i__1 = i__ - 1) < 18 && 0 <= i__1 ? i__1 : 
 		s_rnge("pairs", i__1, "stmp03_", (ftnlen)733)] * *c3;
     }
     *c3 = pairs[1] * *c3;
@@ -722,8 +722,8 @@
 /*     LPAIR2 will be 17. */
 
     *c2 = 1.;
-    for (i__ = 19; i__ >= 3; i__ += -2) {
-	*c2 = 1. - *x * pairs[(i__1 = i__ - 1) < 20 && 0 <= i__1 ? i__1 : 
+    for (i__ = 17; i__ >= 3; i__ += -2) {
+	*c2 = 1. - *x * pairs[(i__1 = i__ - 1) < 18 && 0 <= i__1 ? i__1 : 
 		s_rnge("pairs", i__1, "stmp03_", (ftnlen)764)] * *c2;
     }
     *c2 = pairs[0] * *c2;
--- a/src/cspice/trcpkg.c
+++ b/src/cspice/trcpkg.c
@@ -43,7 +43,7 @@ static integer c__0 = 0;
     integer first;
     extern integer rtrim_(char *, ftnlen);
     extern logical failed_(void);
-    char device[255];
+    char device[128];
     extern /* Subroutine */ int getact_(integer *);
     integer action;
     extern /* Subroutine */ int getdev_(char *, ftnlen);
@@ -780,11 +780,11 @@ L_chkin:
 		    );
 	} else {
 	    ++ovrflw;
-	    getdev_(device, (ftnlen)255);
-	    wrline_(device, "SPICE(TRACEBACKOVERFLOW)", (ftnlen)255, (ftnlen)
+	    getdev_(device, (ftnlen)128);
+	    wrline_(device, "SPICE(TRACEBACKOVERFLOW)", (ftnlen)128, (ftnlen)
 		    24);
 	    wrline_(device, "CHKIN:  The trace storage is completely full.  "
-		    "No further module names can be added.", (ftnlen)255, (
+		    "No further module names can be added.", (ftnlen)128, (
 		    ftnlen)84);
 	}
 
@@ -794,10 +794,10 @@ L_chkin:
 	    maxdep = modcnt + ovrflw;
 	}
     } else {
-	getdev_(device, (ftnlen)255);
-	wrline_(device, "SPICE(BLANKMODULENAME)", (ftnlen)255, (ftnlen)22);
+	getdev_(device, (ftnlen)128);
+	wrline_(device, "SPICE(BLANKMODULENAME)", (ftnlen)128, (ftnlen)22);
 	wrline_(device, "CHKIN:  An attempt to check in was made without sup"
-		"plying a module name.", (ftnlen)255, (ftnlen)72);
+		"plying a module name.", (ftnlen)128, (ftnlen)72);
     }
 
 /*     We're done now, so return. */
@@ -1125,8 +1125,8 @@ L_chkout:
 		    module + (first - 1), (ftnlen)32, l - (first - 1)) != 0) {
 		s_copy(tmpnam, module + (first - 1), (ftnlen)80, module_len - 
 			(first - 1));
-		getdev_(device, (ftnlen)255);
-		wrline_(device, "SPICE(NAMESDONOTMATCH)", (ftnlen)255, (
+		getdev_(device, (ftnlen)128);
+		wrline_(device, "SPICE(NAMESDONOTMATCH)", (ftnlen)128, (
 			ftnlen)22);
 /* Writing concatenation */
 		i__3[0] = 19, a__1[0] = "CHKOUT:  Caller is ";
@@ -1139,18 +1139,18 @@ L_chkout:
 			s_rnge("stack", i__1, "trcpkg_", (ftnlen)1149)) << 5);
 		i__3[4] = 1, a__1[4] = ".";
 		s_cat(ch__1, a__1, i__3, &c__5, (ftnlen)149);
-		wrline_(device, ch__1, (ftnlen)255, rtrim_(tmpnam, (ftnlen)80)
+		wrline_(device, ch__1, (ftnlen)128, rtrim_(tmpnam, (ftnlen)80)
 			 + 36 + rtrim_(stack + (((i__2 = modcnt - 1) < 100 && 
 			0 <= i__2 ? i__2 : s_rnge("stack", i__2, "trcpkg_", (
 			ftnlen)1149)) << 5), (ftnlen)32) + 1);
 	    }
 	    --modcnt;
 	} else {
-	    getdev_(device, (ftnlen)255);
-	    wrline_(device, "SPICE(TRACESTACKEMPTY)", (ftnlen)255, (ftnlen)22)
+	    getdev_(device, (ftnlen)128);
+	    wrline_(device, "SPICE(TRACESTACKEMPTY)", (ftnlen)128, (ftnlen)22)
 		    ;
 	    wrline_(device, "CHKOUT: An attempt to check out was made when n"
-		    "o modules were checked in.", (ftnlen)255, (ftnlen)73);
+		    "o modules were checked in.", (ftnlen)128, (ftnlen)73);
 	}
     } else {
 
@@ -1865,8 +1865,8 @@ L_trcnam:
 /*           Invalid index...we output the error messages directly */
 /*           in this case: */
 
-	    getdev_(device, (ftnlen)255);
-	    wrline_(device, "SPICE(INVALIDINDEX)", (ftnlen)255, (ftnlen)19);
+	    getdev_(device, (ftnlen)128);
+	    wrline_(device, "SPICE(INVALIDINDEX)", (ftnlen)128, (ftnlen)19);
 	    intstr_(index, string, (ftnlen)11);
 /* Writing concatenation */
 	    i__4[0] = 52, a__2[0] = "TRCNAM: An invalid index was input.  Th"
@@ -1874,7 +1874,7 @@ L_trcnam:
 	    i__4[1] = rtrim_(string, (ftnlen)11), a__2[1] = string;
 	    i__4[2] = 1, a__2[2] = ".";
 	    s_cat(ch__2, a__2, i__4, &c__3, (ftnlen)64);
-	    wrline_(device, ch__2, (ftnlen)255, rtrim_(string, (ftnlen)11) + 
+	    wrline_(device, ch__2, (ftnlen)128, rtrim_(string, (ftnlen)11) + 
 		    53);
 	    return 0;
 	}
@@ -1901,8 +1901,8 @@ L_trcnam:
 /*           Invalid index...we output the error messages directly */
 /*           in this case: */
 
-	    getdev_(device, (ftnlen)255);
-	    wrline_(device, "SPICE(INVALIDINDEX)", (ftnlen)255, (ftnlen)19);
+	    getdev_(device, (ftnlen)128);
+	    wrline_(device, "SPICE(INVALIDINDEX)", (ftnlen)128, (ftnlen)19);
 	    intstr_(index, string, (ftnlen)11);
 /* Writing concatenation */
 	    i__4[0] = 52, a__2[0] = "TRCNAM: An invalid index was input.  Th"
@@ -1910,7 +1910,7 @@ L_trcnam:
 	    i__4[1] = rtrim_(string, (ftnlen)11), a__2[1] = string;
 	    i__4[2] = 1, a__2[2] = ".";
 	    s_cat(ch__2, a__2, i__4, &c__3, (ftnlen)64);
-	    wrline_(device, ch__2, (ftnlen)255, rtrim_(string, (ftnlen)11) + 
+	    wrline_(device, ch__2, (ftnlen)128, rtrim_(string, (ftnlen)11) + 
 		    53);
 	    return 0;
 	}
--- a/src/cspice/writln.c
+++ b/src/cspice/writln.c
@@ -379,6 +379,14 @@ static integer c__1 = 1;
 /*     SPICELIB functions */
 
 
+/*     Local Parameters */
+
+/*     Set a value for the logical unit which represents the standard */
+/*     output device, commonly a terminal. A value of 6 is widely used, */
+/*     but the Fortran standard does not specify a value, so it may be */
+/*     different for different fortran implementations. */
+
+
 /*     Local variables */
 
 
--- a/src/cspice/wrline.c
+++ b/src/cspice/wrline.c
@@ -41,7 +41,7 @@ static integer c__2 = 2;
     extern /* Subroutine */ int ljust_(char *, char *, ftnlen, ftnlen);
     logical opened;
     extern /* Subroutine */ int fndlun_(integer *);
-    char tmpnam[255];
+    char tmpnam[128];
     integer iostat;
     extern /* Subroutine */ int suffix_(char *, integer *, char *, ftnlen, 
 	    ftnlen);
@@ -589,14 +589,14 @@ static integer c__2 = 2;
 	case 1: goto L_clline;
 	}
 
-    ljust_(device, tmpnam, device_len, (ftnlen)255);
-    ucase_(tmpnam, tmpnam, (ftnlen)255, (ftnlen)255);
+    ljust_(device, tmpnam, device_len, (ftnlen)128);
+    ucase_(tmpnam, tmpnam, (ftnlen)128, (ftnlen)128);
 
 /*     TMPNAM is now left justified and is in upper case. */
 
-    if (s_cmp(tmpnam, "NULL", (ftnlen)255, (ftnlen)4) == 0) {
+    if (s_cmp(tmpnam, "NULL", (ftnlen)128, (ftnlen)4) == 0) {
 	return 0;
-    } else if (s_cmp(tmpnam, "SCREEN", (ftnlen)255, (ftnlen)6) == 0) {
+    } else if (s_cmp(tmpnam, "SCREEN", (ftnlen)128, (ftnlen)6) == 0) {
 	ci__1.cierr = 1;
 	ci__1.ciunit = 6;
 	ci__1.cifmt = "(A)";
