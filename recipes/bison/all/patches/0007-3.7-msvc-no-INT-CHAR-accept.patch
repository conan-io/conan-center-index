--- src/ielr.c
+++ src/ielr.c
@@ -423,7 +423,7 @@
              check all predecessors' goto follows for the LHS.  */
           if (item_number_is_rule_number (ritem[s->items[item] - 2]))
             {
-              aver (lhs != accept->content->number);
+              aver (lhs != bison_accept->content->number);
               for (state **predecessor = predecessors[s->number];
                    *predecessor;
                    ++predecessor)
--- src/parse-gram.c
+++ src/parse-gram.c
@@ -1144,7 +1144,7 @@
 
     case YYSYMBOL_CHAR: /* "character literal"  */
 #line 236 "src/parse-gram.y"
-         { fputs (char_name (((*yyvaluep).CHAR)), yyo); }
+         { fputs (char_name (((*yyvaluep).CHAR_LITERAL)), yyo); }
 #line 1149 "src/parse-gram.c"
         break;
 
@@ -1180,7 +1180,7 @@
 
     case YYSYMBOL_INT: /* "integer literal"  */
 #line 253 "src/parse-gram.y"
-         { fprintf (yyo, "%d", ((*yyvaluep).INT)); }
+         { fprintf (yyo, "%d", ((*yyvaluep).INT_LITERAL)); }
 #line 1185 "src/parse-gram.c"
         break;
 
@@ -2209,13 +2209,13 @@
 
   case 12: /* prologue_declaration: "%expect" "integer literal"  */
 #line 345 "src/parse-gram.y"
-                                   { expected_sr_conflicts = (yyvsp[0].INT); }
+                                   { expected_sr_conflicts = (yyvsp[0].INT_LITERAL); }
 #line 2214 "src/parse-gram.c"
     break;
 
   case 13: /* prologue_declaration: "%expect-rr" "integer literal"  */
 #line 346 "src/parse-gram.y"
-                                   { expected_rr_conflicts = (yyvsp[0].INT); }
+                                   { expected_rr_conflicts = (yyvsp[0].INT_LITERAL); }
 #line 2220 "src/parse-gram.c"
     break;
 
@@ -2790,7 +2790,7 @@
 
   case 105: /* rhs: rhs "%dprec" "integer literal"  */
 #line 707 "src/parse-gram.y"
-    { grammar_current_rule_dprec_set ((yyvsp[0].INT), (yylsp[0])); }
+    { grammar_current_rule_dprec_set ((yyvsp[0].INT_LITERAL), (yylsp[0])); }
 #line 2795 "src/parse-gram.c"
     break;
 
@@ -2802,13 +2802,13 @@
 
   case 107: /* rhs: rhs "%expect" "integer literal"  */
 #line 711 "src/parse-gram.y"
-    { grammar_current_rule_expect_sr ((yyvsp[0].INT), (yylsp[0])); }
+    { grammar_current_rule_expect_sr ((yyvsp[0].INT_LITERAL), (yylsp[0])); }
 #line 2807 "src/parse-gram.c"
     break;
 
   case 108: /* rhs: rhs "%expect-rr" "integer literal"  */
 #line 713 "src/parse-gram.y"
-    { grammar_current_rule_expect_rr ((yyvsp[0].INT), (yylsp[0])); }
+    { grammar_current_rule_expect_rr ((yyvsp[0].INT_LITERAL), (yylsp[0])); }
 #line 2813 "src/parse-gram.c"
     break;
 
@@ -2872,9 +2872,9 @@
           location loc = muscle_percent_define_get_loc (var);
           subcomplain (&loc, complaint, _("definition of %s"), var);
         }
-      (yyval.id) = symbol_get (char_name ((yyvsp[0].CHAR)), (yylsp[0]));
+      (yyval.id) = symbol_get (char_name ((yyvsp[0].CHAR_LITERAL)), (yylsp[0]));
       symbol_class_set ((yyval.id), token_sym, (yylsp[0]), false);
-      symbol_code_set ((yyval.id), (yyvsp[0].CHAR), (yylsp[0]));
+      symbol_code_set ((yyval.id), (yyvsp[0].CHAR_LITERAL), (yylsp[0]));
     }
 #line 2880 "src/parse-gram.c"
     break;
--- src/parse-gram.h
+++ src/parse-gram.h
@@ -127,7 +127,7 @@
     BRACED_CODE = 41,              /* "{...}"  */
     BRACED_PREDICATE = 42,         /* "%?{...}"  */
     BRACKETED_ID = 43,             /* "[identifier]"  */
-    CHAR = 44,                     /* "character literal"  */
+    CHAR_LITERAL = 44,                     /* "character literal"  */
     COLON = 45,                    /* ":"  */
     EPILOGUE = 46,                 /* "epilogue"  */
     EQUAL = 47,                    /* "="  */
@@ -140,7 +140,7 @@
     TAG = 54,                      /* "<tag>"  */
     TAG_ANY = 55,                  /* "<*>"  */
     TAG_NONE = 56,                 /* "<>"  */
-    INT = 57,                      /* "integer literal"  */
+    INT_LITERAL = 57,                      /* "integer literal"  */
     PERCENT_PARAM = 58,            /* "%param"  */
     PERCENT_UNION = 59,            /* "%union"  */
     PERCENT_EMPTY = 60             /* "%empty"  */
@@ -160,7 +160,7 @@
   char* EPILOGUE;                          /* "epilogue"  */
   char* PROLOGUE;                          /* "%{...%}"  */
   code_props_type code_props_type;         /* code_props_type  */
-  int INT;                                 /* "integer literal"  */
+  int INT_LITERAL;                         /* "integer literal"  */
   int yykind_82;                           /* int.opt  */
   named_ref* yykind_95;                    /* named_ref.opt  */
   param_type PERCENT_PARAM;                /* "%param"  */
@@ -192,7 +192,7 @@
   uniqstr yykind_74;                       /* tag.opt  */
   uniqstr tag;                             /* tag  */
   uniqstr variable;                        /* variable  */
-  unsigned char CHAR;                      /* "character literal"  */
+  unsigned char CHAR_LITERAL;              /* "character literal"  */
   value_type value;                        /* value  */
 
 #line 199 "src/parse-gram.h"
--- src/reader.c
+++ src/reader.c
@@ -804,7 +804,7 @@
 
      $accept: %start $end.  */
   {
-    symbol_list *p = symbol_list_sym_new (accept, empty_loc);
+    symbol_list *p = symbol_list_sym_new (bison_accept, empty_loc);
     p->rhs_loc = grammar->rhs_loc;
     p->next = symbol_list_sym_new (startsymbol, empty_loc);
     p->next->next = symbol_list_sym_new (eoftoken, empty_loc);
--- src/reduce.c
+++ src/reduce.c
@@ -160,9 +160,9 @@
   bitset Pp = bitset_create (nrules, BITSET_FIXED);
 
   /* If the start symbol isn't useful, then nothing will be useful. */
-  if (bitset_test (N, accept->content->number - ntokens))
+  if (bitset_test (N, bison_accept->content->number - ntokens))
     {
-      bitset_set (V, accept->content->number);
+      bitset_set (V, bison_accept->content->number);
 
       while (1)
         {
@@ -301,7 +301,7 @@
       for (item_number *rhsp = rules[r].rhs; 0 <= *rhsp; ++rhsp)
         if (ISVAR (*rhsp))
           *rhsp = symbol_number_as_item_number (nterm_map[*rhsp - ntokens]);
-    accept->content->number = nterm_map[accept->content->number - ntokens];
+    bison_accept->content->number = nterm_map[bison_accept->content->number - ntokens];
   }
 
   nsyms -= nuseless_nonterminals;
@@ -381,7 +381,7 @@
     {
       reduce_print ();
 
-      if (!bitset_test (N, accept->content->number - ntokens))
+      if (!bitset_test (N, bison_accept->content->number - ntokens))
         complain (&startsymbol_loc, fatal,
                   _("start symbol %s does not derive any sentence"),
                   startsymbol->tag);
--- src/scan-gram.c
+++ src/scan-gram.c
@@ -2249,12 +2249,12 @@
 case 65:
 YY_RULE_SETUP
 #line 326 "/Users/akim/src/gnu/bison/src/scan-gram.l"
-RETURN_VALUE (INT, scan_integer (yytext, 10, *loc));
+RETURN_VALUE (INT_LITERAL, scan_integer (yytext, 10, *loc));
 	YY_BREAK
 case 66:
 YY_RULE_SETUP
 #line 327 "/Users/akim/src/gnu/bison/src/scan-gram.l"
-RETURN_VALUE (INT, scan_integer (yytext, 16, *loc));
+RETURN_VALUE (INT_LITERAL, scan_integer (yytext, 16, *loc));
 	YY_BREAK
 /* Identifiers may not start with a digit.  Yet, don't silently
      accept "1FOO" as "1 FOO".  */
@@ -2639,7 +2639,7 @@
     STRING_FINISH ();
     BEGIN INITIAL;
     loc->start = token_start;
-    val->CHAR = last_string[0];
+    val->CHAR_LITERAL = last_string[0];
 
     if (last_string[0] == '\0')
       {
@@ -2656,7 +2656,7 @@
     else
       {
         STRING_FREE ();
-        return CHAR;
+        return CHAR_LITERAL;
       }
   }
 	YY_BREAK
--- src/symtab.c
+++ src/symtab.c
@@ -59,7 +59,7 @@
 symbol *errtoken = NULL;
 symbol *undeftoken = NULL;
 symbol *eoftoken = NULL;
-symbol *accept = NULL;
+symbol *bison_accept = NULL;
 symbol *startsymbol = NULL;
 location startsymbol_loc;
 
@@ -850,9 +850,9 @@
                                    symbol_free);
 
   /* Construct the accept symbol. */
-  accept = symbol_get ("$accept", empty_loc);
-  accept->content->class = nterm_sym;
-  accept->content->number = nnterms++;
+  bison_accept = symbol_get ("$accept", empty_loc);
+  bison_accept->content->class = nterm_sym;
+  bison_accept->content->number = nnterms++;
 
   /* Construct the YYerror/"error" token */
   errtoken = symbol_get ("YYerror", empty_loc);
--- src/symtab.h
+++ src/symtab.h
@@ -245,7 +245,7 @@
 /** The genuine start symbol.
 
    $accept: start-symbol $end */
-extern symbol *accept;
+extern symbol *bison_accept;
 
 /** The user start symbol. */
 extern symbol *startsymbol;
