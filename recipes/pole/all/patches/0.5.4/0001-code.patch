diff --git a/pole/LICENSE b/pole/LICENSE
index 9242061..b62523d 100644
--- a/pole/LICENSE
+++ b/pole/LICENSE
@@ -1,6 +1,6 @@
 POLE - Portable C++ library to access OLE Storage 
 Copyright (C) 2002-2005 Ariya Hidayat. All rights reserved.
-Copyright (C) 2009 Dmitry Fedorov, Center for Bio-Image Informatics. All rights reserved.
+Copyright (C) 2009-2014 Dmitry Fedorov, Center for Bio-Image Informatics. All rights reserved.
 Copyright (C) 2010 Michel Boudinot. All rights reserved.
 
 Redistribution and use in source and binary forms, with or without 
diff --git a/pole/pole.cpp b/pole/pole.cpp
index ecb5b2f..d4f1818 100644
--- a/pole/pole.cpp
+++ b/pole/pole.cpp
@@ -10,7 +10,13 @@
    Considerable rework to allow for creation and updating of structured storage : Stephen Baum
    Copyright 2013 <srbaum@gmail.com>
 
-   Version: 0.5
+   Added GetAllStreams, reworked datatypes
+   Copyright 2013 Felix Gorny from Bitplane
+   
+   More datatype changes to allow for 32 and 64 bit code, some fixes involving incremental updates, flushing
+   Copyright 2013 <srbaum@gmail.com>
+   
+   Version: 0.5.2
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
@@ -42,13 +48,20 @@
 #include <list>
 #include <string>
 #include <vector>
+#include <queue>
+#include <limits>
 
 #include <cstring>
 
 #include "pole.h"
 
+#ifdef POLE_USE_UTF16_FILENAMES
+#include <codecvt>
+#endif //POLE_USE_UTF16_FILENAMES
+
 // enable to activate debugging output
 // #define POLE_DEBUG
+#define CACHEBUFSIZE 4096 //a presumably reasonable size for the read cache
 
 namespace POLE
 {
@@ -57,16 +70,16 @@ class Header
 {
   public:
     unsigned char id[8];       // signature, or magic identifier
-    unsigned int b_shift;          // bbat->blockSize = 1 << b_shift
-    unsigned int s_shift;          // sbat->blockSize = 1 << s_shift
-    unsigned int num_bat;          // blocks allocated for big bat
-    unsigned int dirent_start;     // starting block for directory info
-    unsigned int threshold;        // switch from small to big file (usually 4K)
-    unsigned int sbat_start;       // starting block index to store small bat
-    unsigned int num_sbat;         // blocks allocated for small bat
-    unsigned int mbat_start;       // starting block to store meta bat
-    unsigned int num_mbat;         // blocks allocated for meta bat
-    unsigned int bb_blocks[109];
+    uint64 b_shift;          // bbat->blockSize = 1 << b_shift
+    uint64 s_shift;          // sbat->blockSize = 1 << s_shift
+    uint64 num_bat;          // blocks allocated for big bat
+    uint64 dirent_start;     // starting block for directory info
+    uint64 threshold;        // switch from small to big file (usually 4K)
+    uint64 sbat_start;       // starting block index to store small bat
+    uint64 num_sbat;         // blocks allocated for small bat
+    uint64 mbat_start;       // starting block to store meta bat
+    uint64 num_mbat;         // blocks allocated for meta bat
+    uint64 bb_blocks[109];
     bool dirty;                // Needs to be written
     
     Header();
@@ -79,32 +92,32 @@ class Header
 class AllocTable
 {
   public:
-    static const unsigned int Eof;
-    static const unsigned int Avail;
-    static const unsigned int Bat;
-    static const unsigned int MetaBat;
-    unsigned blockSize;
+    static const uint64 Eof;
+    static const uint64 Avail;
+    static const uint64 Bat;
+    static const uint64 MetaBat;
+    uint64 blockSize;
     AllocTable();
     void clear();
-    unsigned int count();
-    unsigned int unusedCount();
-    void resize( unsigned int newsize );
-    void preserve( unsigned int n );
-    void set( unsigned int index, unsigned int val );
+    uint64 count();
+    uint64 unusedCount();
+    void resize( uint64 newsize );
+    void preserve( uint64 n );
+    void set( uint64 index, uint64 val );
     unsigned unused();
-    void setChain( std::vector<unsigned int> );
-    std::vector<unsigned int> follow( unsigned int start );
-    unsigned int operator[](unsigned int index );
-    void load( const unsigned char* buffer, unsigned int len );
+    void setChain( std::vector<uint64> );
+    std::vector<uint64> follow( uint64 start );
+    uint64 operator[](uint64 index );
+    void load( const unsigned char* buffer, uint64 len );
     void save( unsigned char* buffer );
-    unsigned size();
+    uint64 size();
     void debug();
     bool isDirty();
-    void markAsDirty(unsigned int dataIndex, int bigBlockSize);
-    void flush(std::vector<unsigned int> blocks, StorageIO *const io, int bigBlockSize);
+    void markAsDirty(uint64 dataIndex, int64 bigBlockSize);
+    void flush(std::vector<uint64> blocks, StorageIO *const io, int64 bigBlockSize);
   private:
-    std::vector<unsigned int> data;
-    std::vector<unsigned int> dirtyBlocks;
+    std::vector<uint64> data;
+    std::vector<uint64> dirtyBlocks;
     bool bMaybeFragmented;
     AllocTable( const AllocTable& );
     AllocTable& operator=( const AllocTable& );
@@ -113,14 +126,15 @@ class AllocTable
 class DirEntry
 {
   public:
-    bool valid;            // false if invalid (should be skipped)
-    std::string name;      // the name, not in unicode anymore 
-    bool dir;              // true if directory   
-    unsigned int size;    // size (not valid if directory)
-    unsigned int start;   // starting block
-    unsigned prev;         // previous sibling
-    unsigned next;         // next sibling
-    unsigned child;        // first child
+    DirEntry(): valid(), name(), dir(), size(), start(), prev(), next(), child() {}
+    bool valid;          // false if invalid (should be skipped)
+    std::string name;    // the name, not in unicode anymore 
+    bool dir;            // true if directory   
+    uint64 size;         // size (not valid if directory)
+    uint64 start;        // starting block
+    uint64 prev;         // previous sibling
+    uint64 next;         // next sibling
+    uint64 child;        // first child
     int compare(const DirEntry& de);
     int compare(const std::string& name2);
 
@@ -129,32 +143,32 @@ class DirEntry
 class DirTree
 {
   public:
-    static const unsigned End;
-    DirTree(int bigBlockSize);
-    void clear(int bigBlockSize);
-    inline unsigned int entryCount();
-    unsigned int unusedEntryCount();
-    DirEntry* entry( unsigned index );
-    DirEntry* entry( const std::string& name, bool create = false, int bigBlockSize = 0, StorageIO *const io = 0, int streamSize = 0);
-    int indexOf( DirEntry* e );
-    int parent( unsigned index );
-    std::string fullName( unsigned index );
-    std::vector<unsigned> children( unsigned index );
-    unsigned find_child( unsigned index, const std::string& name, unsigned &closest );
-    void load( unsigned char* buffer, unsigned len );
+    static const uint64 End;
+    DirTree(int64 bigBlockSize);
+    void clear(int64 bigBlockSize);
+    inline uint64 entryCount();
+    uint64 unusedEntryCount();
+    DirEntry* entry( uint64 index );
+    DirEntry* entry( const std::string& name, bool create = false, int64 bigBlockSize = 0, StorageIO *const io = 0, int64 streamSize = 0);
+    int64 indexOf( DirEntry* e );
+    int64 parent( uint64 index );
+    std::string fullName( uint64 index );
+    std::vector<uint64> children( uint64 index );
+    uint64 find_child( uint64 index, const std::string& name, uint64 &closest );
+    void load( unsigned char* buffer, uint64 len );
     void save( unsigned char* buffer );
-    unsigned size();
+    uint64 size();
     void debug();
     bool isDirty();
-    void markAsDirty(unsigned int dataIndex, int bigBlockSize);
-    void flush(std::vector<unsigned int> blocks, StorageIO *const io, int bigBlockSize, unsigned int sb_start, unsigned int sb_size);
-    unsigned int unused();
-    void findParentAndSib(unsigned int inIdx, const std::string& inFullName, unsigned int &parentIdx, unsigned int &sibIdx);
-    unsigned findSib(unsigned int inIdx, unsigned int sibIdx);
-    void deleteEntry(DirEntry *entry, const std::string& inFullName, int bigBlockSize);
+    void markAsDirty(uint64 dataIndex, int64 bigBlockSize);
+    void flush(std::vector<uint64> blocks, StorageIO *const io, int64 bigBlockSize, uint64 sb_start, uint64 sb_size);
+    uint64 unused();
+    void findParentAndSib(uint64 inIdx, const std::string& inFullName, uint64 &parentIdx, uint64 &sibIdx);
+    uint64 findSib(uint64 inIdx, uint64 sibIdx);
+    void deleteEntry(DirEntry *entry, const std::string& inFullName, int64 bigBlockSize);
   private:
     std::vector<DirEntry> entries;
-    std::vector<unsigned int> dirtyBlocks;
+    std::vector<uint64> dirtyBlocks;
     DirTree( const DirTree& );
     DirTree& operator=( const DirTree& );
 };
@@ -165,9 +179,9 @@ class StorageIO
     Storage* storage;         // owner
     std::string filename;     // filename
     std::fstream file;        // associated with above name
-    int result;               // result of operation
+    int64 result;               // result of operation
     bool opened;              // true if file is opened
-    unsigned long filesize;   // size of the file
+    uint64 filesize;   // size of the file
     bool writeable;           // true if the file can be modified
     
     Header* header;           // storage header 
@@ -175,9 +189,9 @@ class StorageIO
     AllocTable* bbat;         // allocation table for big blocks
     AllocTable* sbat;         // allocation table for small blocks
     
-    std::vector<unsigned int> sb_blocks; // blocks for "small" files
-    std::vector<unsigned int> mbat_blocks; // blocks for doubly indirect indices to big blocks
-    std::vector<unsigned int> mbat_data; // the additional indices to big blocks
+    std::vector<uint64> sb_blocks; // blocks for "small" files
+    std::vector<uint64> mbat_blocks; // blocks for doubly indirect indices to big blocks
+    std::vector<uint64> mbat_data; // the additional indices to big blocks
     bool mbatDirty;           // If true, mbat_blocks need to be written
        
     std::list<Stream*> streams;
@@ -197,31 +211,31 @@ class StorageIO
 
     bool deleteLeaf(DirEntry *entry, const std::string& fullName);
 
-    unsigned int loadBigBlocks( std::vector<unsigned int> blocks, unsigned char* buffer, unsigned int maxlen );
+    uint64 loadBigBlocks( std::vector<uint64> blocks, unsigned char* buffer, uint64 maxlen );
 
-    unsigned int loadBigBlock( unsigned int block, unsigned char* buffer, unsigned int maxlen );
+    uint64 loadBigBlock( uint64 block, unsigned char* buffer, uint64 maxlen );
 
-    unsigned int saveBigBlocks( std::vector<unsigned int> blocks, unsigned int offset, unsigned char* buffer, unsigned int len );
+    uint64 saveBigBlocks( std::vector<uint64> blocks, uint64 offset, unsigned char* buffer, uint64 len );
 
-    unsigned int saveBigBlock( unsigned int block, unsigned int offset, unsigned char*buffer, unsigned int len );
+    uint64 saveBigBlock( uint64 block, uint64 offset, unsigned char*buffer, uint64 len );
 
-    unsigned int loadSmallBlocks( std::vector<unsigned int> blocks, unsigned char* buffer, unsigned int maxlen );
+    uint64 loadSmallBlocks( std::vector<uint64> blocks, unsigned char* buffer, uint64 maxlen );
 
-    unsigned int loadSmallBlock( unsigned int block, unsigned char* buffer, unsigned int maxlen );
+    uint64 loadSmallBlock( uint64 block, unsigned char* buffer, uint64 maxlen );
     
-    unsigned int saveSmallBlocks( std::vector<unsigned int> blocks, unsigned int offset, unsigned char* buffer, unsigned int len, int startAtBlock = 0  );
+    uint64 saveSmallBlocks( std::vector<uint64> blocks, uint64 offset, unsigned char* buffer, uint64 len, int64 startAtBlock = 0  );
 
-    unsigned int saveSmallBlock( unsigned int block, unsigned int offset, unsigned char* buffer, unsigned int len );
+    uint64 saveSmallBlock( uint64 block, uint64 offset, unsigned char* buffer, uint64 len );
     
-    StreamIO* streamIO( const std::string& name, bool bCreate = false, int streamSize = 0 ); 
+    StreamIO* streamIO( const std::string& name, bool bCreate = false, int64 streamSize = 0 ); 
 
     void flushbbat();
 
     void flushsbat();
 
-    std::vector<unsigned int> getbbatBlocks(bool bLoading);
+    std::vector<uint64> getbbatBlocks(bool bLoading);
 
-    unsigned int ExtendFile( std::vector<unsigned int> *chain );
+    uint64 ExtendFile( std::vector<uint64> *chain );
 
     void addbbatBlock();
 
@@ -236,46 +250,59 @@ class StreamIO
 {
   public:
     StorageIO* io;
-    int entryIdx; //needed because a pointer to DirEntry will change whenever entries vector changes.
+    int64 entryIdx; //needed because a pointer to DirEntry will change whenever entries vector changes.
     std::string fullName;
     bool eof;
     bool fail;
 
     StreamIO( StorageIO* io, DirEntry* entry );
     ~StreamIO();
-    unsigned int size();
-    void setSize(unsigned int newSize);
-    void seek( unsigned int pos );
-    unsigned int tell();
-    int getch();
-    unsigned int read( unsigned char* data, unsigned int maxlen );
-    unsigned int read( unsigned int pos, unsigned char* data, unsigned int maxlen );
-    unsigned int write( unsigned char* data, unsigned int len );
-    unsigned int write( unsigned int pos, unsigned char* data, unsigned int len );
+    uint64 size();
+    void setSize(uint64 newSize);
+    void seek( uint64 pos );
+    uint64 tell();
+    int64 getch();
+    uint64 read( unsigned char* data, uint64 maxlen );
+    uint64 read( uint64 pos, unsigned char* data, uint64 maxlen );
+    uint64 write( unsigned char* data, uint64 len );
+    uint64 write( uint64 pos, unsigned char* data, uint64 len );
     void flush();
 
   private:
-    std::vector<unsigned int> blocks;
+    std::vector<uint64> blocks;
 
     // no copy or assign
     StreamIO( const StreamIO& );
     StreamIO& operator=( const StreamIO& );
 
     // pointer for read
-    unsigned int m_pos;
+    uint64 m_pos;
 
     // simple cache system to speed-up getch()
     unsigned char* cache_data;
-    unsigned int cache_size;
-    unsigned int cache_pos;
+    uint64 cache_size;
+    uint64 cache_pos;
     void updateCache();
-#define CACHEBUFSIZE 4096 //a presumably reasonable sie for the read cache
 };
 
-}; // namespace POLE
+} // namespace POLE
 
 using namespace POLE;
 
+#ifdef POLE_USE_UTF16_FILENAMES
+
+std::string POLE::UTF16toUTF8(const std::wstring &utf16) {
+    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>, wchar_t> converter;
+    return converter.to_bytes(utf16);
+}
+
+std::wstring POLE::UTF8toUTF16(const std::string &utf8) {
+    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>, wchar_t> converter;
+    return converter.from_bytes(utf8);
+}
+
+#endif //POLE_USE_UTF16_FILENAMES
+
 static void fileCheck(std::fstream &file)
 {
     bool bGood, bFail, bEof, bBad;
@@ -290,23 +317,23 @@ static void fileCheck(std::fstream &file)
 }
     
 
-static inline unsigned int readU16( const unsigned char* ptr )
+static inline uint32 readU16( const unsigned char* ptr )
 {
   return ptr[0]+(ptr[1]<<8);
 }
 
-static inline unsigned int readU32( const unsigned char* ptr )
+static inline uint32 readU32( const unsigned char* ptr )
 {
   return ptr[0]+(ptr[1]<<8)+(ptr[2]<<16)+(ptr[3]<<24);
 }
 
-static inline void writeU16( unsigned char* ptr, unsigned int data )
+static inline void writeU16( unsigned char* ptr, uint32 data )
 {
   ptr[0] = (unsigned char)(data & 0xff);
   ptr[1] = (unsigned char)((data >> 8) & 0xff);
 }
 
-static inline void writeU32( unsigned char* ptr, unsigned int data )
+static inline void writeU32( unsigned char* ptr, uint32 data )
 {
   ptr[0] = (unsigned char)(data & 0xff);
   ptr[1] = (unsigned char)((data >> 8) & 0xff);
@@ -320,22 +347,22 @@ static const unsigned char pole_magic[] =
 // =========== Header ==========
 
 Header::Header()
-{
-  b_shift = 9;      // [1EH,02] size of sectors in power-of-two; typically 9 indicating 512-byte sectors
-  s_shift = 6;      // [20H,02] size of mini-sectors in power-of-two; typically 6 indicating 64-byte mini-sectors
-  num_bat = 0;      // [2CH,04] number of SECTs in the FAT chain
-  dirent_start = 0; // [30H,04] first SECT in the directory chain
-  threshold = 4096; // [38H,04] maximum size for a mini stream; typically 4096 bytes
-  sbat_start = 0;   // [3CH,04] first SECT in the MiniFAT chain
-  num_sbat = 0;     // [40H,04] number of SECTs in the MiniFAT chain
-  mbat_start = AllocTable::Eof;   // [44H,04] first SECT in the DIFAT chain
-  num_mbat = 0;     // [48H,04] number of SECTs in the DIFAT chain
-
-  for( unsigned i = 0; i < 8; i++ )
+:   b_shift(9),                 // [1EH,02] size of sectors in power-of-two; typically 9 indicating 512-byte sectors
+    s_shift(6),                 // [20H,02] size of mini-sectors in power-of-two; typically 6 indicating 64-byte mini-sectors
+    num_bat(0),                 // [2CH,04] number of SECTs in the FAT chain
+    dirent_start(0),            // [30H,04] first SECT in the directory chain
+    threshold(4096),            // [38H,04] maximum size for a mini stream; typically 4096 bytes
+    sbat_start(0),              // [3CH,04] first SECT in the MiniFAT chain
+    num_sbat(0),                // [40H,04] number of SECTs in the MiniFAT chain
+    mbat_start(AllocTable::Eof),// [44H,04] first SECT in the DIFAT chain
+    num_mbat(0),                // [48H,04] number of SECTs in the DIFAT chain
+    dirty(true)	
+
+{
+  for( unsigned int i = 0; i < 8; i++ )
     id[i] = pole_magic[i];  
-  for( unsigned i=0; i<109; i++ )
+  for( unsigned int i=0; i<109; i++ )
     bb_blocks[i] = AllocTable::Avail;
-  dirty = true;
 }
 
 bool Header::valid()
@@ -362,11 +389,11 @@ void Header::load( const unsigned char* buffer ) {
   mbat_start   = readU32( buffer + 0x44 ); // [44H,04] first SECT in the DIFAT chain
   num_mbat     = readU32( buffer + 0x48 ); // [48H,04] number of SECTs in the DIFAT chain
   
-  for( unsigned i = 0; i < 8; i++ )
+  for( unsigned int i = 0; i < 8; i++ )
     id[i] = buffer[i]; 
 
   // [4CH,436] the SECTs of first 109 FAT sectors
-  for( unsigned i=0; i<109; i++ )
+  for( unsigned int i=0; i<109; i++ )
     bb_blocks[i] = readU32( buffer + 0x4C+i*4 );
   dirty = false;
 }
@@ -381,18 +408,18 @@ void Header::save( unsigned char* buffer )
   writeU16( buffer + 24, 0x003e );        // revision ?
   writeU16( buffer + 26, 3 );             // version ?
   writeU16( buffer + 28, 0xfffe );        // unknown
-  writeU16( buffer + 0x1e, b_shift );
-  writeU16( buffer + 0x20, s_shift );
-  writeU32( buffer + 0x2c, num_bat );
-  writeU32( buffer + 0x30, dirent_start );
-  writeU32( buffer + 0x38, threshold );
-  writeU32( buffer + 0x3c, sbat_start );
-  writeU32( buffer + 0x40, num_sbat );
-  writeU32( buffer + 0x44, mbat_start );
-  writeU32( buffer + 0x48, num_mbat );
+  writeU16( buffer + 0x1e, (uint32) b_shift );
+  writeU16( buffer + 0x20, (uint32) s_shift );
+  writeU32( buffer + 0x2c, (uint32) num_bat );
+  writeU32( buffer + 0x30, (uint32) dirent_start );
+  writeU32( buffer + 0x38, (uint32) threshold );
+  writeU32( buffer + 0x3c, (uint32) sbat_start );
+  writeU32( buffer + 0x40, (uint32) num_sbat );
+  writeU32( buffer + 0x44, (uint32) mbat_start );
+  writeU32( buffer + 0x48, (uint32) num_mbat );
   
-  for( unsigned i=0; i<109; i++ )
-    writeU32( buffer + 0x4C+i*4, bb_blocks[i] );
+  for( unsigned int i=0; i<109; i++ )
+    writeU32( buffer + 0x4C+i*4, (uint32) bb_blocks[i] );
   dirty = false;
 }
 
@@ -409,37 +436,40 @@ void Header::debug()
   std::cout << "mbat_start " << mbat_start << std::endl;
   std::cout << "num_mbat " << num_mbat << std::endl;
   
-  unsigned s = (num_bat<=109) ? num_bat : 109;
+  uint64 s = (num_bat<=109) ? num_bat : 109;
   std::cout << "bat blocks: ";
-  for( unsigned i = 0; i < s; i++ )
+  for( uint64 i = 0; i < s; i++ )
     std::cout << bb_blocks[i] << " ";
   std::cout << std::endl;
 }
  
 // =========== AllocTable ==========
 
-const unsigned AllocTable::Avail = 0xffffffff;
-const unsigned AllocTable::Eof = 0xfffffffe;
-const unsigned AllocTable::Bat = 0xfffffffd;
-const unsigned AllocTable::MetaBat = 0xfffffffc;
+const uint64 AllocTable::Avail = 0xffffffff;
+const uint64 AllocTable::Eof = 0xfffffffe;
+const uint64 AllocTable::Bat = 0xfffffffd;
+const uint64 AllocTable::MetaBat = 0xfffffffc;
 
 AllocTable::AllocTable()
+:   blockSize(4096),
+    data(),
+    dirtyBlocks(),
+    bMaybeFragmented(true)
 {
-  blockSize = 4096;
   // initial size
   resize( 128 );
 }
 
-unsigned int AllocTable::count()
+uint64 AllocTable::count()
 {
-  return (unsigned int) data.size();
+  return static_cast<uint64>(data.size());
 }
 
-unsigned int AllocTable::unusedCount()
+uint64 AllocTable::unusedCount()
 {
-    unsigned int maxIdx = count();
-    unsigned int nFound = 0;
-    for (unsigned int idx = 0; idx < maxIdx; idx++)
+    uint64 maxIdx = count();
+    uint64 nFound = 0;
+    for (uint64 idx = 0; idx < maxIdx; idx++)
     {
         if( data[idx] == Avail )
             nFound++;
@@ -447,31 +477,31 @@ unsigned int AllocTable::unusedCount()
     return nFound;
 }
 
-void AllocTable::resize( unsigned int newsize )
+void AllocTable::resize( uint64 newsize )
 {
-  unsigned int oldsize = (unsigned int) data.size();
+  uint64 oldsize = static_cast<uint64>(data.size());
   data.resize( newsize );
   if( newsize > oldsize )
-    for( unsigned i = oldsize; i<newsize; i++ )
+    for( uint64 i = oldsize; i<newsize; i++ )
       data[i] = Avail;
 }
 
 // make sure there're still free blocks
-void AllocTable::preserve( unsigned int n )
+void AllocTable::preserve( uint64 n )
 {
-  std::vector<unsigned int> pre;
+  std::vector<uint64> pre;
   for( unsigned i=0; i < n; i++ )
     pre.push_back( unused() );
 }
 
-unsigned int AllocTable::operator[]( unsigned int index )
+uint64 AllocTable::operator[]( uint64 index )
 {
-  unsigned int result;
+  uint64 result;
   result = data[index];
   return result;
 }
 
-void AllocTable::set( unsigned int index, unsigned int value )
+void AllocTable::set( uint64 index, uint64 value )
 {
   if( index >= count() ) resize( index + 1);
   data[ index ] = value;
@@ -479,7 +509,7 @@ void AllocTable::set( unsigned int index, unsigned int value )
       bMaybeFragmented = true;
 }
 
-void AllocTable::setChain( std::vector<unsigned int> chain )
+void AllocTable::setChain( std::vector<uint64> chain )
 {
   if( chain.size() )
   {
@@ -490,18 +520,18 @@ void AllocTable::setChain( std::vector<unsigned int> chain )
 }
 
 // follow 
-std::vector<unsigned int> AllocTable::follow( unsigned int start )
+std::vector<uint64> AllocTable::follow( uint64 start )
 {
-  std::vector<unsigned int> chain;
+  std::vector<uint64> chain;
 
   if( start >= count() ) return chain; 
 
-  unsigned int p = start;
+  uint64 p = start;
   while( p < count() )
   {
-    if( p == (unsigned int)Eof ) break;
-    if( p == (unsigned int)Bat ) break;
-    if( p == (unsigned int)MetaBat ) break;
+    if( p == (uint64)Eof ) break;
+    if( p == (uint64)Bat ) break;
+    if( p == (uint64)MetaBat ) break;
     if( p >= count() ) break;
     chain.push_back( p );
     if( data[p] >= count() ) break;
@@ -529,7 +559,7 @@ unsigned AllocTable::unused()
   return block;      
 }
 
-void AllocTable::load( const unsigned char* buffer, unsigned len )
+void AllocTable::load( const unsigned char* buffer, uint64 len )
 {
   resize( len / 4 );
   for( unsigned i = 0; i < count(); i++ )
@@ -537,15 +567,15 @@ void AllocTable::load( const unsigned char* buffer, unsigned len )
 }
 
 // return space required to save this dirtree
-unsigned int AllocTable::size()
+uint64 AllocTable::size()
 {
   return count() * 4;
 }
 
 void AllocTable::save( unsigned char* buffer )
 {
-  for( unsigned i = 0; i < count(); i++ )
-    writeU32( buffer + i*4, data[i] );
+  for( uint64 i = 0; i < count(); i++ )
+    writeU32( buffer + i*4, (uint32) data[i] );
 }
 
 bool AllocTable::isDirty()
@@ -553,10 +583,10 @@ bool AllocTable::isDirty()
     return (dirtyBlocks.size() > 0);
 }
 
-void AllocTable::markAsDirty(unsigned int dataIndex, int bigBlockSize)
+void AllocTable::markAsDirty(uint64 dataIndex, int64 bigBlockSize)
 {
-    unsigned int dbidx = dataIndex / (bigBlockSize / sizeof(unsigned int));
-    for (unsigned int idx = 0; idx < dirtyBlocks.size(); idx++)
+    uint64 dbidx = dataIndex / (bigBlockSize / sizeof(uint32));
+    for (uint64 idx = 0; idx < static_cast<uint64>(dirtyBlocks.size()); idx++)
     {
         if (dirtyBlocks[idx] == dbidx)
             return;
@@ -564,14 +594,14 @@ void AllocTable::markAsDirty(unsigned int dataIndex, int bigBlockSize)
     dirtyBlocks.push_back(dbidx);
 }
 
-void AllocTable::flush(std::vector<unsigned int> blocks, StorageIO *const io, int bigBlockSize)
+void AllocTable::flush(std::vector<uint64> blocks, StorageIO *const io, int64 bigBlockSize)
 {
     unsigned char *buffer = new unsigned char[bigBlockSize * blocks.size()];
     save(buffer);
-    for (unsigned int idx = 0; idx < blocks.size(); idx++)
+    for (uint64 idx = 0; idx < static_cast<uint64>(blocks.size()); idx++)
     {
         bool bDirty = false;
-        for (unsigned int idx2 = 0; idx2 < dirtyBlocks.size(); idx2++)
+        for (uint64 idx2 = 0; idx2 < static_cast<uint64>(dirtyBlocks.size()); idx2++)
         {
             if (dirtyBlocks[idx2] == idx)
             {
@@ -623,14 +653,16 @@ int DirEntry::compare(const std::string& name2)
 
 // =========== DirTree ==========
 
-const unsigned DirTree::End = 0xffffffff;
+const uint64 DirTree::End = 0xffffffff;
 
-DirTree::DirTree(int bigBlockSize)
+DirTree::DirTree(int64 bigBlockSize)
+:   entries(),
+    dirtyBlocks()
 {
   clear(bigBlockSize);
 }
 
-void DirTree::clear(int bigBlockSize)
+void DirTree::clear(int64 bigBlockSize)
 {
   // leave only root entry
   entries.resize( 1 );
@@ -645,15 +677,15 @@ void DirTree::clear(int bigBlockSize)
   markAsDirty(0, bigBlockSize);
 }
 
-inline unsigned int DirTree::entryCount()
+inline uint64 DirTree::entryCount()
 {
-  return (unsigned int) entries.size();
+  return entries.size();
 }
 
-unsigned int DirTree::unusedEntryCount()
+uint64 DirTree::unusedEntryCount()
 {
-    unsigned int nFound = 0;
-    for (unsigned idx = 0; idx < entryCount(); idx++)
+    uint64 nFound = 0;
+    for (uint64 idx = 0; idx < entryCount(); idx++)
     {
         if (!entries[idx].valid)
             nFound++;
@@ -661,27 +693,27 @@ unsigned int DirTree::unusedEntryCount()
     return nFound;
 }
 
-DirEntry* DirTree::entry( unsigned index )
+DirEntry* DirTree::entry( uint64 index )
 {
   if( index >= entryCount() ) return (DirEntry*) 0;
   return &entries[ index ];
 }
 
-int DirTree::indexOf( DirEntry* e )
+int64 DirTree::indexOf( DirEntry* e )
 {
-  for( unsigned i = 0; i < entryCount(); i++ )
+  for( uint64 i = 0; i < entryCount(); i++ )
     if( entry( i ) == e ) return i;
     
   return -1;
 }
 
-int DirTree::parent( unsigned index )
+int64 DirTree::parent( uint64 index )
 {
   // brute-force, basically we iterate for each entries, find its children
   // and check if one of the children is 'index'
-  for( unsigned j=0; j<entryCount(); j++ )
+  for( uint64 j=0; j<entryCount(); j++ )
   {
-    std::vector<unsigned> chi = children( j );
+    std::vector<uint64> chi = children( j );
     for( unsigned i=0; i<chi.size();i++ )
       if( chi[i] == index )
         return j;
@@ -690,14 +722,14 @@ int DirTree::parent( unsigned index )
   return -1;
 }
 
-std::string DirTree::fullName( unsigned index )
+std::string DirTree::fullName( uint64 index )
 {
   // don't use root name ("Root Entry"), just give "/"
   if( index == 0 ) return "/";
 
   std::string result = entry( index )->name;
   result.insert( 0,  "/" );
-  int p = parent( index );
+  uint64 p = parent( index );
   DirEntry * _entry = 0;
   while( p > 0 )
   {
@@ -717,7 +749,7 @@ std::string DirTree::fullName( unsigned index )
 // given a fullname (e.g "/ObjectPool/_1020961869"), find the entry
 // if not found and create is false, return 0
 // if create is true, a new entry is returned
-DirEntry* DirTree::entry( const std::string& name, bool create, int bigBlockSize, StorageIO *const io, int streamSize)
+DirEntry* DirTree::entry( const std::string& name, bool create, int64 bigBlockSize, StorageIO *const io, int64 streamSize)
 {
    if( !name.length() ) return (DirEntry*)0;
  
@@ -740,7 +772,7 @@ DirEntry* DirTree::entry( const std::string& name, bool create, int bigBlockSize
    }
   
    // start from root 
-   int index = 0 ;
+   int64 index = 0 ;
 
    // trace one by one   
    std::list<std::string>::iterator it; 
@@ -749,7 +781,7 @@ DirEntry* DirTree::entry( const std::string& name, bool create, int bigBlockSize
    {
      // find among the children of index
      levelsLeft--;
-     unsigned child = 0;
+     uint64 child = 0;
 
      
      /*
@@ -767,7 +799,7 @@ DirEntry* DirTree::entry( const std::string& name, bool create, int bigBlockSize
      }
      */
      // dima: performance optimisation of the previous
-     unsigned closest = End;
+     uint64 closest = End;
      child = find_child( index, *it, closest );
      
      // traverse to the child
@@ -778,7 +810,7 @@ DirEntry* DirTree::entry( const std::string& name, bool create, int bigBlockSize
        if( !create || !io->writeable) return (DirEntry*)0;
        
        // create a new entry
-       unsigned parent = index;
+       uint64 parent2 = index;
        index = unused();
        DirEntry* e = entry( index );
        e->valid = true;
@@ -793,9 +825,9 @@ DirEntry* DirTree::entry( const std::string& name, bool create, int bigBlockSize
        if (closest == End)
        {
            e->prev = End;
-           e->next = entry(parent)->child;
-           entry(parent)->child = index;
-           markAsDirty(parent, bigBlockSize);
+           e->next = entry(parent2)->child;
+           entry(parent2)->child = index;
+           markAsDirty(parent2, bigBlockSize);
        }
        else
        {
@@ -815,20 +847,20 @@ DirEntry* DirTree::entry( const std::string& name, bool create, int bigBlockSize
            markAsDirty(closest, bigBlockSize);
        }
        markAsDirty(index, bigBlockSize);
-       unsigned int bbidx = index / (bigBlockSize / 128);
-       std::vector <unsigned int> blocks = io->bbat->follow(io->header->dirent_start);
+       uint64 bbidx = index / (bigBlockSize / 128);
+       std::vector <uint64> blocks = io->bbat->follow(io->header->dirent_start);
        while (blocks.size() <= bbidx)
        {
-           unsigned int nblock = io->bbat->unused();
+           uint64 nblock = io->bbat->unused();
            if (blocks.size() > 0)
            {
-               io->bbat->set(blocks[(unsigned int)blocks.size()-1], nblock);
-               io->bbat->markAsDirty(blocks[blocks.size()-1], bigBlockSize);
+               io->bbat->set(blocks[static_cast<uint64>(blocks.size())-1], nblock);
+               io->bbat->markAsDirty(blocks[static_cast<uint64>(blocks.size())-1], bigBlockSize);
            }
            io->bbat->set(nblock, AllocTable::Eof);
            io->bbat->markAsDirty(nblock, bigBlockSize);
            blocks.push_back(nblock);
-           unsigned int bbidx = nblock / (io->bbat->blockSize / sizeof(unsigned int));
+           uint64 bbidx = nblock / (io->bbat->blockSize / sizeof(uint64));
            while (bbidx >= io->header->num_bat)
                io->addbbatBlock();
        }
@@ -839,10 +871,11 @@ DirEntry* DirTree::entry( const std::string& name, bool create, int bigBlockSize
 }
 
 // helper function: recursively find siblings of index
-void dirtree_find_siblings( DirTree* dirtree, std::vector<unsigned>& result, 
-  unsigned index )
+void dirtree_find_siblings( DirTree* dirtree, std::vector<uint64>& result, 
+  uint64 index )
 {
     DirEntry* e = dirtree->entry( index );
+    if (!e) return;
     if (e->prev != DirTree::End)
         dirtree_find_siblings(dirtree, result, e->prev);
     result.push_back(index);
@@ -850,9 +883,9 @@ void dirtree_find_siblings( DirTree* dirtree, std::vector<unsigned>& result,
         dirtree_find_siblings(dirtree, result, e->next);
 }
 
-std::vector<unsigned> DirTree::children( unsigned index )
+std::vector<uint64> DirTree::children( uint64 index )
 {
-  std::vector<unsigned> result;
+  std::vector<uint64> result;
   
   DirEntry* e = entry( index );
   if( e ) if( e->valid && e->child < entryCount() )
@@ -861,9 +894,9 @@ std::vector<unsigned> DirTree::children( unsigned index )
   return result;
 }
 
-unsigned dirtree_find_sibling( DirTree* dirtree, unsigned index, const std::string& name, unsigned &closest ) {
+uint64 dirtree_find_sibling( DirTree* dirtree, uint64 index, const std::string& name, uint64& closest ) {
 
-    unsigned count = dirtree->entryCount();
+    uint64 count = dirtree->entryCount();
     DirEntry* e = dirtree->entry( index );
     if (!e || !e->valid) return 0;
     int cval = e->compare(name);
@@ -883,9 +916,9 @@ unsigned dirtree_find_sibling( DirTree* dirtree, unsigned index, const std::stri
     return 0;
 }
 
-unsigned DirTree::find_child( unsigned index, const std::string& name, unsigned& closest ) {
+uint64 DirTree::find_child( uint64 index, const std::string& name, uint64& closest ) {
 
-  unsigned count = entryCount();
+  uint64 count = entryCount();
   DirEntry* p = entry( index );
   if (p && p->valid && p->child < count )
     return dirtree_find_sibling( this, p->child, name, closest );
@@ -893,13 +926,13 @@ unsigned DirTree::find_child( unsigned index, const std::string& name, unsigned&
   return 0;
 }
 
-void DirTree::load( unsigned char* buffer, unsigned size )
+void DirTree::load( unsigned char* buffer, uint64 size )
 {
   entries.clear();
   
-  for( unsigned i = 0; i < size/128; i++ )
+  for( uint64 i = 0; i < size/128; i++ )
   {
-    unsigned p = i * 128;
+    uint64 p = i * 128;
     
     // would be < 32 if first char in the name isn't printable
     unsigned prefix = 32;
@@ -940,7 +973,7 @@ void DirTree::load( unsigned char* buffer, unsigned size )
 }
 
 // return space required to save this dirtree
-unsigned DirTree::size()
+uint64 DirTree::size()
 {
   return entryCount() * 128;
 }
@@ -952,18 +985,18 @@ void DirTree::save( unsigned char* buffer )
   // root is fixed as "Root Entry"
   DirEntry* root = entry( 0 );
   std::string name = "Root Entry";
-  for( unsigned j = 0; j < name.length(); j++ )
+  for( unsigned int j = 0; j < name.length(); j++ )
     buffer[ j*2 ] = name[j];
-  writeU16( buffer + 0x40, (int) name.length()*2 + 2 );
+  writeU16( buffer + 0x40, static_cast<uint32>(name.length()*2 + 2) );
   writeU32( buffer + 0x74, 0xffffffff );
   writeU32( buffer + 0x78, 0 );
   writeU32( buffer + 0x44, 0xffffffff );
   writeU32( buffer + 0x48, 0xffffffff );
-  writeU32( buffer + 0x4c, root->child );
+  writeU32( buffer + 0x4c, (uint32) root->child );
   buffer[ 0x42 ] = 5;
   //buffer[ 0x43 ] = 1; 
 
-  for( unsigned i = 1; i < entryCount(); i++ )
+  for( unsigned int i = 1; i < entryCount(); i++ )
   {
     DirEntry* e = entry( i );
     if( !e ) continue;
@@ -982,12 +1015,12 @@ void DirTree::save( unsigned char* buffer )
     for( unsigned j = 0; j < name.length(); j++ )
       buffer[ i*128 + j*2 ] = name[j];
 
-    writeU16( buffer + i*128 + 0x40, (int) name.length()*2 + 2 );
-    writeU32( buffer + i*128 + 0x74, e->start );
-    writeU32( buffer + i*128 + 0x78, e->size );
-    writeU32( buffer + i*128 + 0x44, e->prev );
-    writeU32( buffer + i*128 + 0x48, e->next );
-    writeU32( buffer + i*128 + 0x4c, e->child );
+    writeU16( buffer + i*128 + 0x40, static_cast<uint32>(name.length()*2 + 2) );
+    writeU32( buffer + i*128 + 0x74, (uint32) e->start );
+    writeU32( buffer + i*128 + 0x78, (uint32) e->size );
+    writeU32( buffer + i*128 + 0x44, (uint32) e->prev );
+    writeU32( buffer + i*128 + 0x48, (uint32) e->next );
+    writeU32( buffer + i*128 + 0x4c, (uint32) e->child );
     if (!e->valid)
         buffer[ i*128 + 0x42 ] = 0; //STGTY_INVALID
     else
@@ -1002,10 +1035,10 @@ bool DirTree::isDirty()
 }
 
 
-void DirTree::markAsDirty(unsigned int dataIndex, int bigBlockSize)
+void DirTree::markAsDirty(uint64 dataIndex, int64 bigBlockSize)
 {
-    unsigned int dbidx = dataIndex / (bigBlockSize / 128);
-    for (unsigned int idx = 0; idx < dirtyBlocks.size(); idx++)
+    uint64 dbidx = dataIndex / (bigBlockSize / 128);
+    for (uint64 idx = 0; idx < static_cast<uint64>(dirtyBlocks.size()); idx++)
     {
         if (dirtyBlocks[idx] == dbidx)
             return;
@@ -1013,17 +1046,17 @@ void DirTree::markAsDirty(unsigned int dataIndex, int bigBlockSize)
     dirtyBlocks.push_back(dbidx);
 }
 
-void DirTree::flush(std::vector<unsigned int> blocks, StorageIO *const io, int bigBlockSize, unsigned int sb_start, unsigned int sb_size)
+void DirTree::flush(std::vector<uint64> blocks, StorageIO *const io, int64 bigBlockSize, uint64 sb_start, uint64 sb_size)
 {
-    unsigned int bufLen = size();
+    uint64 bufLen = size();
     unsigned char *buffer = new unsigned char[bufLen];
     save(buffer);
-    writeU32( buffer + 0x74, sb_start );
-    writeU32( buffer + 0x78, sb_size );
-    for (unsigned int idx = 0; idx < blocks.size(); idx++)
+    writeU32( buffer + 0x74, (uint32) sb_start );
+    writeU32( buffer + 0x78, (uint32) sb_size );
+    for (uint64 idx = 0; idx < static_cast<uint64>(blocks.size()); idx++)
     {
         bool bDirty = false;
-        for (unsigned int idx2 = 0; idx2 < dirtyBlocks.size(); idx2++)
+        for (uint64 idx2 = 0; idx2 < static_cast<uint64>(dirtyBlocks.size()); idx2++)
         {
             if (dirtyBlocks[idx2] == idx)
             {
@@ -1031,8 +1064,8 @@ void DirTree::flush(std::vector<unsigned int> blocks, StorageIO *const io, int b
                 break;
             }
         }
-        unsigned int bytesToWrite = bigBlockSize;
-        unsigned int pos = bigBlockSize*idx;
+        uint64 bytesToWrite = bigBlockSize;
+        uint64 pos = bigBlockSize*idx;
         if ((bufLen - pos) < bytesToWrite)
             bytesToWrite = bufLen - pos;
         if (bDirty)
@@ -1042,9 +1075,9 @@ void DirTree::flush(std::vector<unsigned int> blocks, StorageIO *const io, int b
     delete[] buffer;
 }
 
-unsigned DirTree::unused()
+uint64 DirTree::unused()
 {
-    for (unsigned idx = 0; idx < entryCount(); idx++)
+    for (uint64 idx = 0; idx < static_cast<uint64>(entryCount()); idx++)
     {
         if (!entries[idx].valid)
             return idx;
@@ -1057,7 +1090,7 @@ unsigned DirTree::unused()
 // Then look for a sibling dirEntry that points to inIdx. In some circumstances, the dirEntry at inIdx will be the direct child
 // of the parent, in which case sibIdx will be returned as 0. A failure is indicated if both parentIdx and sibIdx are returned as 0.
 
-void DirTree::findParentAndSib(unsigned inIdx, const std::string& inFullName, unsigned &parentIdx, unsigned &sibIdx)
+void DirTree::findParentAndSib(uint64 inIdx, const std::string& inFullName, uint64& parentIdx, uint64& sibIdx)
 {
     sibIdx = 0;
     parentIdx = 0;
@@ -1076,17 +1109,17 @@ void DirTree::findParentAndSib(unsigned inIdx, const std::string& inFullName, un
     if (lastSlash == 0)
         lastSlash = 1; //leave root
     parentName = parentName.substr(0, lastSlash);
-    DirEntry *parent = entry(parentName);
-    parentIdx = indexOf(parent);
-    if (parent->child == inIdx)
+    DirEntry *parent2 = entry(parentName);
+    parentIdx = indexOf(parent2);
+    if (parent2->child == inIdx)
         return; //successful return, no sibling points to inIdx
-    sibIdx = findSib(inIdx, parent->child);
+    sibIdx = findSib(inIdx, parent2->child);
 }
 
 // Utility function to get the index of the sibling dirEntry which points to inIdx. It is the responsibility of the original caller
 // to start with the root sibling - i.e., sibIdx should be pointed to by the parent node's child.
 
-unsigned DirTree::findSib(unsigned inIdx, unsigned sibIdx)
+uint64 DirTree::findSib(uint64 inIdx, uint64 sibIdx)
 {
     DirEntry *sib = entry(sibIdx);
     if (!sib || !sib->valid)
@@ -1101,14 +1134,14 @@ unsigned DirTree::findSib(unsigned inIdx, unsigned sibIdx)
         return findSib(inIdx, sib->next);
 }
 
-void DirTree::deleteEntry(DirEntry *dirToDel, const std::string& inFullName, int bigBlockSize)
+void DirTree::deleteEntry(DirEntry *dirToDel, const std::string& inFullName, int64 bigBlockSize)
 {
-    unsigned parentIdx;
-    unsigned sibIdx;
-    unsigned inIdx = indexOf(dirToDel);
-    unsigned nEntries = entryCount();
+    uint64 parentIdx;
+    uint64 sibIdx;
+    uint64 inIdx = indexOf(dirToDel);
+    uint64 nEntries = entryCount();
     findParentAndSib(inIdx, inFullName, parentIdx, sibIdx);
-    unsigned replIdx;
+    uint64 replIdx;
     if (!dirToDel->next || dirToDel->next > nEntries)
         replIdx = dirToDel->prev;
     else
@@ -1123,9 +1156,9 @@ void DirTree::deleteEntry(DirEntry *dirToDel, const std::string& inFullName, int
         else
         {
             DirEntry *smlSib = sibNext;
-            int smlIdx = dirToDel->next;
+            int64 smlIdx = dirToDel->next;
             DirEntry *smlrSib;
-            int smlrIdx = -1;
+            int64 smlrIdx = -1;
             for ( ; ; )
             {
                 smlrIdx = smlSib->prev;
@@ -1190,21 +1223,25 @@ void DirTree::debug()
 // =========== StorageIO ==========
 
 StorageIO::StorageIO( Storage* st, const char* fname )
-{
-  storage = st;
-  filename = fname;
-  result = Storage::Ok;
-  opened = false;
-  
-  header = new Header();
-  bbat = new AllocTable();
-  sbat = new AllocTable();
-  
-  filesize = 0;
-  bbat->blockSize = 1 << header->b_shift;
-  sbat->blockSize = 1 << header->s_shift;
-  dirtree = new DirTree(bbat->blockSize);
-  writeable = false;
+: storage(st),        
+  filename(fname),
+  file(), 
+  result(Storage::Ok),        
+  opened(false),        
+  filesize(0),        
+  writeable(false),        
+  header(new Header()),        
+    dirtree(new DirTree( (uint64_t) 1 << header->b_shift)),
+  bbat(new AllocTable()),        
+  sbat(new AllocTable()),
+  sb_blocks(),
+  mbat_blocks(),
+  mbat_data(),
+  mbatDirty(),
+  streams()
+{
+  bbat->blockSize = (uint64) 1 << header->b_shift;
+  sbat->blockSize = (uint64) 1 << header->s_shift;
 }
 
 StorageIO::~StorageIO()
@@ -1239,20 +1276,29 @@ bool StorageIO::open(bool bWriteAccess, bool bCreate)
 void StorageIO::load(bool bWriteAccess)
 {
   unsigned char* buffer = 0;
-  unsigned int buflen = 0;
-  std::vector<unsigned int> blocks;
+  uint64 buflen = 0;
+  std::vector<uint64> blocks;
   
   // open the file, check for error
   result = Storage::OpenFailed;
+
+#if defined(POLE_USE_UTF16_FILENAMES)
+  if (bWriteAccess)
+      file.open(UTF8toUTF16(filename).c_str(), std::ios::binary | std::ios::in | std::ios::out);
+  else
+      file.open(UTF8toUTF16(filename).c_str(), std::ios::binary | std::ios::in);
+#else
   if (bWriteAccess)
-      file.open( filename.c_str(), std::ios::binary | std::ios::in | std::ios::out );
+      file.open(filename.c_str(), std::ios::binary | std::ios::in | std::ios::out);
   else
-      file.open( filename.c_str(), std::ios::binary | std::ios::in );
+      file.open(filename.c_str(), std::ios::binary | std::ios::in);
+#endif //defined(POLE_USE_UTF16_FILENAMES) && defined(POLE_WIN)
+
   if( !file.good() ) return;
   
   // find size of input file
-  file.seekg( (unsigned int) 0, std::ios::end );
-  filesize = (unsigned long)file.tellg();
+  file.seekg(0, std::ios::end );
+  filesize = static_cast<uint64>(file.tellg());
 
   // load header
   buffer = new unsigned char[512];
@@ -1274,13 +1320,13 @@ void StorageIO::load(bool bWriteAccess)
   if( header->threshold != 4096 ) return;
 
   // important block size
-  bbat->blockSize = 1 << header->b_shift;
-  sbat->blockSize = 1 << header->s_shift;
+  bbat->blockSize = (uint64) 1 << header->b_shift;
+  sbat->blockSize = (uint64) 1 << header->s_shift;
   
   blocks = getbbatBlocks(true);
   
   // load big bat
-  buflen = (unsigned int) blocks.size()*bbat->blockSize;
+  buflen = static_cast<uint64>(blocks.size())*bbat->blockSize;
   if( buflen > 0 )
   {
     buffer = new unsigned char[ buflen ];  
@@ -1292,7 +1338,7 @@ void StorageIO::load(bool bWriteAccess)
   // load small bat
   blocks.clear();
   blocks = bbat->follow( header->sbat_start );
-  buflen = (unsigned int) blocks.size()*bbat->blockSize;
+  buflen = static_cast<uint64>(blocks.size())*bbat->blockSize;
   if( buflen > 0 )
   {
     buffer = new unsigned char[ buflen ];  
@@ -1304,7 +1350,7 @@ void StorageIO::load(bool bWriteAccess)
   // load directory tree
   blocks.clear();
   blocks = bbat->follow( header->dirent_start );
-  buflen = (unsigned int) blocks.size()*bbat->blockSize;
+  buflen = static_cast<uint64>(blocks.size())*bbat->blockSize;
   buffer = new unsigned char[ buflen ];  
   loadBigBlocks( blocks, buffer, buflen );
   dirtree->load( buffer, buflen );
@@ -1327,11 +1373,14 @@ void StorageIO::load(bool bWriteAccess)
   opened = true;
 }
 
-void StorageIO::create()
-{
+void StorageIO::create() {
   // std::cout << "Creating " << filename << std::endl; 
   
+#if defined(POLE_USE_UTF16_FILENAMES)
+  file.open(UTF8toUTF16(filename).c_str(), std::ios::binary | std::ios::in | std::ios::out | std::ios::trunc);
+#else
   file.open( filename.c_str(), std::ios::binary | std::ios::in | std::ios::out | std::ios::trunc);
+#endif
   if( !file.good() )
   {
     std::cerr << "Can't create " << filename << std::endl;
@@ -1382,24 +1431,24 @@ void StorageIO::flush()
         flushsbat();
     if (dirtree->isDirty())
     {
-        std::vector<unsigned int> blocks;
+        std::vector<uint64> blocks;
         blocks = bbat->follow(header->dirent_start);
-        unsigned int sb_start = 0xffffffff;
+        uint64 sb_start = 0xffffffff;
         if (sb_blocks.size() > 0)
             sb_start = sb_blocks[0];
-        dirtree->flush(blocks, this, bbat->blockSize, sb_start, (unsigned int) sb_blocks.size()*bbat->blockSize);
+        dirtree->flush(blocks, this, bbat->blockSize, sb_start, static_cast<uint64>(sb_blocks.size())*bbat->blockSize);
     }
     if (mbatDirty && mbat_blocks.size() > 0)
     {
-        unsigned int nBytes = bbat->blockSize * (unsigned int) mbat_blocks.size();
+        uint64 nBytes = bbat->blockSize * static_cast<uint64>(mbat_blocks.size());
         unsigned char *buffer = new unsigned char[nBytes];
-        unsigned int sIdx = 0;
-        unsigned int dcount = 0;
-        unsigned blockCapacity = bbat->blockSize / sizeof(unsigned int) - 1;
-        unsigned blockIdx = 0;
+        uint64 sIdx = 0;
+        uint64 dcount = 0;
+        uint64 blockCapacity = bbat->blockSize / sizeof(uint64) - 1;
+        uint64 blockIdx = 0;
         for (unsigned mdIdx = 0; mdIdx < mbat_data.size(); mdIdx++)
         {
-            writeU32(buffer + sIdx, mbat_data[mdIdx]);
+            writeU32(buffer + sIdx, (uint32) mbat_data[mdIdx]);
             sIdx += 4;
             dcount++;
             if (dcount == blockCapacity)
@@ -1408,7 +1457,7 @@ void StorageIO::flush()
                 if (blockIdx == mbat_blocks.size())
                     writeU32(buffer + sIdx, AllocTable::Eof);
                 else
-                    writeU32(buffer + sIdx, mbat_blocks[blockIdx]);
+                    writeU32(buffer + sIdx, (uint32) mbat_blocks[blockIdx]);
                 sIdx += 4;
                 dcount = 0;
             }
@@ -1440,7 +1489,7 @@ void StorageIO::close()
 }
 
 
-StreamIO* StorageIO::streamIO( const std::string& name, bool bCreate, int streamSize )
+StreamIO* StorageIO::streamIO( const std::string& name, bool bCreate, int64 streamSize )
 {
   // sanity check
   if( !name.length() ) return (StreamIO*)0;
@@ -1452,10 +1501,10 @@ StreamIO* StorageIO::streamIO( const std::string& name, bool bCreate, int stream
   //if( !entry->dir ) std::cout << "  NOT DIR\n";
   if( entry->dir ) return (StreamIO*)0;
 
-  StreamIO* result = new StreamIO( this, entry );
-  result->fullName = name;
+  StreamIO* result2 = new StreamIO( this, entry );
+  result2->fullName = name;
   
-  return result;
+  return result2;
 }
 
 bool StorageIO::deleteByName(const std::string& fullName)
@@ -1500,7 +1549,7 @@ bool StorageIO::deleteNode(DirEntry *entry, const std::string& fullName)
 
 bool StorageIO::deleteLeaf(DirEntry *entry, const std::string& fullName)
 {
-    std::vector<unsigned int> blocks;
+    std::vector<uint64> blocks;
     if (entry->size >= header->threshold)
     {
         blocks = bbat->follow(entry->start);
@@ -1523,8 +1572,8 @@ bool StorageIO::deleteLeaf(DirEntry *entry, const std::string& fullName)
     return true;
 }
 
-unsigned int StorageIO::loadBigBlocks( std::vector<unsigned int> blocks,
-  unsigned char* data, unsigned int maxlen )
+uint64 StorageIO::loadBigBlocks( std::vector<uint64> blocks,
+  unsigned char* data, uint64 maxlen )
 {
   // sentinel
   if( !data ) return 0;
@@ -1534,12 +1583,12 @@ unsigned int StorageIO::loadBigBlocks( std::vector<unsigned int> blocks,
   if( maxlen == 0 ) return 0;
 
   // read block one by one, seems fast enough
-  unsigned int bytes = 0;
+  uint64 bytes = 0;
   for( unsigned int i=0; (i < blocks.size() ) & ( bytes<maxlen ); i++ )
   {
-    unsigned int block = blocks[i];
-    unsigned int pos =  bbat->blockSize * ( block+1 );
-    unsigned long p = (bbat->blockSize < maxlen-bytes) ? bbat->blockSize : maxlen-bytes;
+    uint64 block = blocks[i];
+    uint64 pos =  bbat->blockSize * ( block+1 );
+    uint64 p = (bbat->blockSize < maxlen-bytes) ? bbat->blockSize : maxlen-bytes;
     if( pos + p > filesize )
         p = filesize - pos;
     file.seekg( pos );
@@ -1552,8 +1601,8 @@ unsigned int StorageIO::loadBigBlocks( std::vector<unsigned int> blocks,
   return bytes;
 }
 
-unsigned int StorageIO::loadBigBlock( unsigned int block,
-  unsigned char* data, unsigned int maxlen )
+uint64 StorageIO::loadBigBlock( uint64 block,
+  unsigned char* data, uint64 maxlen )
 {
   // sentinel
   if( !data ) return 0;
@@ -1561,14 +1610,14 @@ unsigned int StorageIO::loadBigBlock( unsigned int block,
   if( !file.good() ) return 0;
   
   // wraps call for loadBigBlocks
-  std::vector<unsigned int> blocks;
+  std::vector<uint64> blocks;
   blocks.resize( 1 );
   blocks[ 0 ] = block;
   
   return loadBigBlocks( blocks, data, maxlen );
 }
 
-unsigned int StorageIO::saveBigBlocks( std::vector<unsigned int> blocks, unsigned int offset, unsigned char* data, unsigned int len )
+uint64 StorageIO::saveBigBlocks( std::vector<uint64> blocks, uint64 offset, unsigned char* data, uint64 len )
 {
   // sentinel
   if( !data ) return 0;
@@ -1578,13 +1627,13 @@ unsigned int StorageIO::saveBigBlocks( std::vector<unsigned int> blocks, unsigne
   if( len == 0 ) return 0;
 
   // write block one by one, seems fast enough
-  unsigned int bytes = 0;
+  uint64 bytes = 0;
   for( unsigned int i=0; (i < blocks.size() ) & ( bytes<len ); i++ )
   {
-    unsigned int block = blocks[i];
-    unsigned int pos =  (bbat->blockSize * ( block+1 ) ) + offset;
-    unsigned int maxWrite = bbat->blockSize - offset;
-    unsigned int tobeWritten = len - bytes;
+    uint64 block = blocks[i];
+    uint64 pos =  (bbat->blockSize * ( block+1 ) ) + offset;
+    uint64 maxWrite = bbat->blockSize - offset;
+    uint64 tobeWritten = len - bytes;
     if (tobeWritten > maxWrite)
         tobeWritten = maxWrite;
     file.seekp( pos );
@@ -1601,21 +1650,21 @@ unsigned int StorageIO::saveBigBlocks( std::vector<unsigned int> blocks, unsigne
 
 }
 
-unsigned int StorageIO::saveBigBlock( unsigned int block, unsigned int offset, unsigned char* data, unsigned int len )
+uint64 StorageIO::saveBigBlock( uint64 block, uint64 offset, unsigned char* data, uint64 len )
 {
     if ( !data ) return 0;
     fileCheck(file);
     if ( !file.good() ) return 0;
     //wrap call for saveBigBlocks
-    std::vector<unsigned int> blocks;
+    std::vector<uint64> blocks;
     blocks.resize( 1 );
     blocks[ 0 ] = block;
     return saveBigBlocks(blocks, offset, data, len );
 }
 
 // return number of bytes which has been read
-unsigned int StorageIO::loadSmallBlocks( std::vector<unsigned int> blocks,
-  unsigned char* data, unsigned int maxlen )
+uint64 StorageIO::loadSmallBlocks( std::vector<uint64> blocks,
+  unsigned char* data, uint64 maxlen )
 {
   // sentinel
   if( !data ) return 0;
@@ -1628,21 +1677,21 @@ unsigned int StorageIO::loadSmallBlocks( std::vector<unsigned int> blocks,
   unsigned char* buf = new unsigned char[ bbat->blockSize ];
 
   // read small block one by one
-  unsigned int bytes = 0;
+  uint64 bytes = 0;
   for( unsigned int i=0; ( i<blocks.size() ) & ( bytes<maxlen ); i++ )
   {
-    unsigned int block = blocks[i];
+    uint64 block = blocks[i];
 
     // find where the small-block exactly is
-    unsigned int pos = block * sbat->blockSize;
-    unsigned int bbindex = pos / bbat->blockSize;
+    uint64 pos = block * sbat->blockSize;
+    uint64 bbindex = pos / bbat->blockSize;
     if( bbindex >= sb_blocks.size() ) break;
 
     loadBigBlock( sb_blocks[ bbindex ], buf, bbat->blockSize );
 
     // copy the data
-    unsigned offset = pos % bbat->blockSize;
-    unsigned int p = (maxlen-bytes < bbat->blockSize-offset ) ? maxlen-bytes :  bbat->blockSize-offset;
+    uint64 offset = pos % bbat->blockSize;
+    uint64 p = (maxlen-bytes < bbat->blockSize-offset ) ? maxlen-bytes :  bbat->blockSize-offset;
     p = (sbat->blockSize<p ) ? sbat->blockSize : p;
     memcpy( data + bytes, buf + offset, p );
     bytes += p;
@@ -1653,8 +1702,8 @@ unsigned int StorageIO::loadSmallBlocks( std::vector<unsigned int> blocks,
   return bytes;
 }
 
-unsigned int StorageIO::loadSmallBlock( unsigned int block,
-  unsigned char* data, unsigned int maxlen )
+uint64 StorageIO::loadSmallBlock( uint64 block,
+  unsigned char* data, uint64 maxlen )
 {
   // sentinel
   if( !data ) return 0;
@@ -1662,7 +1711,7 @@ unsigned int StorageIO::loadSmallBlock( unsigned int block,
   if( !file.good() ) return 0;
 
   // wraps call for loadSmallBlocks
-  std::vector<unsigned int> blocks;
+  std::vector<uint64> blocks;
   blocks.resize( 1 );
   blocks.assign( 1, block );
 
@@ -1670,8 +1719,8 @@ unsigned int StorageIO::loadSmallBlock( unsigned int block,
 }
 
 
-unsigned int StorageIO::saveSmallBlocks( std::vector<unsigned int> blocks, unsigned int offset, 
-                                        unsigned char* data, unsigned int len, int startAtBlock )
+uint64 StorageIO::saveSmallBlocks( std::vector<uint64> blocks, uint64 offset, 
+                                        unsigned char* data, uint64 len, int64 startAtBlock )
 {
   // sentinel
   if( !data ) return 0;
@@ -1681,17 +1730,17 @@ unsigned int StorageIO::saveSmallBlocks( std::vector<unsigned int> blocks, unsig
   if( len == 0 ) return 0;
 
   // write block one by one, seems fast enough
-  unsigned int bytes = 0;
-  for( unsigned int i = startAtBlock; (i < blocks.size() ) & ( bytes<len ); i++ )
+  uint64 bytes = 0;
+  for( uint64 i = startAtBlock; (i < blocks.size() ) & ( bytes<len ); i++ )
   {
-    unsigned int block = blocks[i];
+    uint64 block = blocks[i];
      // find where the small-block exactly is
-    unsigned int pos = block * sbat->blockSize;
-    unsigned int bbindex = pos / bbat->blockSize;
+    uint64 pos = block * sbat->blockSize;
+    uint64 bbindex = pos / bbat->blockSize;
     if( bbindex >= sb_blocks.size() ) break;
-    unsigned offset2 = pos % bbat->blockSize;
-    unsigned int maxWrite = sbat->blockSize - offset;
-    unsigned int tobeWritten = len - bytes;
+    uint64 offset2 = pos % bbat->blockSize;
+    uint64 maxWrite = sbat->blockSize - offset;
+    uint64 tobeWritten = len - bytes;
     if (tobeWritten > maxWrite)
         tobeWritten = maxWrite;
     saveBigBlock( sb_blocks[ bbindex ], offset2 + offset, data + bytes, tobeWritten);
@@ -1703,13 +1752,13 @@ unsigned int StorageIO::saveSmallBlocks( std::vector<unsigned int> blocks, unsig
   return bytes;
 }
 
-unsigned int StorageIO::saveSmallBlock( unsigned int block, unsigned int offset, unsigned char* data, unsigned int len )
+uint64 StorageIO::saveSmallBlock( uint64 block, uint64 offset, unsigned char* data, uint64 len )
 {
     if ( !data ) return 0;
     fileCheck(file);
     if ( !file.good() ) return 0;
     //wrap call for saveSmallBlocks
-    std::vector<unsigned int> blocks;
+    std::vector<uint64> blocks;
     blocks.resize( 1 );
     blocks[ 0 ] = block;
     return saveSmallBlocks(blocks, offset, data, len );
@@ -1717,21 +1766,21 @@ unsigned int StorageIO::saveSmallBlock( unsigned int block, unsigned int offset,
 
 void StorageIO::flushbbat()
 {
-    std::vector<unsigned int> blocks;
+    std::vector<uint64> blocks;
     blocks = getbbatBlocks(false);
     bbat->flush(blocks, this, bbat->blockSize);
 }
 
 void StorageIO::flushsbat()
 {
-    std::vector<unsigned int> blocks;
+    std::vector<uint64> blocks;
     blocks = bbat->follow(header->sbat_start);
     sbat->flush(blocks, this, bbat->blockSize);
 }
 
-std::vector<unsigned int> StorageIO::getbbatBlocks(bool bLoading)
+std::vector<uint64> StorageIO::getbbatBlocks(bool bLoading)
 {
-    std::vector<unsigned int> blocks;
+    std::vector<uint64> blocks;
     // find blocks allocated to store big bat
     // the first 109 blocks are in header, the rest in meta bat
     blocks.clear();
@@ -1751,10 +1800,10 @@ std::vector<unsigned int> StorageIO::getbbatBlocks(bool bLoading)
         if( (header->num_bat > 109) && (header->num_mbat > 0) ) 
         {
             unsigned char* buffer2 = new unsigned char[ bbat->blockSize ];
-            unsigned k = 109;
-            unsigned sector;
-            unsigned mdidx = 0;
-            for( unsigned r = 0; r < header->num_mbat; r++ )
+            uint64 k = 109;
+            uint64 sector;
+            uint64 mdidx = 0;
+            for( uint64 r = 0; r < header->num_mbat; r++ )
             {
                 if(r == 0) // 1st meta bat location is in file header.
                     sector = header->mbat_start;
@@ -1766,7 +1815,7 @@ std::vector<unsigned int> StorageIO::getbbatBlocks(bool bLoading)
                 mbat_blocks.push_back(sector);
                 mbat_data.resize(mbat_blocks.size()*(bbat->blockSize/4));
                 loadBigBlock( sector, buffer2, bbat->blockSize );
-                for( unsigned s=0; s < bbat->blockSize; s+=4 )
+                for( uint64 s=0; s < bbat->blockSize; s+=4 )
                 {
                     if( k >= header->num_bat )
                         break;
@@ -1795,11 +1844,11 @@ std::vector<unsigned int> StorageIO::getbbatBlocks(bool bLoading)
     return blocks;
 }
 
-unsigned int StorageIO::ExtendFile( std::vector<unsigned int> *chain )
+uint64 StorageIO::ExtendFile( std::vector<uint64> *chain )
 {
-    unsigned int newblockIdx = bbat->unused();
+    uint64 newblockIdx = bbat->unused();
     bbat->set(newblockIdx, AllocTable::Eof);
-    unsigned int bbidx = newblockIdx / (bbat->blockSize / sizeof(unsigned int));
+    uint64 bbidx = newblockIdx / (bbat->blockSize / sizeof(uint64));
     while (bbidx >= header->num_bat)
         addbbatBlock();
     bbat->markAsDirty(newblockIdx, bbat->blockSize);
@@ -1814,7 +1863,7 @@ unsigned int StorageIO::ExtendFile( std::vector<unsigned int> *chain )
 
 void StorageIO::addbbatBlock()
 {
-    unsigned int newblockIdx = bbat->unused();
+    uint64 newblockIdx = bbat->unused();
     bbat->set(newblockIdx, AllocTable::MetaBat);
 
     if (header->num_bat < 109)
@@ -1823,12 +1872,12 @@ void StorageIO::addbbatBlock()
     {
         mbatDirty = true;
         mbat_data.push_back(newblockIdx);
-        unsigned metaIdx = header->num_bat - 109;
-        unsigned idxPerBlock = bbat->blockSize / sizeof(unsigned int) - 1; //reserve room for index to next block
-        unsigned idxBlock = metaIdx / idxPerBlock;
+        uint64 metaIdx = header->num_bat - 109;
+        uint64 idxPerBlock = bbat->blockSize / sizeof(uint64) - 1; //reserve room for index to next block
+        uint64 idxBlock = metaIdx / idxPerBlock;
         if (idxBlock == mbat_blocks.size())
         {
-            unsigned int newmetaIdx = bbat->unused();
+            uint64 newmetaIdx = bbat->unused();
             bbat->set(newmetaIdx, AllocTable::MetaBat);
             mbat_blocks.push_back(newmetaIdx);
             if (header->num_mbat == 0)
@@ -1844,23 +1893,21 @@ void StorageIO::addbbatBlock()
 // =========== StreamIO ==========
 
 StreamIO::StreamIO( StorageIO* s, DirEntry* e)
+:   io(s),
+    entryIdx(io->dirtree->indexOf(e)),
+    fullName(),
+    blocks(),
+    eof(false),
+    fail(false),
+    m_pos(0),
+    cache_data(new unsigned char[CACHEBUFSIZE]),        
+    cache_size(0),         // indicating an empty cache
+    cache_pos(0)
 {
-  io = s;
-  entryIdx = io->dirtree->indexOf(e);
-  eof = false;
-  fail = false;
-  
-  m_pos = 0;
-
   if( e->size >= io->header->threshold ) 
     blocks = io->bbat->follow( e->start );
   else
     blocks = io->sbat->follow( e->start );
-
-  // prepare cache
-  cache_pos = 0;
-  cache_size = 0; // indicating an empty cache
-  cache_data = new unsigned char[CACHEBUFSIZE];
 }
 
 // FIXME tell parent we're gone
@@ -1869,7 +1916,7 @@ StreamIO::~StreamIO()
   delete[] cache_data;  
 }
 
-void StreamIO::setSize(unsigned int newSize)
+void StreamIO::setSize(uint64 newSize)
 {
     bool bThresholdCrossed = false;
     bool bOver = false;
@@ -1891,11 +1938,11 @@ void StreamIO::setSize(unsigned int newSize)
     {
         // first, read what is already in the stream, limited by the requested new size. Note
         // that the read can work precisely because we have not yet reset the size.
-        unsigned int len = newSize;
+        uint64 len = newSize;
         if (len > entry->size)
             len = entry->size;
         unsigned char *buffer = 0;
-        unsigned int savePos = tell();
+        uint64 savePos = tell();
         if (len)
         {
             buffer = new unsigned char[len];
@@ -1927,7 +1974,7 @@ void StreamIO::setSize(unsigned int newSize)
         if (len)
         {
             write(0, buffer, len);
-            delete buffer;
+            delete [] buffer;
         }
         if (savePos <= entry->size)
             seek(savePos);
@@ -1940,17 +1987,17 @@ void StreamIO::setSize(unsigned int newSize)
 
 }
 
-void StreamIO::seek( unsigned int pos )
+void StreamIO::seek( uint64 pos )
 {
   m_pos = pos;
 }
 
-unsigned int StreamIO::tell()
+uint64 StreamIO::tell()
 {
   return m_pos;
 }
 
-int StreamIO::getch()
+int64 StreamIO::getch()
 {
   // past end-of-file ?
   DirEntry *entry = io->dirtree->entry(entryIdx);
@@ -1964,19 +2011,19 @@ int StreamIO::getch()
   // something bad if we don't get good cache
   if( !cache_size ) return -1;
 
-  int data = cache_data[m_pos - cache_pos];
+  int64 data = cache_data[m_pos - cache_pos];
   m_pos++;
 
   return data;
 }
 
-unsigned int StreamIO::read( unsigned int pos, unsigned char* data, unsigned int maxlen )
+uint64 StreamIO::read( uint64 pos, unsigned char* data, uint64 maxlen )
 {
   // sanity checks
   if( !data ) return 0;
   if( maxlen == 0 ) return 0;
 
-  unsigned int totalbytes = 0;
+  uint64 totalbytes = 0;
   
   DirEntry *entry = io->dirtree->entry(entryIdx);
   if (pos + maxlen > entry->size)
@@ -1984,17 +2031,17 @@ unsigned int StreamIO::read( unsigned int pos, unsigned char* data, unsigned int
   if ( entry->size < io->header->threshold )
   {
     // small file
-    unsigned int index = pos / io->sbat->blockSize;
+    uint64 index = pos / io->sbat->blockSize;
 
     if( index >= blocks.size() ) return 0;
 
     unsigned char* buf = new unsigned char[ io->sbat->blockSize ];
-    unsigned int offset = pos % io->sbat->blockSize;
+    uint64 offset = pos % io->sbat->blockSize;
     while( totalbytes < maxlen )
     {
       if( index >= blocks.size() ) break;
       io->loadSmallBlock( blocks[index], buf, io->bbat->blockSize );
-      unsigned int count = io->sbat->blockSize - offset;
+      uint64 count = io->sbat->blockSize - offset;
       if( count > maxlen-totalbytes ) count = maxlen-totalbytes;
       memcpy( data+totalbytes, buf + offset, count );
       totalbytes += count;
@@ -2007,17 +2054,17 @@ unsigned int StreamIO::read( unsigned int pos, unsigned char* data, unsigned int
   else
   {
     // big file
-    unsigned int index = pos / io->bbat->blockSize;
+    uint64 index = pos / io->bbat->blockSize;
     
     if( index >= blocks.size() ) return 0;
     
     unsigned char* buf = new unsigned char[ io->bbat->blockSize ];
-    unsigned int offset = pos % io->bbat->blockSize;
+    uint64 offset = pos % io->bbat->blockSize;
     while( totalbytes < maxlen )
     {
       if( index >= blocks.size() ) break;
       io->loadBigBlock( blocks[index], buf, io->bbat->blockSize );
-      unsigned int count = io->bbat->blockSize - offset;
+      uint64 count = io->bbat->blockSize - offset;
       if( count > maxlen-totalbytes ) count = maxlen-totalbytes;
       memcpy( data+totalbytes, buf + offset, count );
       totalbytes += count;
@@ -2031,19 +2078,19 @@ unsigned int StreamIO::read( unsigned int pos, unsigned char* data, unsigned int
   return totalbytes;
 }
 
-unsigned int StreamIO::read( unsigned char* data, unsigned int maxlen )
+uint64 StreamIO::read( unsigned char* data, uint64 maxlen )
 {
-  unsigned int bytes = read( tell(), data, maxlen );
+  uint64 bytes = read( tell(), data, maxlen );
   m_pos += bytes;
   return bytes;
 }
 
-unsigned int StreamIO::write( unsigned char* data, unsigned int len )
+uint64 StreamIO::write( unsigned char* data, uint64 len )
 {
   return write( tell(), data, len );
 }
 
-unsigned int StreamIO::write( unsigned int pos, unsigned char* data, unsigned int len )
+uint64 StreamIO::write( uint64 pos, unsigned char* data, uint64 len )
 {
   // sanity checks
   if( !data ) return 0;
@@ -2053,14 +2100,14 @@ unsigned int StreamIO::write( unsigned int pos, unsigned char* data, unsigned in
   DirEntry *entry = io->dirtree->entry(entryIdx);
   if (pos + len > entry->size)
       setSize(pos + len); //reset size, possibly changing from small to large blocks
-  unsigned int totalbytes = 0;
+  uint64 totalbytes = 0;
   if ( entry->size < io->header->threshold )
   {
     // small file
-    unsigned int index = (pos + len - 1) / io->sbat->blockSize;
+    uint64 index = (pos + len - 1) / io->sbat->blockSize;
     while (index >= blocks.size())
     {
-        unsigned int nblock = io->sbat->unused();
+        uint64 nblock = io->sbat->unused();
         if (blocks.size() > 0)
         {
             io->sbat->set(blocks[blocks.size()-1], nblock);
@@ -2070,34 +2117,38 @@ unsigned int StreamIO::write( unsigned int pos, unsigned char* data, unsigned in
         io->sbat->markAsDirty(nblock, io->bbat->blockSize);
         blocks.resize(blocks.size()+1);
         blocks[blocks.size()-1] = nblock;
-        unsigned int bbidx = nblock / (io->bbat->blockSize / sizeof(unsigned int));
+        uint64 bbidx = nblock / (io->bbat->blockSize / sizeof(unsigned int));
         while (bbidx >= io->header->num_sbat)
         {
-            std::vector<unsigned int> sbat_blocks = io->bbat->follow(io->header->sbat_start);
+            std::vector<uint64> sbat_blocks = io->bbat->follow(io->header->sbat_start);
             io->ExtendFile(&sbat_blocks);
             io->header->num_sbat++;
+            io->header->dirty = true; //Header will have to be rewritten
         }
-        unsigned int sidx = nblock * io->sbat->blockSize / io->bbat->blockSize;
-        while (sidx >= io->sb_blocks.size())
+        uint64 sidx = nblock * io->sbat->blockSize / io->bbat->blockSize;
+        while (sidx >= io->sb_blocks.size()) 
+        {
             io->ExtendFile(&io->sb_blocks);
+            io->dirtree->markAsDirty(0, io->bbat->blockSize); //make sure to rewrite first directory block
+        }
     }
-    unsigned int offset = pos % io->sbat->blockSize;
+    uint64 offset = pos % io->sbat->blockSize;
     index = pos / io->sbat->blockSize;
     //if (index == 0)
         totalbytes = io->saveSmallBlocks(blocks, offset, data, len, index);
   }
   else
   {
-    unsigned int index = (pos + len - 1) / io->bbat->blockSize;
+    uint64 index = (pos + len - 1) / io->bbat->blockSize;
     while (index >= blocks.size())
         io->ExtendFile(&blocks);
-    unsigned int offset = pos % io->bbat->blockSize;
-    unsigned int remainder = len;
+    uint64 offset = pos % io->bbat->blockSize;
+    uint64 remainder = len;
     index = pos / io->bbat->blockSize;
     while( remainder > 0 )
     {
       if( index >= blocks.size() ) break;
-      unsigned int count = io->bbat->blockSize - offset;
+      uint64 count = io->bbat->blockSize - offset;
       if ( remainder < count )
           count = remainder;
       io->saveBigBlock( blocks[index], offset, data + totalbytes, count );
@@ -2114,7 +2165,6 @@ unsigned int StreamIO::write( unsigned int pos, unsigned char* data, unsigned in
   }
   m_pos += len;
   return totalbytes;
-
 }
 
 void StreamIO::flush()
@@ -2129,7 +2179,7 @@ void StreamIO::updateCache()
 
   DirEntry *entry = io->dirtree->entry(entryIdx);
   cache_pos = m_pos - (m_pos % CACHEBUFSIZE);
-  unsigned int bytes = CACHEBUFSIZE;
+  uint64 bytes = CACHEBUFSIZE;
   if( cache_pos + bytes > entry->size ) bytes = entry->size - cache_pos;
   cache_size = read( cache_pos, cache_data, bytes );
 }
@@ -2149,7 +2199,7 @@ Storage::~Storage()
 
 int Storage::result()
 {
-  return io->result;
+  return (int) io->result;
 }
 
 bool Storage::open(bool bWriteAccess, bool bCreate)
@@ -2164,18 +2214,18 @@ void Storage::close()
 
 std::list<std::string> Storage::entries( const std::string& path )
 {
-  std::list<std::string> result;
+  std::list<std::string> localResult;
   DirTree* dt = io->dirtree;
   DirEntry* e = dt->entry( path, false );
   if( e  && e->dir )
   {
-    unsigned parent = dt->indexOf( e );
-    std::vector<unsigned> children = dt->children( parent );
-    for( unsigned i = 0; i < children.size(); i++ )
-      result.push_back( dt->entry( children[i] )->name );
+    uint64 parent = dt->indexOf( e );
+    std::vector<uint64> children = dt->children( parent );
+    for( uint64 i = 0; i < children.size(); i++ )
+      localResult.push_back( dt->entry( children[i] )->name );
   }
   
-  return result;
+  return localResult;
 }
 
 bool Storage::isDirectory( const std::string& name )
@@ -2200,9 +2250,9 @@ bool Storage::deleteByName( const std::string& name )
   return io->deleteByName(name);
 }
 
-void Storage::GetStats(unsigned int *pEntries, unsigned int *pUnusedEntries,
-      unsigned int *pBigBlocks, unsigned int *pUnusedBigBlocks,
-      unsigned int *pSmallBlocks, unsigned int *pUnusedSmallBlocks)
+void Storage::GetStats(uint64 *pEntries, uint64 *pUnusedEntries,
+      uint64 *pBigBlocks, uint64 *pUnusedBigBlocks,
+      uint64 *pSmallBlocks, uint64 *pUnusedSmallBlocks)
 {
     *pEntries = io->dirtree->entryCount();
     *pUnusedEntries = io->dirtree->unusedEntryCount();
@@ -2212,11 +2262,41 @@ void Storage::GetStats(unsigned int *pEntries, unsigned int *pUnusedEntries,
     *pUnusedSmallBlocks = io->sbat->unusedCount();
 }
 
+// recursively collect stream names
+void CollectStreams( std::list<std::string>& result, DirTree* tree, DirEntry* parent, const std::string& path )
+{
+  DirEntry* c = tree->entry( parent->child );
+  std::queue<DirEntry*> queue;
+  if ( c ) queue.push( c );
+  while ( !queue.empty() ) {
+    DirEntry* e = queue.front();
+    queue.pop();
+    if ( e->dir )
+      CollectStreams( result, tree, e, path + e->name + "/" );
+    else
+      result.push_back( path + e->name );
+    DirEntry* p = tree->entry( e->prev );
+    if ( p ) queue.push( p );
+    DirEntry* n = tree->entry( e->next );
+    if ( n ) queue.push( n );
+    // not testing if p or n have already been processed; potential infinite loop in case of closed Entry chain
+    // it seems not to happen, though
+  }
+}
+
+std::list<std::string> Storage::GetAllStreams( const std::string& storageName )
+{
+  std::list<std::string> vresult;
+  DirEntry* e = io->dirtree->entry( storageName, false );
+  if ( e && e->dir ) CollectStreams( vresult, io->dirtree, e, storageName );
+  return vresult;
+}
+
 // =========== Stream ==========
 
-Stream::Stream( Storage* storage, const std::string& name, bool bCreate, long streamSize )
+Stream::Stream( Storage* storage, const std::string& name, bool bCreate, int64 streamSize )
+:   io(storage->io->streamIO( name, bCreate, (int) streamSize ))
 {
-  io = storage->io->streamIO( name, bCreate, (int) streamSize );
 }
 
 // FIXME tell parent we're gone
@@ -2230,18 +2310,18 @@ std::string Stream::fullName()
   return io ? io->fullName : std::string();
 }
 
-unsigned long Stream::tell()
+uint64 Stream::tell()
 {
   return io ? io->tell() : 0;
 }
 
-void Stream::seek( unsigned long newpos )
+void Stream::seek( uint64 newpos )
 {
   if( io )
-      io->seek( (unsigned int) newpos );
+      io->seek(newpos);
 }
 
-unsigned long Stream::size()
+uint64 Stream::size()
 {
     if (!io)
         return 0;
@@ -2249,28 +2329,28 @@ unsigned long Stream::size()
     return entry->size;
 }
 
-void Stream::setSize(long newSize)
+void Stream::setSize(int64 newSize)
 {
     if (!io)
         return;
     if (newSize < 0)
         return;
-    if (newSize > UINT_MAX)
+    if (newSize > std::numeric_limits<int64>::max())
         return;
-    io->setSize((unsigned int) newSize);
+    io->setSize(newSize);
 }
 
-int Stream::getch()
+int64 Stream::getch()
 {
   return io ? io->getch() : 0;
 }
 
-unsigned int Stream::read( unsigned char* data, unsigned int maxlen )
+uint64 Stream::read( unsigned char* data, uint64 maxlen )
 {
   return io ? io->read( data, maxlen ) : 0;
 }
 
-unsigned int Stream::write( unsigned char* data, unsigned int len )
+uint64 Stream::write( unsigned char* data, uint64 len )
 {
     return io ? io->write( data, len ) : 0;
 }
diff --git a/pole/pole.h b/pole/pole.h
index 1b36076..425f155 100644
--- a/pole/pole.h
+++ b/pole/pole.h
@@ -1,16 +1,22 @@
 /* POLE - Portable C++ library to access OLE Storage 
    Copyright (C) 2002-2005 Ariya Hidayat <ariya@kde.org>
 
-   Performance optimization: Dmitry Fedorov 
-   Copyright 2009 <www.bioimage.ucsb.edu> <www.dimin.net> 
+   Performance optimization, API improvements: Dmitry Fedorov 
+   Copyright 2009-2014 <www.bioimage.ucsb.edu> <www.dimin.net> 
 
    Fix for more than 236 mbat block entries : Michel Boudinot
    Copyright 2010 <Michel.Boudinot@inaf.cnrs-gif.fr>
 
    Considerable rework to allow for creation and updating of structured storage: Stephen Baum
-   Copyright 2013 <sbaum@gmail.com>
+   Copyright 2013 <srbaum@gmail.com>
 
-   Version: 0.5
+   Added GetAllStreams, reworked datatypes
+   Copyright 2013 Felix Gorny from Bitplane
+   
+   More datatype changes to allow for 32 and 64 bit code, some fixes involving incremental updates, flushing
+   Copyright 2013 <srbaum@gmail.com>
+   
+   Version: 0.5.3
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
@@ -37,15 +43,49 @@
    THE POSSIBILITY OF SUCH DAMAGE.
 */
 
+/*
+Unicode notes:
+
+Filenames are considered to be encoded in UTF-8 encoding. On windows they 
+can be re-encoded into UTF16 and proper wchar_t APIs will be used to open files.
+This is a default behavior for windows and is defined by the macro POLE_USE_UTF16_FILENAMES.
+
+Using a provided function and a modern c++ compiler it's easy to encode a 
+wide string into utf8 char*:
+    std::string POLE::UTF16toUTF8(const std::wstring &utf16);
+*/
+
 #ifndef POLE_H
 #define POLE_H
 
+#include <cstdio>
 #include <string>
 #include <list>
 
 namespace POLE
 {
 
+#if defined WIN32 || defined WIN64 || defined _WIN32 || defined _WIN64 || defined _MSVC
+#define POLE_USE_UTF16_FILENAMES
+#define POLE_WIN
+typedef __int32 int32;
+typedef __int64 int64;
+typedef unsigned __int32 uint32;
+typedef unsigned __int64 uint64;
+#else
+typedef int int32;
+typedef long long int64;
+typedef unsigned int uint32;
+typedef unsigned long long uint64;
+#endif
+
+typedef uint64 t_offset;
+
+#ifdef POLE_USE_UTF16_FILENAMES
+std::string UTF16toUTF8(const std::wstring &utf16);
+std::wstring UTF8toUTF16(const std::string &utf8);
+#endif //POLE_USE_UTF16_FILENAMES
+
 class StorageIO;
 class Stream;
 class StreamIO;
@@ -117,9 +157,11 @@ public:
    * should be defragmented.
    */
 
-  void GetStats(unsigned int *pEntries, unsigned int *pUnusedEntries,
-      unsigned int *pBigBlocks, unsigned int *pUnusedBigBlocks,
-      unsigned int *pSmallBlocks, unsigned int *pUnusedSmallBlocks);
+  void GetStats(uint64 *pEntries, uint64 *pUnusedEntries,
+      uint64 *pBigBlocks, uint64 *pUnusedBigBlocks,
+      uint64 *pSmallBlocks, uint64 *pUnusedSmallBlocks);
+
+  std::list<std::string> GetAllStreams( const std::string& storageName );
 
 private:
   StorageIO* io;
@@ -141,7 +183,7 @@ public:
    * Creates a new stream.
    */
   // name must be absolute, e.g "/Workbook"
-  Stream( Storage* storage, const std::string& name, bool bCreate = false, long streamSize = 0);
+  Stream( Storage* storage, const std::string& name, bool bCreate = false, int64 streamSize = 0);
 
   /**
    * Destroys the stream.
@@ -156,39 +198,39 @@ public:
   /**
    * Returns the stream size.
    **/
-  unsigned long size();
+  uint64 size();
 
   /**
    * Changes the stream size (note this is done automatically if you write beyond the old size.
    * Use this primarily as a preamble to rewriting a stream that is already open. Of course, you
    * could simply delete the stream first).
    **/
-  void setSize(long newSize);
+  void setSize(int64 newSize);
 
   /**
    * Returns the current read/write position.
    **/
-  unsigned long tell();
+  uint64 tell();
 
   /**
    * Sets the read/write position.
    **/
-  void seek( unsigned long pos ); 
+  void seek( uint64 pos ); 
 
   /**
    * Reads a byte.
    **/
-  int getch();
+  int64 getch();
 
   /**
    * Reads a block of data.
    **/
-  unsigned int read( unsigned char* data, unsigned int maxlen );
+  uint64 read( unsigned char* data, uint64 maxlen );
   
   /**
    * Writes a block of data.
    **/
-  unsigned int write( unsigned char* data, unsigned int len );
+  uint64 write( unsigned char* data, uint64 len );
 
   /**
    * Makes sure that any changes for the stream (and the structured storage) have been written to disk.
diff --git a/pole/poleview.h b/pole/poleview.h
index 1cf91be..182271b 100644
--- a/pole/poleview.h
+++ b/pole/poleview.h
@@ -20,8 +20,22 @@
 #ifndef POLEVIEW
 #define POLEVIEW
 
-#include <QtCore>
-#include <QtGui>
+#include <QApplication>
+#include <QMainWindow>
+#include <QMenu>
+#include <QTreeWidget>
+#include <QDialog>
+#include <QLabel>
+#include <QTextEdit>
+#include <QTreeWidget>
+#include <QAction>
+#include <QMenuBar>
+#include <QStatusBar>
+#include <QTime>
+#include <QMessageBox>
+#include <QFileDialog>
+#include <QTimer>
+#include <QVBoxLayout>
 
 #include "pole.h"
 
diff --git a/pole/poleview.pro b/pole/poleview.pro
index 6e7bfa3..481267d 100644
--- a/pole/poleview.pro
+++ b/pole/poleview.pro
@@ -1,3 +1,7 @@
+QT       += core gui
+
+greaterThan(QT_MAJOR_VERSION, 4): QT += widgets
+
 TEMPLATE = app
 TARGET = poleview
 
